<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.1.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/icon.jpg">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/icon.jpg">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/icon.jpg">
  <link rel="mask-icon" href="/images/icon.jpg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://Beritra.github.com').hostname,
    root: '/',
    scheme: 'Pisces',
    version: '7.6.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta name="description" content="NoSQL 几乎是必备的知识，其中 Redis 大概是适用范围最广的非关系型数据库，应该也是我个人接触比较早，了解比较多的，因此整理下 Redis 的相关知识点。先从比较基础的内容整理开始，后续更多复杂和深入的内容考虑慢慢补充或者再开专门的文章来整理。">
<meta property="og:type" content="article">
<meta property="og:title" content="关于Redis应该知道的">
<meta property="og:url" content="http:&#x2F;&#x2F;beritra.github.com&#x2F;2020&#x2F;02&#x2F;26&#x2F;%E5%85%B3%E4%BA%8ERedis%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84&#x2F;index.html">
<meta property="og:site_name" content="Beritra">
<meta property="og:description" content="NoSQL 几乎是必备的知识，其中 Redis 大概是适用范围最广的非关系型数据库，应该也是我个人接触比较早，了解比较多的，因此整理下 Redis 的相关知识点。先从比较基础的内容整理开始，后续更多复杂和深入的内容考虑慢慢补充或者再开专门的文章来整理。">
<meta property="article:published_time" content="2020-02-25T17:23:14.000Z">
<meta property="article:modified_time" content="2020-02-25T17:25:21.998Z">
<meta property="article:author" content="Beritra">
<meta property="article:tag" content="数据库">
<meta property="article:tag" content="redis">
<meta property="article:tag" content="NoSQL">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://beritra.github.com/2020/02/26/%E5%85%B3%E4%BA%8ERedis%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true
  };
</script>

  <title>关于Redis应该知道的 | Beritra</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Beritra</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">Blogs</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="搜索..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://beritra.github.com/2020/02/26/%E5%85%B3%E4%BA%8ERedis%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avator.jpg">
      <meta itemprop="name" content="Beritra">
      <meta itemprop="description" content="Beritra's Blogs">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Beritra">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          关于Redis应该知道的
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-02-26 01:23:14 / 修改时间：01:25:21" itemprop="dateCreated datePublished" datetime="2020-02-26T01:23:14+08:00">2020-02-26</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index">
                    <span itemprop="name">数据库</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>14k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>24 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>NoSQL 几乎是必备的知识，其中 Redis 大概是适用范围最广的非关系型数据库，应该也是我个人接触比较早，了解比较多的，因此整理下 Redis 的相关知识点。先从比较基础的内容整理开始，后续更多复杂和深入的内容考虑慢慢补充或者再开专门的文章来整理。</p>
<a id="more"></a>

<h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p>直接抄来的一些关于Redisd的简介：</p>
<p>Redis 是一个高性能的key-value数据库。 </p>
<p>Redis 有以下优势：</p>
<ul>
<li>性能极高 – Redis能读的速度是110000次/s,写的速度是81000次/s 。</li>
<li>丰富的数据类型 – Redis支持二进制案例的 Strings, Lists, Hashes, Sets 及 Ordered Sets 数据类型操作。</li>
<li>原子 – Redis的所有操作都是原子性的，意思就是要么成功执行要么失败完全不执行。单个操作是原子性的。多个操作也支持事务，即原子性，通过MULTI和EXEC指令包起来。</li>
<li>丰富的特性 – Redis还支持 publish/subscribe, 通知, key 过期等等特性。</li>
</ul>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>Redis 能用来做什么？互联网公司一般怎么使用它？</p>
<p>除了常见的缓存（cache），Redis 能做的还有很多，比如：</p>
<ul>
<li>分布式锁:<a href="https://segmentfault.com/a/1190000012919740" target="_blank" rel="noopener">基于 Redis 的分布式锁实现</a></li>
<li>排序:<a href="http://doc.redisfans.com/key/sort.html" target="_blank" rel="noopener">sort 命令</a></li>
<li>去重:小数据量可以直接用 Redis 的 Set 来去重，数据量非常大而且不要是百分百的精准可以考虑用布隆过滤器。 </li>
<li>计数器:简单方式用<code>incr()</code> </li>
</ul>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>Redis 有 5 种常用的基础数据结构，分别为:string (字符串)、list (列表)、set (集合)、hash (哈 希) 和 zset (有序集合)。熟练掌握这 5 种基本数据结构的使用是 Redis 知识最基础也最重要的部分，它也是在 Redis 面试题中问到最多的内容。除此之外，Redis 官网上还提到了三种数据类型：Bit arrays 、HyperLogLogs和Streams。</p>
<h3 id="key"><a href="#key" class="headerlink" title="key"></a>key</h3><p>官网上这么介绍 Redis 的 key：</p>
<p>Redis密钥是二进制安全的，这意味着您可以使用任何二进制序列作为密钥，从“ foo”之类的字符串到JPEG文件的内容。空字符串也是有效的键。有关密钥的其他一些规则：</p>
<ul>
<li>太长的密钥不是一个好主意。例如，一个1024字节的密钥是一个坏主意，不仅是内存方面的问题，而且因为在数据集中查找密钥可能需要进行一些代价高昂的密钥比较。即使当手头的任务是匹配一个大值的存在时，对它进行散列（例如使用SHA1）也是一个更好的主意，尤其是从内存和带宽的角度来看。</li>
<li>非常短的键通常不是一个好主意。如果您可以改写“ user:1000:followers”，那么将“ u1000flw”作为密钥写的毫无意义。与键对象本身和值对象使用的空间相比，后者更具可读性，并且添加的空间较小。虽然短键显然会消耗更少的内存，但您的工作是找到合适的平衡。</li>
<li>尝试坚持使用架构。例如，“ object-type:id”是一个好主意，例如“ user:1000”。点或破折号通常用于多字字段，例如“ comment:123:reply.to”或“ comment:123:reply-to”中。</li>
<li>允许的最大密钥大小为512 MB。</li>
</ul>
<p>key 是所有数据类型通用的键，关于 key 的操作有如下几个：</p>
<ul>
<li>DEL key 删除给定的一个或多个 <code>key</code> 。不存在的 <code>key</code> 会被忽略。</li>
<li>DUMP key 序列化给定 <code>key</code> ，并返回被序列化的值，使用 <a href="http://doc.redisfans.com/key/restore.html" target="_blank" rel="noopener"><em>RESTORE</em></a> 命令可以将这个值反序列化为 Redis 键。</li>
<li>EXISTS key 检查键是否存在。若 key 存在，返回1，否则返回0。</li>
<li>EXPIRE key seconds 为给定 <code>key</code> 设置生存时间，当 <code>key</code> 过期时(生存时间为 <code>0</code> )，它会被自动删除。注意：<ul>
<li>可以对一个已经带有生存时间的 <code>key</code> 执行 <a href="http://doc.redisfans.com/key/expire.html#expire" target="_blank" rel="noopener"><em>EXPIRE</em></a> 命令，新指定的生存时间会取代旧的生存时间。</li>
<li>使用 <a href="http://doc.redisfans.com/key/persist.html" target="_blank" rel="noopener"><em>PERSIST</em></a> 命令可以在不删除 <code>key</code> 的情况下，移除 <code>key</code> 的生存时间，让 <code>key</code> 重新成为一个『持久的』(persistent) <code>key</code> 。</li>
<li>其他的操作不会影响<code>key</code>的生存时间。</li>
<li>在 Redis 2.4 版本中，过期时间的延迟在 1 秒钟之内 —— 也即是，就算 <code>key</code> 已经过期，但它还是可能在过期之后一秒钟之内被访问到，而在新的 Redis 2.6 版本中，延迟被降低到 1 毫秒之内。</li>
</ul>
</li>
<li>EXPIREAT key timestamp <a href="http://doc.redisfans.com/key/expireat.html#expireat" target="_blank" rel="noopener">EXPIREAT</a> 的作用和 <a href="http://doc.redisfans.com/key/expire.html" target="_blank" rel="noopener"><em>EXPIRE</em></a> 类似，都用于为 <code>key</code> 设置生存时间。不同在于 <a href="http://doc.redisfans.com/key/expireat.html#expireat" target="_blank" rel="noopener">EXPIREAT</a> 命令接受的时间参数是 UNIX 时间戳(unix timestamp)。</li>
<li>PEXPIRE key milliseconds 这个命令和 <a href="http://doc.redisfans.com/key/expire.html" target="_blank" rel="noopener"><em>EXPIRE</em></a> 命令的作用类似，但是它以毫秒为单位设置 <code>key</code> 的生存时间，而不像 <a href="http://doc.redisfans.com/key/expire.html" target="_blank" rel="noopener"><em>EXPIRE</em></a> 命令那样，以秒为单位。</li>
<li>PEXPIREAT key milliseconds-timestamp 这个命令和 <a href="http://doc.redisfans.com/key/expireat.html" target="_blank" rel="noopener"><em>EXPIREAT</em></a> 命令类似，但它以毫秒为单位设置 <code>key</code> 的过期 unix 时间戳，而不是像 <a href="http://doc.redisfans.com/key/expireat.html" target="_blank" rel="noopener"><em>EXPIREAT</em></a> 那样，以秒为单位。</li>
<li>TTL key 以秒为单位，返回给定 <code>key</code> 的剩余生存时间(TTL, time to live)。</li>
<li>PTTL key 这个命令类似于 <a href="http://doc.redisfans.com/key/ttl.html#ttl" target="_blank" rel="noopener"><em>TTL</em></a> 命令，但它以毫秒为单位返回 <code>key</code> 的剩余生存时间，而不是像 <a href="http://doc.redisfans.com/key/ttl.html#ttl" target="_blank" rel="noopener"><em>TTL</em></a> 命令那样，以秒为单位。</li>
<li>KEYS pattern 查找所有符合给定模式 <code>pattern</code> 的 <code>key</code> 。</li>
<li>MIGRATE host port key destination-db timeout [COPY] [REPLACE] 将 <code>key</code> 原子性地从当前实例传送到目标实例的指定数据库上，一旦传送成功， <code>key</code> 保证会出现在目标实例上，而当前实例上的 <code>key</code> 会被删除。这个命令是一个原子操作，它在执行的时候会阻塞进行迁移的两个实例，直到以下任意结果发生：迁移成功，迁移失败，等到超时。</li>
<li>MOVE key db 将当前数据库的 <code>key</code> 移动到给定的数据库 <code>db</code> 当中。如果当前数据库(源数据库)和给定数据库(目标数据库)有相同名字的给定 <code>key</code> ，或者 <code>key</code> 不存在于当前数据库，那么 <code>MOVE</code> 没有任何效果。</li>
<li>OBJECT subcommand [arguments [arguments] <a href="http://doc.redisfans.com/key/object.html#object" target="_blank" rel="noopener">OBJECT</a> 命令允许从内部察看给定 <code>key</code> 的 Redis 对象。</li>
<li>PERSIST key 移除给定 <code>key</code> 的生存时间，将这个 <code>key</code> 从『易失的』(带生存时间 <code>key</code> )转换成『持久的』(一个不带生存时间、永不过期的 <code>key</code> )。</li>
<li>RANDOMKEY 从当前数据库中随机返回(不删除)一个 <code>key</code> 。</li>
<li>RENAME key newkey 将 <code>key</code> 改名为 <code>newkey</code> 。当 <code>key</code> 和 <code>newkey</code> 相同，或者 <code>key</code> 不存在时，返回一个错误。当 <code>newkey</code> 已经存在时， <a href="http://doc.redisfans.com/key/rename.html#rename" target="_blank" rel="noopener">RENAME</a> 命令将覆盖旧值。</li>
<li>RENAMENX key newkey 当且仅当 <code>newkey</code> 不存在时，将 <code>key</code> 改名为 <code>newkey</code> 。当 <code>key</code> 不存在时，返回一个错误。</li>
<li>RESTORE key ttl serialized-value 反序列化给定的序列化值，并将它和给定的 <code>key</code> 关联。参数 <code>ttl</code> 以毫秒为单位为 <code>key</code> 设置生存时间；如果 <code>ttl</code> 为 <code>0</code> ，那么不设置生存时间。</li>
<li>SORT key [BY pattern] [LIMIT offset count] [GET pattern [GET pattern …]] [ASC | DESC] [ALPHA] [STORE destination] 返回或保存给定列表、集合、有序集合 <code>key</code> 中经过排序的元素。排序默认以数字作为对象，值被解释为双精度浮点数，然后进行比较。因为 <a href="http://doc.redisfans.com/key/sort.html#sort" target="_blank" rel="noopener">SORT</a> 命令默认排序对象为数字， 当需要对字符串进行排序时， 需要显式地在 <a href="http://doc.redisfans.com/key/sort.html#sort" target="_blank" rel="noopener">SORT</a> 命令之后添加 <code>ALPHA</code> 修饰符。</li>
<li>TYPE key 返回 <code>key</code> 所储存的值的类型。</li>
</ul>
<h3 id="string-字符串"><a href="#string-字符串" class="headerlink" title="string (字符串)"></a>string (字符串)</h3><p>字符串 string 是 Redis 最简单的数据结构。Redis 所有的数据结构都是以唯一的 key 字符串作为名称，然后通过这个唯一 key 值来获取相应的 value 数据。</p>
<p>字符串结构使用非常广泛，一个常见的用途就是缓存用户信息。我们将用户信息结构体 使用 JSON 序列化成字符串，然后将序列化后的字符串塞进 Redis 来缓存。</p>
<p>Redis 的字符串是动态字符串，是可以修改的字符串，内部结构实现上类似于 Java 的 ArrayList，采用预分配冗余空间的方式来减少内存的频繁分配，内部为当前字符串实际分配的空间 capacity 一般要高于实际字符串长度 len。当字符串长度小于 1M 时， 扩容都是加倍现有的空间，如果超过 1M，扩容时一次只会多扩 1M 的空间。需要注意的是，字符串最大长度为 512M。</p>
<p>Redis 中字符串对象的编码可以是 <code>int</code>，<code>raw</code> 或者 <code>embstr</code> 中的某一种，分别如下：</p>
<ul>
<li><strong>int 编码</strong>：保存long 型的64位有符号整数，系统会缓存包含了 1~1000 数字的对象，相同对象会指向同一个地址。</li>
<li><strong>embstr 编码</strong>：保存长度小于44字节的字符串，和字符串对象的其他元信息保存在一段连续的内存地址中。</li>
<li><strong>raw 编码</strong>：保存长度大于44字节的字符串，和字符串对象的其他元信息分开保存。</li>
</ul>
<h3 id="Hash（哈希）"><a href="#Hash（哈希）" class="headerlink" title="Hash（哈希）"></a>Hash（哈希）</h3><p><strong>Hash</strong> 是一个键值(key =&gt; value)对集合。Redis hash 是一个 string 类型的 field 和 value 的映射表，hash 特别适合用于存储对象。 常用命令：hget,hset,hgetall 等。</p>
<p>Hash 的底层数据结构有两种表示：ziplist 和 hashtable。当哈希对象可以同时满足以下两个条件时， 哈希对象使用 ziplist 编码：</p>
<ol>
<li>哈希对象保存的所有键值对的键和值的字符串长度都小于 64 字节；</li>
<li>哈希对象保存的键值对数量小于 512 个；</li>
</ol>
<p>hash 对象使用ziplist 保存时，程序会将保存了键的ziplist节点推入到列表的表尾，然后再将保存了值的ziplist节点推入列表的表尾。使用这种方式保存时，并不需要申请多余的内存空间，而且每个Key都要存储一些关联的系统信息（如过期时间、LRU等），因此和String类型的Key/Value相比，Hash类型极大的减少了Key的数量(大部分的Key都以Hash字段的形式表示并存储了)，从而进一步优化了存储空间的使用效率</p>
<p>hashtable 编码的哈希对象使用字典作为底层实现时， 哈希对象中的每个键值对都使用一个字典键值对来保存：</p>
<ul>
<li>字典的每个键都是一个字符串对象， 对象中保存了键值对的键；</li>
<li>字典的每个值都是一个字符串对象， 对象中保存了键值对的值。</li>
</ul>
<h3 id="List（列表）"><a href="#List（列表）" class="headerlink" title="List（列表）"></a>List（列表）</h3><p>List 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）。</p>
<p>实现方式：Redis中的列表对象在版本3.2之前，列表底层的编码是 ziplist 和 linkedlist 实现的，但是在版本 3.2 之后，重新引入了一个 quicklist 的数据结构，列表的底层都由 quicklist 实现。在早期的设计中， 当列表对象中元素的长度比较小或者数量比较少的时候，采用 ziplist 来存储，当列表对象中元素的长度比较大或者数量比较多的时候，则会转而使用双向列表 linkedlist 来存储。</p>
<h4 id="这两种存储方式的优缺点"><a href="#这两种存储方式的优缺点" class="headerlink" title="这两种存储方式的优缺点"></a>这两种存储方式的优缺点</h4><ul>
<li>双向链表 linkedlist 便于在表的两端进行 push 和 pop 操作，在插入节点上复杂度很低，但是它的内存开销比较大。首先，它在每个节点上除了要保存数据之外，还要额外保存两个指针；其次，双向链表的各个节点是单独的内存块，地址不连续，节点多了容易产生内存碎片。</li>
<li>ziplist 存储在一段连续的内存上，所以存储效率很高。但是，它不利于修改操作，插入和删除操作需要频繁的申请和释放内存。特别是当 ziplist 长度很长的时候，一次 realloc 可能会导致大批量的数据拷贝。</li>
</ul>
<h3 id="Set（集合）"><a href="#Set（集合）" class="headerlink" title="Set（集合）"></a>Set（集合）</h3><p>Redis 的 Set 是 String 类型的无序集合。集合成员是唯一的，这就意味着集合中不能出现重复的数据。</p>
<p>Redis 中集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是 O(1)。</p>
<h3 id="Sorted-Set（有序集合）"><a href="#Sorted-Set（有序集合）" class="headerlink" title="Sorted Set（有序集合）"></a>Sorted Set（有序集合）</h3><p>Redis 有序集合和集合一样也是string类型元素的集合,且不允许重复的成员。不同的是每个元素都会关联一个 double 类型的分数。Redis 正是通过分数来为集合中的成员进行从小到大的排序。有序集合的成员是唯一的,但分数(score)却可以重复。</p>
<p>集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是O(1)。 集合中最大的成员数为 2^32 - 1 (4294967295, 每个集合可存储40多亿个成员)。</p>
<h3 id="Bitmaps（位图）-and-HyperLogLogs（？这个怎么翻译）"><a href="#Bitmaps（位图）-and-HyperLogLogs（？这个怎么翻译）" class="headerlink" title="Bitmaps（位图） and HyperLogLogs（？这个怎么翻译）"></a>Bitmaps（位图） and HyperLogLogs（？这个怎么翻译）</h3><p>Redis还支持位图和 HyperLogLogs，它们实际上是基于String基本类型的数据类型，但是具有自己的语义。 可以参考官网中<a href="https://redis.io/topics/data-types-intro" target="_blank" rel="noopener">introduction to Redis data types</a>以获取有关这些类型的信息。</p>
<h2 id="其他功能"><a href="#其他功能" class="headerlink" title="其他功能"></a>其他功能</h2><h3 id="Transaction（事务）"><a href="#Transaction（事务）" class="headerlink" title="Transaction（事务）"></a>Transaction（事务）</h3><p><a href="http://redisdoc.com/transaction/multi.html#multi" target="_blank" rel="noopener">MULTI</a> 、 <a href="http://redisdoc.com/transaction/exec.html#exec" target="_blank" rel="noopener">EXEC</a> 、 <a href="http://redisdoc.com/transaction/discard.html#discard" target="_blank" rel="noopener">DISCARD</a> 和 <a href="http://redisdoc.com/transaction/watch.html#watch" target="_blank" rel="noopener">WATCH</a> 是 Redis 事务的基础。</p>
<p>事务可以一次执行多个命令， 并且带有以下两个重要的保证：</p>
<ul>
<li><p>事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。</p>
</li>
<li><p>事务是一个原子操作：事务中的命令要么全部被执行，要么全部都不执行。</p>
<p><a href="http://redisdoc.com/transaction/exec.html#exec" target="_blank" rel="noopener">EXEC</a> 命令负责触发并执行事务中的所有命令：</p>
<ul>
<li>如果客户端在使用 <a href="http://redisdoc.com/transaction/multi.html#multi" target="_blank" rel="noopener">MULTI</a> 开启了一个事务之后，却因为断线而没有成功执行 <a href="http://redisdoc.com/transaction/exec.html#exec" target="_blank" rel="noopener">EXEC</a> ，那么事务中的所有命令都不会被执行。</li>
<li>另一方面，如果客户端成功在开启事务之后执行 <a href="http://redisdoc.com/transaction/exec.html#exec" target="_blank" rel="noopener">EXEC</a> ，那么事务中的所有命令都会被执行。</li>
</ul>
<p>当使用 AOF 方式做持久化的时候， Redis 会使用单个 <code>write(2)</code> 命令将事务写入到磁盘中。</p>
<p>然而，如果 Redis 服务器因为某些原因被管理员杀死，或者遇上某种硬件故障，那么可能只有部分事务命令会被成功写入到磁盘中。</p>
<p>如果 Redis 在重新启动时发现 AOF 文件出了这样的问题，那么它会退出，并汇报一个错误。</p>
<p>使用 <code>redis-check-aof</code> 程序可以修复这一问题：它会移除 AOF 文件中不完整事务的信息，确保服务器可以顺利启动。</p>
</li>
</ul>
<p>从 2.2 版本开始，Redis 还可以通过乐观锁（optimistic lock）实现 CAS （check-and-set）操作。</p>
<h3 id="Replication（复制）"><a href="#Replication（复制）" class="headerlink" title="Replication（复制）"></a>Replication（复制）</h3><p>Redis 支持简单且易用的主从复制（master-slave replication）功能， 该功能可以让从服务器(slave server)成为主服务器(master server)的精确复制品。</p>
<p>以下是关于 Redis 复制功能的几个重要方面：</p>
<ul>
<li><p>Redis 使用异步复制。 从 Redis 2.8 开始， 从服务器会以每秒一次的频率向主服务器报告复制流（replication stream）的处理进度。</p>
</li>
<li><p>一个主服务器可以有多个从服务器。</p>
</li>
<li><p>不仅主服务器可以有从服务器， 从服务器也可以有自己的从服务器， 多个从服务器之间可以构成一个图状结构。</p>
</li>
<li><p>复制功能不会阻塞主服务器： 即使有一个或多个从服务器正在进行初次同步， 主服务器也可以继续处理命令请求。</p>
</li>
<li><p>复制功能也不会阻塞从服务器： 只要在 <code>redis.conf</code> 文件中进行了相应的设置， 即使从服务器正在进行初次同步， 服务器也可以使用旧版本的数据集来处理命令查询。</p>
<p>不过， 在从服务器删除旧版本数据集并载入新版本数据集的那段时间内， 连接请求会被阻塞。</p>
<p>你还可以配置从服务器， 让它在与主服务器之间的连接断开时， 向客户端发送一个错误。</p>
</li>
<li><p>复制功能可以单纯地用于数据冗余（data redundancy）， 也可以通过让多个从服务器处理只读命令请求来提升扩展性（scalability）： 比如说， 繁重的 [SORT key [BY pattern] [LIMIT offset count] [GET pattern [GET pattern …]] [ASC | DESC] [ALPHA] [STORE destination]](<a href="http://redisdoc.com/database/sort.html#sort" target="_blank" rel="noopener">http://redisdoc.com/database/sort.html#sort</a>) 命令可以交给附属节点去运行。</p>
</li>
<li><p>可以通过复制功能来让主服务器免于执行持久化操作： 只要关闭主服务器的持久化功能， 然后由从服务器去执行持久化操作即可。</p>
</li>
</ul>
<h3 id="pub-sub（发布与订阅）"><a href="#pub-sub（发布与订阅）" class="headerlink" title="pub/sub（发布与订阅）"></a>pub/sub（发布与订阅）</h3><p><code>SUBSCRIBE</code>、<code>UNSUBSCRIBE</code> 和 <code>PUBLISH</code>三个命令实现了<a href="http://en.wikipedia.org/wiki/Publish/subscribe" target="_blank" rel="noopener">发布与订阅信息泛型</a>（Publish/Subscribe messaging paradigm）， 在这个实现中， 发送者（发送信息的客户端）不是将信息直接发送给特定的接收者（接收信息的客户端）， 而是将信息发送给频道（channel）， 然后由频道将信息转发给所有对这个频道感兴趣的订阅者。</p>
<p>发送者无须知道任何关于订阅者的信息， 而订阅者也无须知道是那个客户端给它发送信息， 它只要关注自己感兴趣的频道即可。</p>
<p>对发布者和订阅者进行解构（decoupling）， 可以极大地提高系统的扩展性（scalability）， 并得到一个更动态的网络拓扑（network topology）。</p>
<p>比如说， 要订阅频道 <code>foo</code> 和 <code>bar</code> ， 客户端可以使用频道名字作为参数来调用 <code>SUBSCRIBE</code>命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">redis&gt; SUBSCRIBE foo bar</span></pre></td></tr></table></figure>

<p>当有客户端发送信息到这些频道时， Redis 会将传入的信息推送到所有订阅这些频道的客户端里面。</p>
<p>正在订阅频道的客户端不应该发送除 <code>SUBSCRIBE</code>、<code>UNSUBSCRIBE</code>之外的其他命令。 其中， <code>SUBSCRIBE</code> 可以用于订阅更多频道， 而 <code>UNSUBSCRIBE</code> 则可以用于退订已订阅的一个或多个频道。</p>
<p><code>SUBSCRIBE</code>的执行结果会以信息的形式返回， 客户端可以通过分析所接收信息的第一个元素， 从而判断所收到的内容是一条真正的信息， 还是 <code>SUBSCRIBE</code>或<code>UNSUBSCRIBE</code> 命令的操作结果。</p>
<p>信息的第一个元素标识了信息的类型：</p>
<ul>
<li><code>subscribe</code> ： 表示当前客户端成功地订阅了信息第二个元素所指示的频道。 而信息的第三个元素则记录了目前客户端已订阅频道的总数。</li>
<li><code>unsubscribe</code> ： 表示当前客户端成功地退订了信息第二个元素所指示的频道。 信息的第三个元素记录了客户端目前仍在订阅的频道数量。 当客户端订阅的频道数量降为 <code>0</code> 时， 客户端不再订阅任何频道， 它可以像往常一样， 执行任何 Redis 命令。</li>
<li><code>message</code> ： 表示这条信息是由某个客户端执行 <a href="http://redisdoc.com/pubsub/publish.html#publish" target="_blank" rel="noopener">PUBLISH channel message</a> 命令所发送的， 真正的信息。 信息的第二个元素是信息来源的频道， 而第三个元素则是信息的内容。</li>
</ul>
<h4 id="编程示例"><a href="#编程示例" class="headerlink" title="编程示例"></a>编程示例</h4><p>Pieter Noordhuis 提供了一个使用 EventMachine 和 Redis 编写的 <a href="https://gist.github.com/348262" target="_blank" rel="noopener">高性能多用户网页聊天软件</a> ， 这个软件很好地展示了发布与订阅功能的用法。</p>
<h3 id="Sentinel（哨兵）"><a href="#Sentinel（哨兵）" class="headerlink" title="Sentinel（哨兵）"></a>Sentinel（哨兵）</h3><p>Redis 的 Sentinel 系统用于管理多个 Redis 服务器（instance）， 该系统执行以下三个任务：</p>
<ul>
<li><strong>监控（Monitoring）</strong>： Sentinel 会不断地检查你的主服务器和从服务器是否运作正常。</li>
<li><strong>提醒（Notification）</strong>： 当被监控的某个 Redis 服务器出现问题时， Sentinel 可以通过 API 向管理员或者其他应用程序发送通知。</li>
<li><strong>自动故障迁移（Automatic failover）</strong>： 当一个主服务器不能正常工作时， Sentinel 会开始一次自动故障迁移操作， 它会将失效主服务器的其中一个从服务器升级为新的主服务器， 并让失效主服务器的其他从服务器改为复制新的主服务器； 当客户端试图连接失效的主服务器时， 集群也会向客户端返回新主服务器的地址， 使得集群可以使用新主服务器代替失效服务器。</li>
</ul>
<p>Redis Sentinel 是一个分布式系统， 你可以在一个架构中运行多个 Sentinel 进程（progress）， 这些进程使用流言协议（gossip protocols)来接收关于主服务器是否下线的信息， 并使用投票协议（agreement protocols）来决定是否执行自动故障迁移， 以及选择哪个从服务器作为新的主服务器。</p>
<p>虽然 Redis Sentinel 释出为一个单独的可执行文件 <code>redis-sentinel</code> ， 但实际上它只是一个运行在特殊模式下的 Redis 服务器， 你可以在启动一个普通 Redis 服务器时通过给定 <code>--sentinel</code> 选项来启动 Redis Sentinel 。</p>
<h2 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h2><p>Redis 提供了多种不同级别的持久化方式：</p>
<ul>
<li>RDB 持久化可以在指定的时间间隔内生成数据集的时间点快照（point-in-time snapshot）。</li>
<li>AOF 持久化记录服务器执行的所有写操作命令，并在服务器启动时，通过重新执行这些命令来还原数据集。 AOF 文件中的命令全部以 Redis 协议的格式来保存，新命令会被追加到文件的末尾。 Redis 还可以在后台对 AOF 文件进行重写（rewrite），使得 AOF 文件的体积不会超出保存数据集状态所需的实际大小。</li>
<li>Redis 还可以同时使用 AOF 持久化和 RDB 持久化。 在这种情况下， 当 Redis 重启时， 它会优先使用 AOF 文件来还原数据集， 因为 AOF 文件保存的数据集通常比 RDB 文件所保存的数据集更完整。</li>
<li>你甚至可以关闭持久化功能，让数据只在服务器运行时存在。</li>
</ul>
<p>了解 RDB 持久化和 AOF 持久化之间的异同是非常重要的， 以下几个小节将详细地介绍这这两种持久化功能， 并对它们的相同和不同之处进行说明。</p>
<h3 id="RDB-的优点"><a href="#RDB-的优点" class="headerlink" title="RDB 的优点"></a>RDB 的优点</h3><ul>
<li>RDB 是一个非常紧凑（compact）的文件，它保存了 Redis 在某个时间点上的数据集。 这种文件非常适合用于进行备份： 比如说，你可以在最近的 24 小时内，每小时备份一次 RDB 文件，并且在每个月的每一天，也备份一个 RDB 文件。 这样的话，即使遇上问题，也可以随时将数据集还原到不同的版本。</li>
<li>RDB 非常适用于灾难恢复（disaster recovery）：它只有一个文件，并且内容都非常紧凑，可以（在加密后）将它传送到别的数据中心，或者亚马逊 S3 中。</li>
<li>RDB 可以最大化 Redis 的性能：父进程在保存 RDB 文件时唯一要做的就是 <code>fork</code> 出一个子进程，然后这个子进程就会处理接下来的所有保存工作，父进程无须执行任何磁盘 I/O 操作。</li>
<li>RDB 在恢复大数据集时的速度比 AOF 的恢复速度要快。</li>
</ul>
<h3 id="RDB-的缺点"><a href="#RDB-的缺点" class="headerlink" title="RDB 的缺点"></a>RDB 的缺点</h3><ul>
<li>如果你需要尽量避免在服务器故障时丢失数据，那么 RDB 不适合你。 虽然 Redis 允许你设置不同的保存点（save point）来控制保存 RDB 文件的频率， 但是， 因为RDB 文件需要保存整个数据集的状态， 所以它并不是一个轻松的操作。 因此你可能会至少 5 分钟才保存一次 RDB 文件。 在这种情况下， 一旦发生故障停机， 你就可能会丢失好几分钟的数据。</li>
<li>每次保存 RDB 的时候，Redis 都要 <code>fork()</code> 出一个子进程，并由子进程来进行实际的持久化工作。 在数据集比较庞大时， <code>fork()</code> 可能会非常耗时，造成服务器在某某毫秒内停止处理客户端； 如果数据集非常巨大，并且 CPU 时间非常紧张的话，那么这种停止时间甚至可能会长达整整一秒。 虽然 AOF 重写也需要进行 <code>fork()</code> ，但无论 AOF 重写的执行间隔有多长，数据的耐久性都不会有任何损失。</li>
</ul>
<h3 id="AOF-的优点"><a href="#AOF-的优点" class="headerlink" title="AOF 的优点"></a>AOF 的优点</h3><ul>
<li>使用 AOF 持久化会让 Redis 变得非常耐久（much more durable）：你可以设置不同的 <code>fsync</code> 策略，比如无 <code>fsync</code> ，每秒钟一次 <code>fsync</code> ，或者每次执行写入命令时 <code>fsync</code> 。 AOF 的默认策略为每秒钟 <code>fsync</code> 一次，在这种配置下，Redis 仍然可以保持良好的性能，并且就算发生故障停机，也最多只会丢失一秒钟的数据（ <code>fsync</code> 会在后台线程执行，所以主线程可以继续努力地处理命令请求）。</li>
<li>AOF 文件是一个只进行追加操作的日志文件（append only log）， 因此对 AOF 文件的写入不需要进行 <code>seek</code> ， 即使日志因为某些原因而包含了未写入完整的命令（比如写入时磁盘已满，写入中途停机，等等）， <code>redis-check-aof</code> 工具也可以轻易地修复这种问题。</li>
<li>Redis 可以在 AOF 文件体积变得过大时，自动地在后台对 AOF 进行重写： 重写后的新 AOF 文件包含了恢复当前数据集所需的最小命令集合。 整个重写操作是绝对安全的，因为 Redis 在创建新 AOF 文件的过程中，会继续将命令追加到现有的 AOF 文件里面，即使重写过程中发生停机，现有的 AOF 文件也不会丢失。 而一旦新 AOF 文件创建完毕，Redis 就会从旧 AOF 文件切换到新 AOF 文件，并开始对新 AOF 文件进行追加操作。</li>
<li>AOF 文件有序地保存了对数据库执行的所有写入操作， 这些写入操作以 Redis 协议的格式保存， 因此 AOF 文件的内容非常容易被人读懂， 对文件进行分析（parse）也很轻松。 导出（export） AOF 文件也非常简单： 举个例子， 如果你不小心执行了 <a href="http://redisdoc.com/database/flushall.html#flushall" target="_blank" rel="noopener">FLUSHALL</a> 命令， 但只要 AOF 文件未被重写， 那么只要停止服务器， 移除 AOF 文件末尾的 <a href="http://redisdoc.com/database/flushall.html#flushall" target="_blank" rel="noopener">FLUSHALL</a> 命令， 并重启 Redis ， 就可以将数据集恢复到 <a href="http://redisdoc.com/database/flushall.html#flushall" target="_blank" rel="noopener">FLUSHALL</a> 执行之前的状态。</li>
</ul>
<h3 id="AOF-的缺点"><a href="#AOF-的缺点" class="headerlink" title="AOF 的缺点"></a>AOF 的缺点</h3><ul>
<li>对于相同的数据集来说，AOF 文件的体积通常要大于 RDB 文件的体积。</li>
<li>根据所使用的 <code>fsync</code> 策略，AOF 的速度可能会慢于 RDB 。 在一般情况下， 每秒 <code>fsync</code> 的性能依然非常高， 而关闭 <code>fsync</code> 可以让 AOF 的速度和 RDB 一样快， 即使在高负荷之下也是如此。 不过在处理巨大的写入载入时，RDB 可以提供更有保证的最大延迟时间（latency）。</li>
<li>AOF 在过去曾经发生过这样的 bug ： 因为个别命令的原因，导致 AOF 文件在重新载入时，无法将数据集恢复成保存时的原样。 （举个例子，阻塞命令 <a href="http://redisdoc.com/list/brpoplpush.html#brpoplpush" target="_blank" rel="noopener">BRPOPLPUSH source destination timeout</a> 就曾经引起过这样的 bug 。） 测试套件里为这种情况添加了测试： 它们会自动生成随机的、复杂的数据集， 并通过重新载入这些数据来确保一切正常。 虽然这种 bug 在 AOF 文件中并不常见， 但是对比来说， RDB 几乎是不可能出现这种 bug 的。</li>
</ul>
<h3 id="RDB-和-AOF-，应该用哪一个？"><a href="#RDB-和-AOF-，应该用哪一个？" class="headerlink" title="RDB 和 AOF ，应该用哪一个？"></a>RDB 和 AOF ，应该用哪一个？</h3><p>一般来说， 如果想达到足以媲美 PostgreSQL 的数据安全性， 你应该同时使用两种持久化功能。</p>
<p>如果你非常关心你的数据， 但仍然可以承受数分钟以内的数据丢失， 那么你可以只使用 RDB 持久化。</p>
<p>有很多用户都只使用 AOF 持久化， 但我们并不推荐这种方式： 因为定时生成 RDB 快照（snapshot）非常便于进行数据库备份， 并且 RDB 恢复数据集的速度也要比 AOF 恢复的速度要快， 除此之外， 使用 RDB 还可以避免之前提到的 AOF 程序的 bug 。</p>
<h2 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h2><p>集群部分的内容官方文档介绍的比较详细了，这里直接大段抄自官方文档的中文翻译，<a href="http://redisdoc.com/topic/cluster-spec.html" target="_blank" rel="noopener">Redis集群规范</a>和<a href="http://redisdoc.com/topic/cluster-tutorial.html" target="_blank" rel="noopener">Redis集群教程</a>章节。</p>
<h3 id="什么是-Redis-集群？"><a href="#什么是-Redis-集群？" class="headerlink" title="什么是 Redis 集群？"></a>什么是 Redis 集群？</h3><p>Redis 集群是一个分布式（distributed）、容错（fault-tolerant）的 Redis 实现， 集群可以使用的功能是普通单机 Redis 所能使用的功能的一个子集（subset）。</p>
<p>Redis 集群中不存在中心（central）节点或者代理（proxy）节点， 集群的其中一个主要设计目标是达到线性可扩展性（linear scalability）。</p>
<p>Redis 集群为了保证一致性（consistency）而牺牲了一部分容错性： 系统会在保证对网络断线（net split）和节点失效（node failure）具有有限（limited）抵抗力的前提下， 尽可能地保持数据的一致性。</p>
<p>Redis 集群是一个可以<strong>在多个 Redis 节点之间进行数据共享</strong>的设施（installation）。</p>
<p>Redis 集群不支持那些需要同时处理多个键的 Redis 命令， 因为执行这些命令需要在多个 Redis 节点之间移动数据， 并且在高负载的情况下， 这些命令将降低 Redis 集群的性能， 并导致不可预测的行为。</p>
<p>Redis 集群<strong>通过分区（partition）来提供一定程度的可用性</strong>（availability）： 即使集群中有一部分节点失效或者无法进行通讯， 集群也可以继续处理命令请求。</p>
<p>Redis 集群提供了以下两个好处：</p>
<ul>
<li>将数据自动切分（split）到多个节点的能力。</li>
<li>当集群中的一部分节点失效或者无法进行通讯时， 仍然可以继续处理命令请求的能力。</li>
</ul>
<h3 id="Redis-集群数据共享"><a href="#Redis-集群数据共享" class="headerlink" title="Redis 集群数据共享"></a>Redis 集群数据共享</h3><p>Redis 集群使用数据分片（sharding）而非一致性哈希（consistency hashing）来实现： 一个 Redis 集群包含 <code>16384</code> 个哈希槽（hash slot）， 数据库中的每个键都属于这 <code>16384</code> 个哈希槽的其中一个， 集群使用公式 <code>CRC16(key) % 16384</code> 来计算键 <code>key</code> 属于哪个槽， 其中 <code>CRC16(key)</code> 语句用于计算键 <code>key</code> 的 <a href="http://zh.wikipedia.org/wiki/循環冗餘校驗" target="_blank" rel="noopener">CRC16 校验和</a> 。</p>
<p>集群中的每个节点负责处理一部分哈希槽。 举个例子， 一个集群可以有三个哈希槽， 其中：</p>
<ul>
<li>节点 A 负责处理 <code>0</code> 号至 <code>5500</code> 号哈希槽。</li>
<li>节点 B 负责处理 <code>5501</code> 号至 <code>11000</code> 号哈希槽。</li>
<li>节点 C 负责处理 <code>11001</code> 号至 <code>16384</code> 号哈希槽。</li>
</ul>
<p>这种将哈希槽分布到不同节点的做法使得用户可以很容易地向集群中添加或者删除节点。 比如说：</p>
<ul>
<li>如果用户将新节点 D 添加到集群中， 那么集群只需要将节点 A 、B 、 C 中的某些槽移动到节点 D 就可以了。</li>
<li>与此类似， 如果用户要从集群中移除节点 A ， 那么集群只需要将节点 A 中的所有哈希槽移动到节点 B 和节点 C ， 然后再移除空白（不包含任何哈希槽）的节点 A 就可以了。</li>
</ul>
<p>因为将一个哈希槽从一个节点移动到另一个节点不会造成节点阻塞， 所以无论是添加新节点还是移除已存在节点， 又或者改变某个节点包含的哈希槽数量， 都不会造成集群下线。</p>
<h3 id="Redis-集群中的主从复制"><a href="#Redis-集群中的主从复制" class="headerlink" title="Redis 集群中的主从复制"></a>Redis 集群中的主从复制</h3><p>为了使得集群在一部分节点下线或者无法与集群的大多数（majority）节点进行通讯的情况下， 仍然可以正常运作， Redis 集群对节点使用了主从复制功能： 集群中的每个节点都有 <code>1</code> 个至 <code>N</code> 个复制品（replica）， 其中一个复制品为主节点（master）， 而其余的 <code>N-1</code> 个复制品为从节点（slave）。</p>
<p>在之前列举的节点 A 、B 、C 的例子中， 如果节点 B 下线了， 那么集群将无法正常运行， 因为集群找不到节点来处理 <code>5501</code> 号至 <code>11000</code> 号的哈希槽。</p>
<p>另一方面， 假如在创建集群的时候（或者至少在节点 B 下线之前）， 我们为主节点 B 添加了从节点 B1 ， 那么当主节点 B 下线的时候， 集群就会将 B1 设置为新的主节点， 并让它代替下线的主节点 B ， 继续处理 <code>5501</code> 号至 <code>11000</code> 号的哈希槽， 这样集群就不会因为主节点 B 的下线而无法正常运作了。</p>
<p>不过如果节点 B 和 B1 都下线的话， Redis 集群还是会停止运作。</p>
<h3 id="Redis-集群的一致性保证（guarantee）"><a href="#Redis-集群的一致性保证（guarantee）" class="headerlink" title="Redis 集群的一致性保证（guarantee）"></a>Redis 集群的一致性保证（guarantee）</h3><p>Redis 集群<strong>不保证数据的强一致性</strong>（strong consistency）： 在特定条件下， Redis 集群可能会丢失已经被执行过的写命令。</p>
<p>使用异步复制（asynchronous replication）是 Redis 集群可能会丢失写命令的其中一个原因。 考虑以下这个写命令的例子：</p>
<ul>
<li>客户端向主节点 B 发送一条写命令。</li>
<li>主节点 B 执行写命令，并向客户端返回命令回复。</li>
<li>主节点 B 将刚刚执行的写命令复制给它的从节点 B1 、 B2 和 B3 。</li>
</ul>
<p>如你所见， 主节点对命令的复制工作发生在返回命令回复之后， 因为如果每次处理命令请求都需要等待复制操作完成的话， 那么主节点处理命令请求的速度将极大地降低 —— 我们必须在性能和一致性之间做出权衡。</p>
<p>Note</p>
<p>如果真的有必要的话， Redis 集群可能会在将来提供同步地（synchronou）执行写命令的方法。</p>
<p>Redis 集群另外一种可能会丢失命令的情况是， 集群出现网络分裂（<a href="http://en.wikipedia.org/wiki/Network_partition" target="_blank" rel="noopener">network partition</a>）， 并且一个客户端与至少包括一个主节点在内的少数（minority）实例被孤立。</p>
<p>举个例子， 假设集群包含 A 、 B 、 C 、 A1 、 B1 、 C1 六个节点， 其中 A 、B 、C 为主节点， 而 A1 、B1 、C1 分别为三个主节点的从节点， 另外还有一个客户端 Z1 。</p>
<p>假设集群中发生网络分裂， 那么集群可能会分裂为两方， 大多数（majority）的一方包含节点 A 、C 、A1 、B1 和 C1 ， 而少数（minority）的一方则包含节点 B 和客户端 Z1 。</p>
<p>在网络分裂期间， 主节点 B 仍然会接受 Z1 发送的写命令：</p>
<ul>
<li>如果网络分裂出现的时间很短， 那么集群会继续正常运行；</li>
<li>但是， 如果网络分裂出现的时间足够长， 使得大多数一方将从节点 B1 设置为新的主节点， 并使用 B1 来代替原来的主节点 B ， 那么 Z1 发送给主节点 B 的写命令将丢失。</li>
</ul>
<p>注意， 在网络分裂出现期间， 客户端 Z1 可以向主节点 B 发送写命令的最大时间是有限制的， 这一时间限制称为<strong>节点超时时间</strong>（node timeout）， 是 Redis 集群的一个重要的配置选项：</p>
<ul>
<li>对于大多数一方来说， 如果一个主节点未能在节点超时时间所设定的时限内重新联系上集群， 那么集群会将这个主节点视为下线， 并使用从节点来代替这个主节点继续工作。</li>
<li>对于少数一方， 如果一个主节点未能在节点超时时间所设定的时限内重新联系上集群， 那么它将停止处理写命令， 并向客户端报告错误。</li>
</ul>
<h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h3 id="1、为什么-Redis-这么快？"><a href="#1、为什么-Redis-这么快？" class="headerlink" title="1、为什么 Redis 这么快？"></a>1、为什么 Redis 这么快？</h3><ul>
<li>数据存于内存</li>
<li>用了多路复用I/O</li>
<li>单线程</li>
</ul>
<h3 id="2、key-过期清除（超时剔除）策略"><a href="#2、key-过期清除（超时剔除）策略" class="headerlink" title="2、key 过期清除（超时剔除）策略"></a>2、key 过期清除（超时剔除）策略</h3><ol>
<li>惰性过期（类比懒加载，这是懒过期）：只有当访问一个key时，才会判断该key是否已过期，过期则清除。该策略可以最大化地节省CPU资源，却对内存非常不友好。极端情况可能出现大量的过期key没有再次被访问，从而不会被清除，占用大量内存。</li>
<li>定期过期：每隔一定的时间，会扫描一定数量的数据库的expires字典中一定数量的key，并清除其中已过期的key。该策略是前两者的一个折中方案。通过调整定时扫描的时间间隔和每次扫描的限定耗时，可以在不同情况下使得CPU和内存资源达到最优的平衡效果</li>
</ol>
<h3 id="3、-Redis的内存淘汰策略"><a href="#3、-Redis的内存淘汰策略" class="headerlink" title="3、 Redis的内存淘汰策略"></a>3、 Redis的内存淘汰策略</h3><p>Redis的内存淘汰策略是指在Redis的用于缓存的内存不足时，怎么处理需要新写入且需要申请额外空间的数据。</p>
<ul>
<li>noeviction：当内存不足以容纳新写入数据时，新写入操作会报错。</li>
<li>allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key。</li>
<li>allkeys-random：当内存不足以容纳新写入数据时，在键空间中，随机移除某个key。</li>
<li>volatile-lru：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的key。</li>
<li>volatile-random：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个key。</li>
<li>volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的key优先移除。</li>
</ul>
<h3 id="4、如何防止缓存穿透？"><a href="#4、如何防止缓存穿透？" class="headerlink" title="4、如何防止缓存穿透？"></a>4、如何防止缓存穿透？</h3><ol>
<li>数据命中不高，变化实时性比较高的情况下，可以缓存空对象。</li>
<li>数据命中不高，相对固定实时性低的时候，用 BloomFilter 布隆过滤器。</li>
</ol>
<h3 id="5、为什么-Redis-不支持回滚（roll-back）"><a href="#5、为什么-Redis-不支持回滚（roll-back）" class="headerlink" title="5、为什么 Redis 不支持回滚（roll back）"></a>5、为什么 Redis 不支持回滚（roll back）</h3><p>如果你有使用关系式数据库的经验， 那么 “Redis 在事务失败时不进行回滚，而是继续执行余下的命令”这种做法可能会让你觉得有点奇怪。</p>
<p>以下是这种做法的优点：</p>
<ul>
<li>Redis 命令只会因为错误的语法而失败（并且这些问题不能在入队时发现），或是命令用在了错误类型的键上面：这也就是说，从实用性的角度来说，失败的命令是由编程错误造成的，而这些错误应该在开发的过程中被发现，而不应该出现在生产环境中。</li>
<li>因为不需要对回滚进行支持，所以 Redis 的内部可以保持简单且快速。</li>
</ul>
<p>有种观点认为 Redis 处理事务的做法会产生 bug ， 然而需要注意的是， 在通常情况下， 回滚并不能解决编程错误带来的问题。 举个例子， 如果你本来想通过 <a href="http://redisdoc.com/string/incr.html#incr" target="_blank" rel="noopener">INCR key</a> 命令将键的值加上 <code>1</code> ， 却不小心加上了 <code>2</code> ， 又或者对错误类型的键执行了 <a href="http://redisdoc.com/string/incr.html#incr" target="_blank" rel="noopener">INCR key</a> ， 回滚是没有办法处理这些情况的。</p>
<p>鉴于没有任何机制能避免程序员自己造成的错误， 并且这类错误通常不会在生产环境中出现， 所以 Redis 选择了更简单、更快速的无回滚方式来处理事务。</p>
<h2 id="结合Java"><a href="#结合Java" class="headerlink" title="结合Java"></a>结合Java</h2><p>参考文章</p>
<p><a href="https://youyou-tech.com/2019/11/05/redis相关原理及面试官由浅到深必问的/" target="_blank" rel="noopener">redis相关原理及面试官由浅到深必问的</a></p>
<p><a href="https://juejin.im/post/5d0da0ef6fb9a07ebd48dee0" target="_blank" rel="noopener">Redis 选择hash还是string 存储数据？</a></p>
<p><a href="https://segmentfault.com/a/1190000002906345" target="_blank" rel="noopener">Redis 持久化</a></p>
<p><a href="http://redisdoc.com/topic/persistence.html" target="_blank" rel="noopener">持久化（persistence）</a></p>
<p><a href="https://www.cnblogs.com/rjzheng/p/10360619.html" target="_blank" rel="noopener">【原创】那些年用过的Redis集群架构（含面试解析）</a></p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="tag"># 数据库</a>
              <a href="/tags/redis/" rel="tag"># redis</a>
              <a href="/tags/NoSQL/" rel="tag"># NoSQL</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/02/01/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/" rel="prev" title="Java多线程">
      <i class="fa fa-chevron-left"></i> Java多线程
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/03/01/HTTPS%E4%B8%BA%E4%BB%80%E4%B9%88%E5%AE%89%E5%85%A8%EF%BC%9F/" rel="next" title="HTTPS为什么安全？">
      HTTPS为什么安全？ <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#简述"><span class="nav-number">1.</span> <span class="nav-text">简述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#应用"><span class="nav-number">2.</span> <span class="nav-text">应用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数据结构"><span class="nav-number">3.</span> <span class="nav-text">数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#key"><span class="nav-number">3.1.</span> <span class="nav-text">key</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#string-字符串"><span class="nav-number">3.2.</span> <span class="nav-text">string (字符串)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Hash（哈希）"><span class="nav-number">3.3.</span> <span class="nav-text">Hash（哈希）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#List（列表）"><span class="nav-number">3.4.</span> <span class="nav-text">List（列表）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#这两种存储方式的优缺点"><span class="nav-number">3.4.1.</span> <span class="nav-text">这两种存储方式的优缺点</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Set（集合）"><span class="nav-number">3.5.</span> <span class="nav-text">Set（集合）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Sorted-Set（有序集合）"><span class="nav-number">3.6.</span> <span class="nav-text">Sorted Set（有序集合）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Bitmaps（位图）-and-HyperLogLogs（？这个怎么翻译）"><span class="nav-number">3.7.</span> <span class="nav-text">Bitmaps（位图） and HyperLogLogs（？这个怎么翻译）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#其他功能"><span class="nav-number">4.</span> <span class="nav-text">其他功能</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Transaction（事务）"><span class="nav-number">4.1.</span> <span class="nav-text">Transaction（事务）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Replication（复制）"><span class="nav-number">4.2.</span> <span class="nav-text">Replication（复制）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#pub-sub（发布与订阅）"><span class="nav-number">4.3.</span> <span class="nav-text">pub&#x2F;sub（发布与订阅）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#编程示例"><span class="nav-number">4.3.1.</span> <span class="nav-text">编程示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Sentinel（哨兵）"><span class="nav-number">4.4.</span> <span class="nav-text">Sentinel（哨兵）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#持久化"><span class="nav-number">5.</span> <span class="nav-text">持久化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#RDB-的优点"><span class="nav-number">5.1.</span> <span class="nav-text">RDB 的优点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RDB-的缺点"><span class="nav-number">5.2.</span> <span class="nav-text">RDB 的缺点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AOF-的优点"><span class="nav-number">5.3.</span> <span class="nav-text">AOF 的优点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AOF-的缺点"><span class="nav-number">5.4.</span> <span class="nav-text">AOF 的缺点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RDB-和-AOF-，应该用哪一个？"><span class="nav-number">5.5.</span> <span class="nav-text">RDB 和 AOF ，应该用哪一个？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#集群"><span class="nav-number">6.</span> <span class="nav-text">集群</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#什么是-Redis-集群？"><span class="nav-number">6.1.</span> <span class="nav-text">什么是 Redis 集群？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis-集群数据共享"><span class="nav-number">6.2.</span> <span class="nav-text">Redis 集群数据共享</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis-集群中的主从复制"><span class="nav-number">6.3.</span> <span class="nav-text">Redis 集群中的主从复制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis-集群的一致性保证（guarantee）"><span class="nav-number">6.4.</span> <span class="nav-text">Redis 集群的一致性保证（guarantee）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#常见问题"><span class="nav-number">7.</span> <span class="nav-text">常见问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1、为什么-Redis-这么快？"><span class="nav-number">7.1.</span> <span class="nav-text">1、为什么 Redis 这么快？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2、key-过期清除（超时剔除）策略"><span class="nav-number">7.2.</span> <span class="nav-text">2、key 过期清除（超时剔除）策略</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3、-Redis的内存淘汰策略"><span class="nav-number">7.3.</span> <span class="nav-text">3、 Redis的内存淘汰策略</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4、如何防止缓存穿透？"><span class="nav-number">7.4.</span> <span class="nav-text">4、如何防止缓存穿透？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5、为什么-Redis-不支持回滚（roll-back）"><span class="nav-number">7.5.</span> <span class="nav-text">5、为什么 Redis 不支持回滚（roll back）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#结合Java"><span class="nav-number">8.</span> <span class="nav-text">结合Java</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Beritra"
      src="/images/avator.jpg">
  <p class="site-author-name" itemprop="name">Beritra</p>
  <div class="site-description" itemprop="description">Beritra's Blogs</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">34</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">21</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">45</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/beritra" title="Github → https:&#x2F;&#x2F;github.com&#x2F;beritra" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>Github</a>
      </span>
      <span class="links-of-author-item">
        <a href="http://weibo.com/u/3315421093" title="Weibo → http:&#x2F;&#x2F;weibo.com&#x2F;u&#x2F;3315421093" rel="noopener" target="_blank"><i class="fa fa-fw fa-weibo"></i>Weibo</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        
  <div class="beian"><a href="http://www.beian.miit.gov.cn/" rel="noopener" target="_blank">京ICP备16042931号-3 </a>
  </div>

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Beritra</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    <span title="站点总字数">316k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">8:47</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
