<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.1.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/icon.jpg">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/icon.jpg">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/icon.jpg">
  <link rel="mask-icon" href="/images/icon.jpg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://Beritra.github.com').hostname,
    root: '/',
    scheme: 'Mist',
    version: '7.6.0',
    exturl: false,
    sidebar: {"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta name="description" content="记录 Java 中的各种集合类和底层原理。">
<meta property="og:type" content="article">
<meta property="og:title" content="Java中的各种集合类">
<meta property="og:url" content="http:&#x2F;&#x2F;beritra.github.com&#x2F;2019&#x2F;12&#x2F;01&#x2F;Java%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E9%9B%86%E5%90%88%E7%B1%BB&#x2F;index.html">
<meta property="og:site_name" content="Beritra">
<meta property="og:description" content="记录 Java 中的各种集合类和底层原理。">
<meta property="og:image" content="http:&#x2F;&#x2F;nas.beritra.com:18081&#x2F;uploads&#x2F;big&#x2F;745d97b3e18d919ffbb9ad3a7f61c61b.png">
<meta property="og:image" content="http:&#x2F;&#x2F;nas.beritra.com:18081&#x2F;uploads&#x2F;big&#x2F;e2865f788f40d13b29e204649820a9bf.jpg">
<meta property="og:image" content="http:&#x2F;&#x2F;nas.beritra.com:18081&#x2F;uploads&#x2F;big&#x2F;61bd32fe80e6c936034c93389cc99c0a.jpg">
<meta property="og:image" content="http:&#x2F;&#x2F;nas.beritra.com:18081&#x2F;uploads&#x2F;big&#x2F;f7855185a5577918835416203aa831ae.jpg">
<meta property="og:image" content="http:&#x2F;&#x2F;nas.beritra.com:18081&#x2F;uploads&#x2F;big&#x2F;11d786f3c58fa393e519eca19c63fa67.png">
<meta property="og:image" content="http:&#x2F;&#x2F;nas.beritra.com:18081&#x2F;uploads&#x2F;big&#x2F;06530f14f76b79769887d3f1e8eebc27.png">
<meta property="og:image" content="http:&#x2F;&#x2F;nas.beritra.com:18081&#x2F;uploads&#x2F;big&#x2F;8fd5bf86f968ababd2e78669517c5c08.png">
<meta property="og:image" content="http:&#x2F;&#x2F;nas.beritra.com:18081&#x2F;uploads&#x2F;big&#x2F;9151c7a0b015e54bdc06bebfaec18be7.jpg">
<meta property="article:published_time" content="2019-12-01T04:12:12.000Z">
<meta property="article:modified_time" content="2019-12-15T14:27:27.944Z">
<meta property="article:author" content="Beritra">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="集合">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http:&#x2F;&#x2F;nas.beritra.com:18081&#x2F;uploads&#x2F;big&#x2F;745d97b3e18d919ffbb9ad3a7f61c61b.png">

<link rel="canonical" href="http://beritra.github.com/2019/12/01/Java%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E9%9B%86%E5%90%88%E7%B1%BB/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true
  };
</script>

  <title>Java中的各种集合类 | Beritra</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Beritra</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">Blogs</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="搜索..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://beritra.github.com/2019/12/01/Java%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E9%9B%86%E5%90%88%E7%B1%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avator.jpg">
      <meta itemprop="name" content="Beritra">
      <meta itemprop="description" content="Beritra's Blogs">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Beritra">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Java中的各种集合类
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-12-01 12:12:12" itemprop="dateCreated datePublished" datetime="2019-12-01T12:12:12+08:00">2019-12-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-12-15 22:27:27" itemprop="dateModified" datetime="2019-12-15T22:27:27+08:00">2019-12-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>记录 Java 中的各种集合类和底层原理。</p>
<a id="more"></a>

<p>Java中的集合主要分为以下集合类：<code>Map</code>、<code>List</code>、<code>Set</code>、<code>Queue</code>和<code>concurrent</code>包里面供多线程环境下使用的以上几种集合类。</p>
<h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p><code>java.util</code>包中提供的常见Map类包括以下几种。这里乱入了个<code>ConcurrentHashMap</code>，放到下面和其他<code>concurrent</code>包的集合一起讲。</p>
<p><img src="http://nas.beritra.com:18081/uploads/big/745d97b3e18d919ffbb9ad3a7f61c61b.png" alt=""></p>
<h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><p> HashMap是老生常谈的集合了，学习HashMap主要关注点是哈希算法、rehash、数据存储、扩容方式、性能区别和结合ConcurrentHashMap了解为什么线程不安全，后者怎么解决线程安全问题。</p>
<h4 id="哈希算法"><a href="#哈希算法" class="headerlink" title="哈希算法"></a>哈希算法</h4><p>先看一下JDK中hashCode的生成方式，JDK8以后都是如下方式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">int</span> h;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>这里可以看到，key不是null的情况下，都是取<code>key.hashCode()</code>之后无符号右移16位，然后取异或。这里的<code>key.hashCode()</code>是native方法，直接在JVM中返回int型散列值。</p>
<blockquote>
<p>无符号右移&gt;&gt;&gt; ：不管正负标志位为0还是1，将该数的二进制码整体右移，左边部分总是以0填充，右边部分舍弃。</p>
<p>位与：第一个操作数的的第n位于第二个操作数的第n位如果都是1，那么结果的第n为也为1，否则为0</p>
</blockquote>
<p>为什么要这么做？</p>
<p>理论上散列值是一个int型，如果直接拿散列值作为下标访问HashMap主数组的话，考虑到2进制32位带符号的int表值范围从-2147483648到2147483648。前后加起来大概40亿的映射空间。只要哈希函数映射得比较均匀松散，一般应用是很难出现碰撞的。</p>
<p>但问题是一个40亿长度的数组，内存是放不下的。你想，HashMap扩容之前的数组初始大小才16。所以这个散列值是不能直接拿来用的。用之前还要先做对数组的长度取模运算，得到的余数才能用来访问数组下标。</p>
<p>顺便说一下，这也正好解释了为什么HashMap的数组长度要取2的整次幂。因为这样（数组长度-1）正好相当于一个“低位掩码”。“与”操作的结果就是散列值的高位全部归零，只保留低位值，用来做数组下标访问。以初始长度16为例，16-1=15。2进制表示是00000000 00000000 00001111。和某散列值做“与”操作如下，结果就是截取了最低的四位值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">      10100101 11000100 00100101</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">&amp;	00000000 00000000 00001111</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">----------------------------------</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">	00000000 00000000 00000101    &#x2F;&#x2F;高位全部归零，只保留末四位</span></pre></td></tr></table></figure>

<p>但这时候问题就来了，这样就算我的散列值分布再松散，要是只取最后几位的话，碰撞也会很严重。更要命的是如果散列本身做得不好，分布上成等差数列的漏洞，恰好使最后几个低位呈现规律性重复，就无比蛋疼。</p>
<p>这时候“扰动函数”的价值就体现出来了，说到这里大家应该猜出来了。看下面这个图:</p>
<p><img src="http://nas.beritra.com:18081/uploads/big/e2865f788f40d13b29e204649820a9bf.jpg" alt=""></p>
<p>右位移16位，正好是32bit的一半，自己的高半区和低半区做异或，就是为了混合原始哈希码的高位和低位，以此来加大低位的随机性。而且混合后的低位掺杂了高位的部分特征，这样高位的信息也被变相保留下来。</p>
<h4 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h4><p>HashMap两个关键的初始化参数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span></pre></td></tr></table></figure>

<p>前者是初始化容量16，即新建一个HashMap的时候，如果不指定长度，则容量为16。</p>
<p>后者是加载因子，即当实际长度除以容量高于该因子的时候，进行扩容操作。默认为0.75，所以HashMap空间占用大于3/4的时候就开始扩容了。扩容后的容量是原来的两倍。</p>
<p>HashMap的resize不是简单的把长度扩大，而是有下面两个步骤：</p>
<ol>
<li>扩容：创建一个新的Entry空数组，长度是原数组的2倍。</li>
<li>reHash:遍历原Entry数组，把所有的Entry重新hash到新数组。为什么要重新hash呢？因为长度扩大以后，hash的规则也随之改变。</li>
</ol>
<p>让我们回顾一下hash公式：</p>
<p><code>index = hashCode(key) &amp; (length - 1)</code></p>
<p>当原数组长度为8时，hash运算是和111B做与运算；新数组长度为16，hash运算是和1111B做与运算。Hash结果显然不同。</p>
<p>那么这里为什么要用map容量减去1这个数字哪？好处有两个：</p>
<ol>
<li>分布均匀</li>
<li>速度更快</li>
</ol>
<p>在HashMap的源码中。get和put方法会根据key的hash值找到这个entry在hash表数组中的位置，源码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">if ((p &#x3D; tab[i &#x3D; (n - 1) &amp; hash]) &#x3D;&#x3D; null)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    tab[i] &#x3D; newNode(hash, key, value, null);</span></pre></td></tr></table></figure>

<p>按照我们理想的状况，hashMap的存取就是O(1)，也就是直接根据hashcode就可以找到它，每个bucket只存储一个节点，链表指向都是null,这样就比较开心了，不要出现一个链表很长的情况。</p>
<p>所以我们希望它能分布的均匀一点，如果让我们设计的话，我们肯定是直接对长度取模：hashcode % length,但HashMap的设计者却不是这样写的，它写成了2进制运算，因为当容量一定是2^n时，<code>h &amp; (length - 1) == h % length</code>，并且位运算的速度要高于取模。</p>
<p>另外，元素在重新计算hash之后，因为n变为2倍，新的index的二进制就是在前面多了一位，比如原来的容量为8的时候，元素下标为5，扩容到16之后，根据多的那一位是0还是1，元素下标只需要+8或者在原位置就可以了，也就是说resize操作也会更快。</p>
<h4 id="存储方式"><a href="#存储方式" class="headerlink" title="存储方式"></a>存储方式</h4><p>HashMap实际是一种“数组+链表”数据结构。在put操作中，通过内部定义算法寻止找到数组下标，将数据直接放入此数组元素中，若通过算法得到的该数组元素已经有了元素（俗称hash冲突，链表结构出现的实际意义也就是为了解决hash冲突的问题）。将会把这个数组元素上的链表进行遍历，将新的数据放到链表末尾。</p>
<p>通过哈希算法从寻止上能够高效的找到对应的下标，但是随着数据的增长，哈希冲突碰撞过多。在寻找数据上，找到该来链表，会通过遍历在寻找对应数据，如此将会使得get数据效率越来越低。在jdk1.8中，链表元素数量大于等于8将会重组该链表结构形成为“红黑树结构”，这种结构使得在hash冲突碰撞过多情况下，get效率比链表的效率高很多。</p>
<h4 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h4><p>在没有哈希冲突的情况下，HashMap存取元素的时间复杂度是O(1)，但是这只是理想情况。当冲突不多的时候，重复元素以链表形式存储，时间复杂度是O(N)，当数据量大的时候，链表转换为红黑树，时间复杂度变成O(LogN)</p>
<h4 id="线程安全和其他局限"><a href="#线程安全和其他局限" class="headerlink" title="线程安全和其他局限"></a>线程安全和其他局限</h4><p>HashMap不是线程安全的，另外如果HashMap的key是自定义类，需要重写<code>hashCode()</code>方法，并且由于HashMap的效率高度依赖<code>hashCode()</code>，需要保证散列分布尽量均匀。</p>
<p>都知道HashMap不是线程安全的，那么在哪些环节导致了他线程不安全？</p>
<ol>
<li><p>插入数据的时候</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span></pre></td></tr></table></figure>

<p>假如A线程和B线程同时添加元素，然后计算出了相同的哈希值对应了相同的数组位置，因为此时该位置还没数据，然后对同一个数组位置添加，B的写入操作就会覆盖A的写入操作造成A的写入操作丢失。</p>
</li>
<li><p>删除数据的时候</p>
<p>跟上面同样，多个线程同时删除数据，可能产生错误。</p>
</li>
<li><p>扩容的时候</p>
<p>线程1执行put时，因为元素个数超出threshold而导致rehash，线程2此时执行get，有可能导致这个问题。</p>
<p>因为在resize的时候，是计算新的容量和threshold，在创建一个新hash表，最后将旧hash表中元素rehash到新的hash表中。如果在这个期间，另一个线程执行读取操作，有可能get到null。</p>
</li>
</ol>
<p>那么ConcurrentHashMap如何保证线程安全？下面解析ConcurrentHashMap的时候一起说。</p>
<h3 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h3><p>LinkedHashMap是继承自HashMap的，跟HashMap最大的区别是，他是基于Hash表和链表的实现，并且依靠着双向链表保证了迭代顺序是插入的顺序。</p>
<p>来看看HashMap和LinkedHashMap的结构图，是不是秒懂了。LinkedHashMap其实就是可以看成HashMap的基础上，多了一个双向链表来维持顺序。</p>
<p><img src="http://nas.beritra.com:18081/uploads/big/61bd32fe80e6c936034c93389cc99c0a.jpg" alt=""></p>
<p><img src="http://nas.beritra.com:18081/uploads/big/f7855185a5577918835416203aa831ae.jpg" alt=""></p>
<p>可以用LinkedHashMap实现最近访问算法，即最近访问过的元素在最前面，LinkedHashMap有这么一个构造方法。</p>
<p><code>public LinkedHashMap(int initialCapacity, float loadFactor,boolean accessOrder)</code></p>
<p> accessOrder为true的时候按照元素最后访问时间排序（LRU算法：最近最久使用），为false则是按照插入顺序排序，默认为false.</p>
<h3 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h3><p>TreeMap是基于红黑树的实现，具有如下特点：</p>
<ul>
<li>不允许出现重复的key；</li>
<li>可以插入null键，null值；</li>
<li>可以对元素进行排序；</li>
<li>无序集合（插入和遍历顺序不一致）；</li>
</ul>
<p>由于是基于红黑树，TreeMap在插入、删除、搜索的时候，时间复杂度都是O（LogN）</p>
<h3 id="EnumMap"><a href="#EnumMap" class="headerlink" title="EnumMap"></a>EnumMap</h3><p>EnumMap是专门为枚举类型量身定做的Map实现。虽然使用其它的Map实现（如HashMap）也能完成枚举类型实例到值得映射，但是使用EnumMap会更加高效：它只能接收同一枚举类型的实例作为键值，并且由于枚举类型实例的数量相对固定并且有限，所以EnumMap使用数组来存放与枚举类型对应的值。这使得EnumMap的效率非常高。EnumMap在内部使用枚举类型的ordinal()得到当前实例的声明次序，并使用这个次序维护枚举类型实例对应值在数组的位置。</p>
<p>在key是枚举类的时候，EnumMap可以用来代替HashMap，并且由于是数组实现，性能更好。</p>
<h3 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a>HashTable</h3><h4 id="Hashtable-与-HashMap-的简单比较"><a href="#Hashtable-与-HashMap-的简单比较" class="headerlink" title="Hashtable 与 HashMap 的简单比较"></a>Hashtable 与 HashMap 的简单比较</h4><ol>
<li><p>HashTable 基于 Dictionary 类，而 HashMap 是基于 AbstractMap。Dictionary 是任何可将键映射到相应值的类的抽象父类，而 AbstractMap 是基于 Map 接口的实现，它以最大限度地减少实现此接口所需的工作。</p>
</li>
<li><p>HashMap 的 key 和 value 都允许为 null，而 Hashtable 的 key 和 value 都不允许为 null。HashMap 遇到 key 为 null 的时候，调用 putForNullKey 方法进行处理，而对 value 没有处理；Hashtable遇到 null，直接返回 NullPointerException。</p>
</li>
<li><p>Hashtable 方法是同步，而HashMap则不是。我们可以看一下源码，Hashtable 中的几乎所有的 public 的方法都是 synchronized 的，而有些方法也是在内部通过 synchronized 代码块来实现。所以有人一般都建议如果是涉及到多线程同步时采用 HashTable，没有涉及就采用 HashMap，但是在Collections 类中存在一个静态方法：synchronizedMap()，该方法创建了一个线程安全的 Map 对象，并把它作为一个封装的对象来返回。</p>
</li>
<li><p>HashMap的初始容量为16，Hashtable初始容量为11，两者的填充因子默认都是0.75。</p>
</li>
<li><p>两者计算hash的方法不同</p>
<p>Hashtable计算hash是直接使用key的hashcode对table数组的长度直接进行取模</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">int hash &#x3D; key.hashCode();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">int index &#x3D; (hash &amp; 0x7FFFFFFF) % tab.length;</span></pre></td></tr></table></figure>

<p>HashMap计算hash对key的hashcode的前后16为进行了异或操作，以获得更好的散列值，然后对table数组长度取模(实际上是位操作，增加效率)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">   static final int hash(Object key) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">       int h;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">       return (key &#x3D;&#x3D; null) ? 0 : (h &#x3D; key.hashCode()) ^ (h &gt;&gt;&gt; 16);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">   &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">   </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">static int indexFor(int h, int length) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">       return h &amp; (length-1);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">   &#125;</span></pre></td></tr></table></figure>



</li>
</ol>
<h3 id="IdentityHashMap"><a href="#IdentityHashMap" class="headerlink" title="IdentityHashMap"></a>IdentityHashMap</h3><p>IdentityHashMap是一致性哈希表，使用引用相等，而不是equals方法来比较两个对象的相等性。因此，IdentityHashMap中，如果存在两个键key1和key2，当且仅当key1==key2时，两个键相等，而其他大部分的哈希表，当且仅当k1 == null ? k2 == null : k1.equals(k2)时，两个键才认为是相等的。</p>
<p>IdentityHashMap使用System.identityHashCode来确定对象的哈希码，该方法返回对象的地址。</p>
<p>看下IdentityHashMap的存储原理图，和HashMap不同，HashMap是通过数组+拉链法存储元素并解决哈希冲突的。IdentityHashMap将所有的key和value都存储到Object[]数组table中，并且key和value相邻存储，当出现哈希冲突时，会往下遍历数组，直到找到一个空闲的位置。注意，数组第一个位置存储的是key，第二个位置存储的是value。因此奇数位置处存储的是key，偶数位置处存储的是value。</p>
<p>IdentityHashMap同样允许空的键和值，但是不保证map中的顺序，尤其是不保证顺序会恒定不变。</p>
<h3 id="WeakHashMap"><a href="#WeakHashMap" class="headerlink" title="WeakHashMap"></a>WeakHashMap</h3><p>和HashMap一样，WeakHashMap 也是一个散列表，它存储的内容也是键值对(key-value)映射，而且键和值都可以是null。不过WeakHashMap的键是“弱键”。</p>
<p>当弱引用指向的对象只能通过弱引用（没有强引用或弱引用）访问时，GC会清理掉该对象，之后，引用对象会被放到ReferenceQueue中。在Entry的构造函数中可以得知，通过super(key, queue)将key保存为弱引用，通过this.value = value将value保存为强引用。当key中的引用被gc掉之后，在下次访问WeakHashMap（调用expungeStaleEntries函数）时相应的entry也会自动被移除。</p>
<p>WeakHashMap 并不是你什么也不干它就能自动释放内部不用的对象的，而是在你访问它的内容的时候释放内部不用的对象。</p>
<h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><p><code>java.util</code>包中提供的常见List类包括以下几种。</p>
<p><img src="http://nas.beritra.com:18081/uploads/big/11d786f3c58fa393e519eca19c63fa67.png" alt=""></p>
<p>从刚学Java的前几天起，大概就会见到这个问题：LinkedList和ArrayList有什么共同点和区别？</p>
<p>共同点：</p>
<ol>
<li>二者都是继承自AbstractList抽象类，AbstractList实现了List接口中除了size()、get(int location)之外的方法。</li>
<li>二者都是线程不安全的。</li>
</ol>
<p>区别：</p>
<ol>
<li>ArrayList是实现了<strong>基于动态数组</strong>的数据结构，而LinkedList是<strong>基于链表</strong>的数据结构；</li>
<li>数据更新和查找时，ArrayList可以直接通过数组下标访问，所以效率更高。</li>
<li>数据增加和删除的时候，ArrayList需要移动其他元素的位置，而LinkedList只需要修改一个指针，所以后者效率更高。</li>
</ol>
<h4 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h4><p>Vector是同样继承于AbstractList的一个列表，而它是线程安全的，实现方式是对所有数据操作的方法添加了synchronized关键字。</p>
<h4 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h4><p>Stack栈是Vector的一个子类，它实现了一个标准的后进先出的栈。</p>
<p>他的方法很简单，只有<code>empty()</code>、<code>peek()</code>、<code>pop()</code>、<code>push(Object element)</code>、<code>search(object element)</code>这几个。其中peek和pop的返回值都是堆栈顶部的对象，但是前者只是查看，后者是移除。</p>
<h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><p><code>java.util</code>包中提供的常见Set类包括以下几种。</p>
<p><img src="http://nas.beritra.com:18081/uploads/big/06530f14f76b79769887d3f1e8eebc27.png" alt=""></p>
<p>HashSet没什么好说的，其实就是把HashMap封装了一层，从HashSet的构造方法可以看出，就是维护了一个HashMap，数据的增伤改查也是调用的HashMap的方法。</p>
<p>TreeSet也是一样，其实就是TreeMap套了个皮。</p>
<p>EnumSet就不一样了，跟EnumMap其实没有什么关系。EnumSet 是一个 Set 集合的抽象类，其有两个实现类 JumboEnumSet 和 RegularEnumSet，在使用的时候放入的必须是枚举类型，<strong>其特点是速度非常快。</strong></p>
<p>EnumSet 的默认子类 RegularEnumSet 和 JumboEnumSet 实现原理都是基于位运算向量，位运算向量的原理就是用一个位表示一个元素的状态（元素的状态只有两种），用一组位表示一个集合的状态，每个位对应一个元素，譬如一个枚举类 DemoEnum 有6个枚举值，则 EnumSet<DemoEnum> 集合就可以通过一个 byte 字节从右到左（二进制低到高位）来表示，不用的位上用 0 填充，用的位上每个 bit 位代表一个枚举值，1 表示包含该枚举值，0 表示不含该枚举值。因此位向量能表示的枚举值个数与向量长度有关，上面例子中一个 byte 类型最多能表示 8 个枚举值，所以 EnumSet 抽象类的两个实现类 RegularEnumSet 和 JumboEnumSet 分别定义了不同的向量长度。<strong>RegularEnumSet 使用 64 位的 long 类型变量作为位向量，而 JumboEnumSet 使用一个 long 类型数组作为向量（数组内存连续），</strong>故当我们通过 EnumSet 的工厂方法创建 EnumSet 集合时 EnumSet 会通过判断枚举类的枚举值数量决定使用两个子类的哪一个，<strong>如果枚举值个数小于等于 64 就用 RegularEnumSet，大于 64 就用 JumboEnumSet。</strong></p>
<p>简单来说EnumSet就是一个高效的枚举类集合。</p>
<h2 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h2><p><img src="http://nas.beritra.com:18081/uploads/big/8fd5bf86f968ababd2e78669517c5c08.png" alt=""></p>
<p>队列(Queue)可以当做一种特殊的线性表，遵循先进先出原则。而双向队列(Deque),是Queue的一个子接口，双向队列是指该队列两端的元素既能入队(offer)也能出队(poll),如果将Deque限制为只能从一端入队和出队，则可实现栈的数据结构。</p>
<p>PriorityQueue有一种特殊的队列，叫做优先队列。优先队列的作用是能保证每次取出的元素都是队列中权值最小的<strong>（Java的优先队列每次取最小元素，C++的优先队列每次取最大元素）。这里牵涉到了大小关系，</strong>元素大小的评判可以通过元素本身的自然顺序（natural ordering），也可以通过构造时传入的比较器（Comparator，类似于C++的仿函数）。</p>
<p>Java中<em>PriorityQueue</em>实现了<em>Queue</em>接口，不允许放入<code>null</code>元素；其通过堆实现，具体说是通过完全二叉树（<em>complete binary tree</em>）实现的<strong>小顶堆</strong>（任意一个非叶子节点的权值，都不大于其左右子节点的权值），也就意味着可以通过数组来作为<em>PriorityQueue</em>的底层实现。</p>
<p>最小堆的完全二叉树有一个特性是根节点必定是最小节点，子女节点一定大于其父节点。还有一个特性是叶子节点数量=全部非叶子节点数量+1。</p>
<p>每次增删元素都有可能对树结构进行调整，所以PriorityQueue队列不适合进场出队入队的频繁操作，但是他的优先级特性非常适合一些对顺序有要求的数据处理场合。</p>
<h2 id="concurrent包"><a href="#concurrent包" class="headerlink" title="concurrent包"></a>concurrent包</h2><p>ConcurrentHashMap</p>
<p>上面HashMap已经说到了HashMap在多个线程同时存取或者触发扩容的时候，都有可能出现错误，导致操作被覆盖或者丢失，那么怎么解决这个问题呐？</p>
<p>第一反应当然是加锁，HashTable就是这么做的，使用了synchronized关键字。虽然解决了并发访问的安全性问题，但是性能不怎么样。HashTable中的增删改、甚至equals、toString方法等等都是方法级的锁，所以同时只能一个线程去操作，导致效率问题。</p>
<p>在JDK1.7及之前版本，ConcurrentHashMap采用的是Segment分段锁，即将数据分为一段一段的存储，然后给每一段数据加一把锁。当一个线程占用锁访问其中一个段数据时，其他段的数据也能被其他线程访问。</p>
<p>在JDK1.8以后，ConcurrentHashMap取消了Segment分段锁，采用CAS和synchronized来保证并发安全。 数据结构与HashMap1.8的结构类似，数组+链表/红黑二叉树(链表长度&gt;8时，转换为红黑树)。</p>
<p>通过 JDK 的源码和官方文档看来， 他们认为的弃用分段锁的原因由以下几点：</p>
<ol>
<li>加入多个分段锁浪费内存空间。</li>
<li>生产环境中， map 在放入时竞争同一个锁的概率非常小，分段锁反而会造成更新等操作的长时间等待。</li>
<li>为了提高 GC 的效率。</li>
</ol>
<p>在JDK11下对HashMap和ConcurrentHashMap进行了简单测试，生成5000万条随机数然后插入，分别消耗16348毫秒和19194毫秒。其中包括随机数生成、插入和扩容的时间消耗，可见两者之间性能差距不大。</p>
<p>然后使用HashTable在单线程下插入，同样的数据量时间在17秒所有，跟HashMap差别不大，可以当做是误差范围内。然后使用20个线程插入，消耗时间在15秒左右，提升并不明显。奇怪的是ConcurrentHashMap却使用了45秒。然后缩小数据量，在1000万以下的时候，ConcurrentHashMap的插入速度又好于HashTable了。这个现象很有意思，有空了详细研究一下产生这个问题的原因。</p>
<p>ConcurrentHashMap的<strong>整体性能</strong>要优于HashTable，但是某些场景不能替代HashTable，例如<strong>强一致性</strong>的场景，ConcurrentHashMap的get、size等方法都<strong>没有加锁</strong>，ConcurrentHashMap是<strong>弱一致性</strong>的。</p>
<p>ConcurrentSkipListMap</p>
<p>concurrentHashMap与ConcurrentSkipListMap性能测试<br>在4线程1.6万数据的条件下，ConcurrentHashMap 存取速度是ConcurrentSkipListMap 的4倍左右。</p>
<p>但ConcurrentSkipListMap有几个ConcurrentHashMap 不能比拟的优点：</p>
<p>1、ConcurrentSkipListMap 的key是有序的。</p>
<p>2、ConcurrentSkipListMap 支持更高的并发。ConcurrentSkipListMap 的存取时间是log（N），和线程数几乎无关。也就是说在数据量一定的情况下，并发的线程越多，ConcurrentSkipListMap越能体现出他的优势。 </p>
<p>ArrayBlockingQueue</p>
<p>ConcurrentLinedQueue</p>
<p>ConcurrentLinkedDeque</p>
<p>ConcurrentSkipSet</p>
<p>CopyOnWriteArrayList</p>
<p>CopyOnWriteArraySet</p>
<p>DelayQueue</p>
<p>LinkedBlockingDeque</p>
<p>LinkedBlockingQueue</p>
<p>LinkedTransferQueue</p>
<p>PriorityBlockingQueue</p>
<p>SynchronousQueue</p>
<p><img src="http://nas.beritra.com:18081/uploads/big/9151c7a0b015e54bdc06bebfaec18be7.jpg" alt=""></p>
<p>参考资料：</p>
<p><a href="https://www.zhihu.com/question/20733617" target="_blank" rel="noopener">JDK 源码中 HashMap 的 hash 方法原理是什么？</a></p>
<p><a href="https://juejin.im/post/5c1c79b16fb9a049a711c97c" target="_blank" rel="noopener">HashMap底层实现原理</a></p>
<p><a href="https://blog.csdn.net/eson_15/article/details/51543812" target="_blank" rel="noopener">【java并发】造成HashMap非线程安全的原因</a></p>
<p><a href="https://blog.csdn.net/luanmousheng/article/details/78587547" target="_blank" rel="noopener">IdentityHashMap源码详解</a></p>
<p><a href="https://blog.csdn.net/itmyhome1990/article/details/77651165" target="_blank" rel="noopener">WeakHashMap实现原理及源码分析</a></p>
<p><a href="https://www.jianshu.com/p/fb37835a8103" target="_blank" rel="noopener">EnumSet 原理相关</a></p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Java/" rel="tag"># Java</a>
              <a href="/tags/%E9%9B%86%E5%90%88/" rel="tag"># 集合</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2019/12/01/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/" rel="prev" title="Java多线程">
      <i class="fa fa-chevron-left"></i> Java多线程
    </a></div>
      <div class="post-nav-item">
    <a href="/2019/12/01/InnoDB%E8%A1%A8%E7%BB%93%E6%9E%84/" rel="next" title="InnoDB 表结构">
      InnoDB 表结构 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Map"><span class="nav-number">1.</span> <span class="nav-text">Map</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#HashMap"><span class="nav-number">1.1.</span> <span class="nav-text">HashMap</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#哈希算法"><span class="nav-number">1.1.1.</span> <span class="nav-text">哈希算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#扩容"><span class="nav-number">1.1.2.</span> <span class="nav-text">扩容</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#存储方式"><span class="nav-number">1.1.3.</span> <span class="nav-text">存储方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#性能"><span class="nav-number">1.1.4.</span> <span class="nav-text">性能</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#线程安全和其他局限"><span class="nav-number">1.1.5.</span> <span class="nav-text">线程安全和其他局限</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LinkedHashMap"><span class="nav-number">1.2.</span> <span class="nav-text">LinkedHashMap</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TreeMap"><span class="nav-number">1.3.</span> <span class="nav-text">TreeMap</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#EnumMap"><span class="nav-number">1.4.</span> <span class="nav-text">EnumMap</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HashTable"><span class="nav-number">1.5.</span> <span class="nav-text">HashTable</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Hashtable-与-HashMap-的简单比较"><span class="nav-number">1.5.1.</span> <span class="nav-text">Hashtable 与 HashMap 的简单比较</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#IdentityHashMap"><span class="nav-number">1.6.</span> <span class="nav-text">IdentityHashMap</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#WeakHashMap"><span class="nav-number">1.7.</span> <span class="nav-text">WeakHashMap</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#List"><span class="nav-number">2.</span> <span class="nav-text">List</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Vector"><span class="nav-number">2.0.1.</span> <span class="nav-text">Vector</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Stack"><span class="nav-number">2.0.2.</span> <span class="nav-text">Stack</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Set"><span class="nav-number">3.</span> <span class="nav-text">Set</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Queue"><span class="nav-number">4.</span> <span class="nav-text">Queue</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#concurrent包"><span class="nav-number">5.</span> <span class="nav-text">concurrent包</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Beritra"
      src="/images/avator.jpg">
  <p class="site-author-name" itemprop="name">Beritra</p>
  <div class="site-description" itemprop="description">Beritra's Blogs</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">28</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">16</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">40</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/beritra" title="Github → https:&#x2F;&#x2F;github.com&#x2F;beritra" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>Github</a>
      </span>
      <span class="links-of-author-item">
        <a href="http://weibo.com/u/3315421093" title="Weibo → http:&#x2F;&#x2F;weibo.com&#x2F;u&#x2F;3315421093" rel="noopener" target="_blank"><i class="fa fa-fw fa-weibo"></i>Weibo</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Beritra</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
