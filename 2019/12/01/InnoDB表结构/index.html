<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.1.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/icon.jpg">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/icon.jpg">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/icon.jpg">
  <link rel="mask-icon" href="/images/icon.jpg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://Beritra.github.com').hostname,
    root: '/',
    scheme: 'Mist',
    version: '7.6.0',
    exturl: false,
    sidebar: {"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta name="description" content="本文大部分内容摘抄至《MySQL技术内幕（InnoDB存储引擎）第二版》，小部分来源于自己理解和网络博客。">
<meta property="og:type" content="article">
<meta property="og:title" content="InnoDB 表结构">
<meta property="og:url" content="http:&#x2F;&#x2F;beritra.github.com&#x2F;2019&#x2F;12&#x2F;01&#x2F;InnoDB%E8%A1%A8%E7%BB%93%E6%9E%84&#x2F;index.html">
<meta property="og:site_name" content="Beritra">
<meta property="og:description" content="本文大部分内容摘抄至《MySQL技术内幕（InnoDB存储引擎）第二版》，小部分来源于自己理解和网络博客。">
<meta property="og:image" content="http:&#x2F;&#x2F;nas.beritra.com:18081&#x2F;uploads&#x2F;big&#x2F;6083671fe7d547fd2a8fd496b5bb0904.png">
<meta property="og:image" content="http:&#x2F;&#x2F;nas.beritra.com:18081&#x2F;uploads&#x2F;big&#x2F;090c385542dcfeb6fdabc2520ffaafd0.png">
<meta property="og:image" content="http:&#x2F;&#x2F;nas.beritra.com:18081&#x2F;uploads&#x2F;big&#x2F;78f4e0e0dc3bd05909f06abf44a56f4b.png">
<meta property="og:image" content="http:&#x2F;&#x2F;nas.beritra.com:18081&#x2F;uploads&#x2F;big&#x2F;b5b0d29d8328223c1873f43074172c39.png">
<meta property="og:image" content="http:&#x2F;&#x2F;nas.beritra.com:18081&#x2F;uploads&#x2F;big&#x2F;97aa2daf41d886ac93e40b1dfd88cca5.png">
<meta property="article:published_time" content="2019-12-01T04:12:12.000Z">
<meta property="article:modified_time" content="2019-12-15T14:39:39.456Z">
<meta property="article:author" content="Beritra">
<meta property="article:tag" content="MySQL">
<meta property="article:tag" content="数据库">
<meta property="article:tag" content="InnoDB">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http:&#x2F;&#x2F;nas.beritra.com:18081&#x2F;uploads&#x2F;big&#x2F;6083671fe7d547fd2a8fd496b5bb0904.png">

<link rel="canonical" href="http://beritra.github.com/2019/12/01/InnoDB%E8%A1%A8%E7%BB%93%E6%9E%84/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true
  };
</script>

  <title>InnoDB 表结构 | Beritra</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Beritra</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">Blogs</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="搜索..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://beritra.github.com/2019/12/01/InnoDB%E8%A1%A8%E7%BB%93%E6%9E%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avator.jpg">
      <meta itemprop="name" content="Beritra">
      <meta itemprop="description" content="Beritra's Blogs">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Beritra">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          InnoDB 表结构
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-12-01 12:12:12" itemprop="dateCreated datePublished" datetime="2019-12-01T12:12:12+08:00">2019-12-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-12-15 22:39:39" itemprop="dateModified" datetime="2019-12-15T22:39:39+08:00">2019-12-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MySQL/" itemprop="url" rel="index">
                    <span itemprop="name">MySQL</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>9.5k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>16 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>本文大部分内容摘抄至《MySQL技术内幕（InnoDB存储引擎）第二版》，小部分来源于自己理解和网络博客。</p>
<a id="more"></a>

<h2 id="索引组织表"><a href="#索引组织表" class="headerlink" title="索引组织表"></a>索引组织表</h2><p>在InnoDB存储引擎中，表都是根据主键顺序组织存放的，这种存储方式的表成为索引组织表（Index Organized table）。在InnoDB存储引擎表中，每张表都有个主键（Primary Key），如果在创建表的时候没有仙式地定义主键，则InnoDB会按照以下方式选择或创建主键：</p>
<ul>
<li>首次按判断表中是否有非空的唯一索引（Unique NOT NULL），如果有，则该列为主键。</li>
<li>如果没有，InnoDB存储引擎会自动创建一个6字节大小的指针。</li>
</ul>
<blockquote>
<p> 当表中有多个非空唯一索引的时候，InnoDB存储引擎将选择建表的时候第一个定义的非空唯一索引作为主键。注意这里是定义索引的顺序，而不是建表的时候列的顺序。</p>
</blockquote>
<h2 id="InnoDB逻辑存储结构"><a href="#InnoDB逻辑存储结构" class="headerlink" title="InnoDB逻辑存储结构"></a>InnoDB逻辑存储结构</h2><p>从InnoDB存储应引擎的存储结构来看，所有的数据都被逻辑的存放在一个空间中，成为表空间（tablespace）。表空间又由段（segment）、区（extent）、页（page）组成。页在一些文档中也成为块（block），InnoDB存储引擎的逻辑存储结构大致如图：</p>
<p><img src="http://nas.beritra.com:18081/uploads/big/6083671fe7d547fd2a8fd496b5bb0904.png" alt=""></p>
<h3 id="表空间"><a href="#表空间" class="headerlink" title="表空间"></a>表空间</h3><p>表空间可以看做是InnoDB存储引擎逻辑结构的最高层，所有的数据都存放在表空间中。默认情况下InnoDB存储引擎有一个共享表空间ibdata1，所有的数据都存放在这个表空间中。如果用户开启了参数<code>innodb_fiule_per_table</code>，则每张表内的数据可以单独放在一个表空间中。</p>
<blockquote>
<p>即使启用了<code>innodb_fiule_per_table</code>，每张表的表空间内从存放的也只是数据、索引和插入缓冲Bitmap页，其他类型的数据比如回滚（undo）、插入缓冲索引页、系统事务信息、二次写缓冲（Double write buffer）等还是存放在原有共享表空间。</p>
</blockquote>
<h3 id="段"><a href="#段" class="headerlink" title="段"></a>段</h3><p>上面的图已经显示了表空间是由各个段组成的，常见的段有数据段、索引段、回滚段等。因为前面已经介绍过了InnoDB存储引擎表是索引组织（index organized）的，因此数据即索引，索引即数据。那么数据段即B+树的叶子节点（图中的Leaf node segment），索引段即B+树中的非索引节点（图中的Non-leaf node segment）。回滚段较为特殊。</p>
<h3 id="区"><a href="#区" class="headerlink" title="区"></a>区</h3><p>区是由连续的页组成的空间，在任何情况下，每个区的大小都为1MB。为了保证区中页的连续性，InnoDB存储引擎一次从磁盘中申请4~5个区。在默认情况下，InnoDB存储引擎页的大小为16KB，即一个区中一共有64个连续的页。</p>
<p>InnoDB 1.0.x 版本开始引入压缩页，即每个夜的大小可以通过<code>KEY_BLOCK_SIZE</code>设置为2K、4K、8K，因此每个区对应页的数量就应该是512、256、128。</p>
<p>InnoDB 1.2.x 版本新增了参数 <code>innodb_page_size</code>，通过该参数可以将默认页的大小设置为4K、8K，但是页中的数据库不是压缩。这是区中页的数量同样页是256、128。总之，不论页的大小怎么变化，区的大小总为1M。</p>
<h3 id="页"><a href="#页" class="headerlink" title="页"></a>页</h3><p>同大多数数据库一样，InnoDB有页（Page）的概念（也可以称之为块），页是InnoDB磁盘管理的最小单位。</p>
<p>在InnoDB存储引擎中，常见的页类型有：</p>
<ul>
<li>数据页（B-tree Node）</li>
<li>undo页（undo Log Page）</li>
<li>系统页（System Page）</li>
<li>事务数据页（Transaction system Page）</li>
<li>插入缓冲位图页（Insert Buffer Bitmap）</li>
<li>插入缓冲空闲列表页（Inser Buffer Free List）</li>
<li>未压缩的二进制大对象页（Uncompressed BLOB Page）</li>
<li>压缩的二进制大对象页（compressed BLOB Page）</li>
</ul>
<h3 id="行"><a href="#行" class="headerlink" title="行"></a>行</h3><p>InnoDB存储引擎是面向列的（row-oriented），也就是说数据是按行进行存放的。每个页存放的行记录也是有硬性规定的，最多允许存放16KB/2-200行记录，即7992行。</p>
<h2 id="InnoDB行记录格式"><a href="#InnoDB行记录格式" class="headerlink" title="InnoDB行记录格式"></a>InnoDB行记录格式</h2><p>InnoDB引擎和大多数数据库一样，记录以行的形式存储。这意味这页中保存着表中一行行的数据。在InnoDB 1.0.x 版本之前，InnoDB存储引擎提供了Compact 和 Redundant 两种格式来存放行记录数据，这也是目前使用最多的一种格式。Redundant 格式是为了兼容之前版本而保留的，MySQL 5.1之后的版本默认为 Compact 行格式。可以使用命令<code>SHOW TABLE STATUS LIKE &#39;table_name&#39;</code>来查看当前表使用的行格式。</p>
<h3 id="Compact-行记录格式"><a href="#Compact-行记录格式" class="headerlink" title="Compact 行记录格式"></a>Compact 行记录格式</h3><p>Compact行记录格式的设计目标是高效的存储数据，简单来说就是一个页中存放的行数据越多，性能就越高。下图是详细的存储格式：</p>
<p><img src="http://nas.beritra.com:18081/uploads/big/090c385542dcfeb6fdabc2520ffaafd0.png" alt=""></p>
<p>可以看到，Compact 行记录的格式首部是一个非 NULL 变长字段长度列表，并且是按照列的顺序逆序放置的，长度为：</p>
<ul>
<li>若列的长度小于255字节，则用1字节表示；</li>
<li>若大于255个字节，用2字节表示。</li>
</ul>
<p>变长字段的长度不可以超过两个字节，因为 VARCHAR 类型的最大长度限制为 65535。变长字段之后的第二个部分是 NULL 标志位，该位指示了该位数据中是否有 NULL 值，有则用1表示。接下来的部分是记录头信息（record header），固定占用5字节（40位），每位的含义如下：</p>
<p><img src="http://nas.beritra.com:18081/uploads/big/78f4e0e0dc3bd05909f06abf44a56f4b.png" alt=""></p>
<p>最后的部分就是实际存储每个列的数据。需要特别注意的是，NULL 不占用该部分任何空间，即 NULL 除了占用 NULL 标志位之外，实际存储不占用空间。另外，每行数据除了用户定义的之外，还有两个隐藏列，事务ID列和回归指针列，分别是6和7字节大小。如果 InnoDB 表没有定义主键，还会增加一个6字节的 rowid 列。</p>
<h3 id="行溢出数据"><a href="#行溢出数据" class="headerlink" title="行溢出数据"></a>行溢出数据</h3><p>InnoDB 存储引擎可以将一条记录中的某些数据存储在真正的数据页面之外。一般认为 BLOB 、 LOB 这类的大对象列类型的存储会把数据放在数据页面之外。但是不是这样的，BLOB 可以不放在溢出页面，而且即便 VARCHAR 这种类型也可能被存放为行溢出数据。</p>
<p>MySQL 数据库的 VARCHAR 类型理论上可以存放 65535 字节，实际上创建一个 65535 长度的列的时候，会得到错误信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">[42000][1118] Row size too large. The maximum row size for the used table type, not counting BLOBs, is 65535. This includes storage overhead, check the manual. You have to change some columns to TEXT or BLOBs.</span></pre></td></tr></table></figure>

<p>由于还有别的开销，经过实际测试，能存放 VARCHAR 类型的最大长度是65532。</p>
<p>这里需要注意，65535 是说的字节数，如果你是用的是多字节的字符集，比如我用utf8mb4，没个字占用4个字节，创建会提示<code>[42000][1074] Column length too big for column &#39;varchars&#39; (max = 16383); use BLOB or TEXT instead.</code>，即<code>varchar</code>字段已经被限制到了16383的长度。</p>
<p>此外，还要注意，MySQL 官方手册中定义的65535长度是指所有 VARCHAR 列的长度综合，如果综合超过了这个长度，依然无法创建，同样是上面那个错误提示。</p>
<p>即便能够存储65535个字节，但是，InnoDB 引擎的页为 16KB，即16384字节，怎么能存放65535个字节呐？因此，在一般情况下，InnoDB引擎存储的数据都是放在页类型为B-tree node中。但是当发生行溢出的时候，数据存放在页类型为 Uncompress BLOB 页中。</p>
<p>通过工具可以看到，数据也只保存 VARCHAR 的前768的前缀（prefix）数据，之后都是偏移量，指向行溢出页，也就是 Uncompressed BLOB Page。因此，对于行溢出数据，存放采用下图的方式：</p>
<p><img src="http://nas.beritra.com:18081/uploads/big/b5b0d29d8328223c1873f43074172c39.png" alt=""></p>
<p>那么新的问题又来了，多长的 VARCHAR 是保存在单个数据页中的，多长开始会保存在 BLOB 中？</p>
<p>InnoDB存储引擎表是索引组织的，即 B+Tree 结构，这样每个页中至少应该有两条记录（不然就退化成链表了）。因此，如果页中只能存下一条记录，那么 InnoDB 引擎就会自动将行数据放到溢出页中。</p>
<p>经过测试，这个数字是 8098 ，如果少于这个长度，一个页中就可以放入至少两行数据，VARCHAR 类型的行数据就不会被放到 BLOB 页中去。</p>
<p>另一个问题，对于 TEXT 和 BLOB 数据类型，他们也不是永远存放在 Uncompressed BLOB Page 中的，跟 VARCHAR 类似，至少保证一个页中能存放两条记录。当然一般 BLOB 不会这么小，大多数情况下还是会发生行溢出，数据页只保存前 768 字节，实际数据还是存在 BLOB 页中。</p>
<h2 id="InnoDB数据页结构"><a href="#InnoDB数据页结构" class="headerlink" title="InnoDB数据页结构"></a>InnoDB数据页结构</h2><p>页是 InnoDB 存储引擎管理数据库的最小磁盘单位。也类型为 B-tree Node 的页存放的即是表中行的实际数据了。</p>
<p>InnoDB 数据页由以下7个部分组成，如图所示：</p>
<ul>
<li>File Header（文件头）</li>
<li>Page Header（页头）</li>
<li>Infimun 和 Supremum Records</li>
<li>User Records（用户记录，即行记录）</li>
<li>Free Space（空闲空间）</li>
<li>Page Directory（页目录）</li>
<li>File Trailer（文件结尾信息）</li>
</ul>
<p>其中 File Header、Page Header、File Trailer 的大小是固定队的，分别为38、56、8字节，这些空间用来标记也得一些信息，如 Checksum，数据页所以在的 B+ 树索引的层数等。User Records、Free Space、Page Dirctory 这些部分为实际的行记录存储空间，因此大小是动态的。</p>
<p><img src="http://nas.beritra.com:18081/uploads/big/97aa2daf41d886ac93e40b1dfd88cca5.png" alt=""></p>
<h2 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h2><h3 id="约束完整性"><a href="#约束完整性" class="headerlink" title="约束完整性"></a>约束完整性</h3><p>关系型数据库和文件系统的一个不同点是，关系数据库本身能够保证存储数据的完整性，不需要应用程序的控制，而文件系统一般都需要在程序端进行控制。当前几乎所有的关系型数据库都提供了约束（constraint）机制，来保证数据的完整性。</p>
<p>对 InnoDB 存储引擎本身而言，提供了以下几种约束：</p>
<ul>
<li>Primary Key</li>
<li>Unique Key</li>
<li>Foreign Key</li>
<li>Default</li>
<li>NOT NULL</li>
</ul>
<h3 id="约束的创建和查找"><a href="#约束的创建和查找" class="headerlink" title="约束的创建和查找"></a>约束的创建和查找</h3><p>约束的创建可以用以下两种方式：</p>
<ul>
<li>表建立的时候进行约束定义</li>
<li>利用<code>ALTER TABLE</code>命令来创建约束</li>
</ul>
<p>对于 Unique Key （唯一索引）的约束，用户可以通过命令<code>CREATE UNIQUE INDEX</code>来建立。对于主键约束而言，默认约束名为 PRIMARY  。</p>
<h3 id="约束和索引的区别"><a href="#约束和索引的区别" class="headerlink" title="约束和索引的区别"></a>约束和索引的区别</h3><p>创建约束的方法通常就是创建索引的方法，的确，当用户创建了一个唯一索引就创建了一个唯一约束。但是约束和索引的概念还是有所不同的，约束更是一个逻辑的概念，用来保证数据的完成性，而索引是一个数据结构，既有逻辑上的概念，在数据库中还代表着物理存储的方式。</p>
<h3 id="对错误数据的约束"><a href="#对错误数据的约束" class="headerlink" title="对错误数据的约束"></a>对错误数据的约束</h3><p>在某些设置下，MySQL 允许非法的或不正确的数据的插入或更新，又或者可以在数据库内部将其转化为一个合法的值，如向 NOT NULL 的字段中插入一个 NULL值，MySQL 数据库会将其改为0再插入，因此数据库本身没有对数据的正确性进行约束。而通过设置 <code>sql_mode</code>参数，MySQL 数据库又可以堆输入的合法值进行约束。详细设置可以参考<a href="https://dev.mysql.com/doc/refman/8.0/en/sql-mode.html" target="_blank" rel="noopener">MySQL官方手册中对 sql_mode 的说明</a>。</p>
<h3 id="外键约束"><a href="#外键约束" class="headerlink" title="外键约束"></a>外键约束</h3><p>MyISAM 存储引擎本身不支持外键，而 InnoDB 则完整支持外键约束。现在有一定规模的项目都会不建议甚至强制不允许使用外键，具体原因可以再专门探讨，这里就不详细说明外键的使用方法和原理了，只记录几个知识要点。</p>
<p>可以定义的字表操作：</p>
<ul>
<li>CASCADE：父表变化时子表与父表进行一样的操作</li>
<li>SET NULL：父表变化时子表设为 NULL</li>
<li>NO ACTION：父表抛出错误，阻止操作</li>
<li>RESTRICT：同上, 都是立即检查外键约束</li>
</ul>
<p>数据库默认的设置是 RESTRICT。</p>
<h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><p>在MySQL数据中，视图（View）是一个命名的虚表，它由一个 SQL 查询来定义，可以当做表使用。与持久表（permanent table）不同的是，视图中的数据没有实际的物理存储。</p>
<h3 id="视图的作用"><a href="#视图的作用" class="headerlink" title="视图的作用"></a>视图的作用</h3><p>视图的主要用途之一是被用作一个抽象装置，特别是对于一些应用程序，程序本身不需要关心基表（base table）的结构，只需要按照视图定义来取数据或者更新数据，因此，视图层在一定程度上起到一个安全层的作用。</p>
<p>创建视图的语法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">CREATE</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    [OR REPLACE]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    [ALGORITHM &#x3D; &#123;UNDEFINED | MERGE | TEMPTABLE&#125;]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    [DEFINER &#x3D; user]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    [SQL SECURITY &#123; DEFINER | INVOKER &#125;]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    VIEW view_name [(column_list)]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    AS select_statement</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    [WITH [CASCADED | LOCAL] CHECK OPTION]</span></pre></td></tr></table></figure>

<p>虽然视图是基于基表的虚拟表，但是用户可以对某些视图进行更新操作，其本质就是通过视图的定义来更新基表。</p>
<p>一般称可以进行更新操作的视图成为可更新视图（updatable view）。视图定义中的 WITH CHECK OPTION 就是针对于可更新的视图的，即更新的值是否需要检查。</p>
<h2 id="分区表"><a href="#分区表" class="headerlink" title="分区表"></a>分区表</h2><h3 id="分区概述"><a href="#分区概述" class="headerlink" title="分区概述"></a>分区概述</h3><p>分区功能并不是在存储引擎层完成的，因此不是只有 InnoDB 存储引擎支持分区，常见的存储引擎 MyISAM、NDB等都支持。但也并不是所有的存储引擎都支持，如 CSV、FEDORATED、MERGE 等就不支持。在使用分区功能前，应该对选择的存储引擎对分区的支持有所了解。</p>
<p>MySQL 数据库在5.1版本时就添加了对分区的支持。分区的过程是将一个表或索引分解为多个更小、更可管理的部分。就访问数据库的应用而言，从逻辑上讲，只有一个表或一个索引，但是在物理上，这个表或索引可能由数十个物理分区组成。每个分区都是独立的对象，可以独自处理，也可以作为一个更大对象的一部分进行处理。</p>
<p>MySQL 数据库支持的分区类型为水平分区，并不支持垂直分区。此外，MySQL 数据的分区是局部分区索引，一个分区中即存放了数据又存放了索引。而全局分区是指，数据存放在各个分区中，但是所有数据的索引放在一个对象中。目前，MySQL 数据库还不支持全局分区。</p>
<p>MySQL 数据库支持以下几种分区：</p>
<ul>
<li>RANGE 分区：行数据基于属于一个给定连续区间的列值被放入分区。MySQL 5.5 开始支持 RANGE COLUMNS 的分区。</li>
<li>LIST 分区：和 RANGE 分区类似，只是 LIST 分区面向的是离散的值。 MySQL 5.5 开始支持 LIST COLUMNS 的分区。</li>
<li>HASH 分区：根据用户自定义的表达式的返回值来进行分区，返回值不能为负数。</li>
<li>KEY 分区：根据 MySQL 数据库提供的哈希函数来进行分区。</li>
</ul>
<p>无论创建何种类型的分区，如果分区表中存在主键或唯一索引时，分区列必须是唯一索引的一个组成部分。</p>
<p>唯一索引是允许 NULL 值的，并且分区列只要是唯一索引的一个组成部分，不需要是整个唯一索引列都是分区列。</p>
<p>另外，如果建表时没有指定主键，唯一索引，可以指定任何一个列为分区列。</p>
<h3 id="分区类型"><a href="#分区类型" class="headerlink" title="分区类型"></a>分区类型</h3><h4 id="RANGE-分区"><a href="#RANGE-分区" class="headerlink" title="RANGE 分区"></a>RANGE 分区</h4><p>RANGE分区是最常用的一种分区。下面的<code>CREATE TABLE</code>语句创建了一个 id 列的区间分区表。当 id 小于10时，数据插入 p0 分区。当 id 等于10 小于 20时，数据插入 p1 分区。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">CREATE TABLE t&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">id INT</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">&#125;ENGINE&#x3D;INNODB</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">PARTITION BY RANGE(id)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">PARTITION p0 VALUES LESS THAN(10),</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">PARTITION p1 VALUES LESS THAN(20));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>这时候查看磁盘上的物理文件，启用分区表之后，文件不再是由一个 ibd 文件组成了，而是由建立分区时的各个分区 ibd 文件组成。</p>
<p>可以通过查询<code>information_cheme</code>架构下的 PARATITIONS 表来查看每个分区的具体信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">SELECT * FROM information_scheme.PARTITIONS where table_scheme&#x3D;database() and table_name&#x3D;&#39;t&#39;\G;</span></pre></td></tr></table></figure>

<p>RANGE 分区主要用于日期列的分区，例如销售类的表，按年进行分区存放销售记录。这样的好处就是，便于对表进行管理。比如要删除某一年的数据，不需要在 where 里面写大段的时间参数，只需删除对应年份所在的分区即可。另一个好处就是可以加快某些查询操作，比如查询某一年的销售额，使用预先设定好的分区可以加快查询速度。</p>
<h4 id="LIST-分区"><a href="#LIST-分区" class="headerlink" title="LIST 分区"></a>LIST 分区</h4><p>LIST 分区个 RANGE 分区非常相似，只是分区列的值是离散的，而非连续的。比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">CREATE TABLE t(</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">a INT,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">b INT)ENGINE&#x3D;INNODB</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">PARTITION BY LIST(b)(</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">PARTITION p0 VALUES IN(1,3,5,7,9),</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">PARTITION p1 VALUES IN(0,2,4,6,8)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">);</span></pre></td></tr></table></figure>

<p>不同于 RANGE 分区中定义的<code>VALUES LESS TAHN</code>语句，LIST 分区使用 <code>VALUES IN</code>。因为每个分区的值是离散的，因此只能定义值。</p>
<h4 id="HASH-分区"><a href="#HASH-分区" class="headerlink" title="HASH 分区"></a>HASH 分区</h4><p>HASH分区的目的是将数据均匀的分不到预先定义的各个分区中，保证各个分区的数据量大致都一样的。在 RANGE 和 LIST 分区中，必须明确指定一个给定的列值或列值集合应该保存在哪个分区中；而在 HASH 分区中，MySQL 自动完成这些工作，用户需要做的只是基于将要进行哈希分区的列值指定一个列值或者表达式，以及指定被分区的表将要被分割的分区数量。</p>
<p>要使用 HASH 分区来分割一个表，要在 CREATE TABLE 语句上添加一个<code>PARTITION BY HASH（expr）</code>子句，其中<code>expr</code>是一个返回一个整数的表达式。它可以仅仅是字段类型为 MySQL 整型的列名。此外，用户很可能需要在后面再添加一个<code>PARTITIONS num</code>子句，其中 num 是一个非负的整数，它表示将要被分割成分区的数量。如果没有包含一个 PARTITIONS 字句，那么分区数量将默认为1。</p>
<p>下面的例子创建了一个 HASH 分区的表 t，分区按日期列 b 进行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">CREATE TABLE t_hash(</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">a INT,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">b DATETIME)ENGINE&#x3D;INNODB</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">PARTITION BY HASH(YEAR(b))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">PARTITIONS 4;</span></pre></td></tr></table></figure>

<p>MySQL 数据库还支持一种成为 <code>LINEAR HASH</code>的分区，它使用一个更加复杂的算法来确定新行插入到已经分区的表中的位置。它的语法和 HASH 分区的语法相似，只是将关键字 HASH 改为 LINEAR HASH。下面创建的是一个 LINEAR HASH 的分区表：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">CREATE TABLE t_linear_hash(</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">a INT,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">b DATETIME)ENGINE&#x3D;INNODB</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">PARTITION BY LINEAR HASH(YEAR(b))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">PARTITIONS 4;</span></pre></td></tr></table></figure>

<p>LINEAR HASH 分区的优点在于，增加、删除、合并和拆分分区将变得更加快捷，这有利于处理含有大量数据库的表。缺点在于，与使用 HASH 分区得到的数据分布相比，各个分区间数据的分布可能不太均衡。</p>
<h4 id="KEY-分区"><a href="#KEY-分区" class="headerlink" title="KEY 分区"></a>KEY 分区</h4><p>KEY 分区和 HASH 分区相似，不同之处在于 HASH 分区使用用户定义的函数进行分区，KEY 分区使用 MySQL 数据库提供的函数进行分区，对于 NDB Cluster 引擎，MySQL 数据库使用 MD5 函数来分区；对于其他存储引擎， MySQL 数据库使用其内部的哈希函数，这些函数基于与 PASSWORD() 一样的运算法则。</p>
<h4 id="COLUMNS-分区"><a href="#COLUMNS-分区" class="headerlink" title="COLUMNS 分区"></a>COLUMNS 分区</h4><p>前面介绍的4种分区，分区得条件是：数据必须是整形（integer），如果不是整型，那应该需要通过函数化为整型。MySQL 5.5 版本开始支持 COLUMNS 分区，可以视为 RANGE 分区和 LIST 分区的一种进化。COLUMNS 分区可以直接使用非整形的数据进行分区，分区根据类型直接比较而得，不需要转化为整形。此外 RANGE COLUMNS 分区可以对多个列的值进行分区。</p>
<p>COLUMNS 分区支持以下的数据类型：</p>
<ul>
<li>所有整形类型，如 INT、SMALLINT、TINYINT、BIGINT。FLOAT 和 DECIMAL 则不予支持。</li>
<li>日期类型，如 DATE 和 DATETIME。其余的日期类型则不予支持。</li>
<li>字符串类型，如 CHAR、VARCHAR、BINARY 和 VARBINARY。BLOB 和 TEXT 类型不予支持。</li>
</ul>
<p>对于日期类型的分区，我们不再需要<code>YEAR()</code>和<code>TO_DODAY()</code>函数了，而可以直接使用 COLUMNS。</p>
<h3 id="子分区"><a href="#子分区" class="headerlink" title="子分区"></a>子分区</h3><p>子分区（subpartitioning）是在分区的基础上在进行分区，有时也称这种分区为复合分区（composite partitioning）。MySQL 数据库允许在 RANGE 和 LIST 的分区上在进行 HASH 和 KEY 的子分区。</p>
<p>但是子分区的建立需要注意以下几个问题：</p>
<ul>
<li>每个子分区的数量必须相同。</li>
<li>要在一个分区表的任何分区上使用 SUBPARTITION 来明确定义任何子分区，就必须定义所有的子分区。</li>
<li>每个 SUBPARTITION 子句必须包括子分区的一个名字。</li>
<li>子分区的名字必须是唯一的。</li>
</ul>
<h3 id="分区中的NULL值"><a href="#分区中的NULL值" class="headerlink" title="分区中的NULL值"></a>分区中的NULL值</h3><p>MySQL数据库允许堆 NULL 值进行分区，但是处理方法和其他数据库可能完全不同。MySQL 数据库的分区总是视 NULL 值小于任何一个非 NULL 值，这和 MySQL 数据库中处理 NULL 值的<code>ORDER BY</code>操作是一样的。因此对于不同的分区类型，MySQL 数据库对于 NULL 值的处理也是各不相同。</p>
<ul>
<li><p>对于 RANGE 分区，如果向分区中插入了 NULL 值，则 MySQL 数据库会将该值放入最左边的分区。</p>
</li>
<li><p>LIST 分区必须显式指出向哪个分区中放入 NULL 值，否则会报错。</p>
</li>
<li><p>HASH 分区和 KEY 分区跟上面又不相同，任何分区函数都会将含有 NULL 值的记录返回为0。</p>
</li>
</ul>
<h3 id="分区和性能"><a href="#分区和性能" class="headerlink" title="分区和性能"></a>分区和性能</h3><p>在合理使用分区之前，必须了解分区的使用环境。</p>
<p>数据库的应用分为两类：一类是 OLTP（在线事务处理），如 Blog、电子商务、网络游戏等；另一类是 OLAP（在线分析处理），如数据仓库、数据集市。</p>
<p>对于 OLAP 的应用，分区的确是能够很好地提高查询性能，因为 OLAP 应用大多数查询需要频繁的扫描一张很大的表。</p>
<p>然而对于 OLTP 的应用，分区应该非常小心。在这种应用下，通常不可能获取一张表中超过 10%，大部分通过索引返回几条记录即可。而根据 B+ 树索引的原理，一般的 B+ 树需要2~3次的磁盘 IO ，因此 B+ 树已经可以很好地完成操作，不需要分区的帮助，而且设计不好的分区会带来严重的性能问题。</p>
<h3 id="在表和分区间交换数据"><a href="#在表和分区间交换数据" class="headerlink" title="在表和分区间交换数据"></a>在表和分区间交换数据</h3><p>在MySQL 5.6 开始支持<code>ALTER TABLE ... EXCHANGE PARTITION</code>语法。该语句允许分区或子分区中的数据与另一个非分区的表中的数据进行交换。如果非分区表中的数据为空，那么相当于将分区中的数据移动到非分区表中。若分区表中的数据为空，则相当于将外部表中的数据导入到分区中。</p>
<p>要使用<code>ALTER TABLE ... EXCHANGE PARTITION</code>语句，必须满足：</p>
<ul>
<li>要交换的表和分区表有相同的结构，但是不能含有分区</li>
<li>在非分区表中的数据必须在交换的分区定义中</li>
<li>被交换的表中不能含有外键，或者其他的表含有对该表的外键引用</li>
<li>用户除了需要 ALTER、INSERT 和 CREATE 权限外，还需要 DROP 的权限</li>
</ul>
<p>此外，还有两个小的细节需要注意：</p>
<ul>
<li>使用该语句的时候，不会触发交换表和被交换表上的触发器</li>
<li>AUTO_INCREMENT 列将被重置</li>
</ul>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/MySQL/" rel="tag"># MySQL</a>
              <a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="tag"># 数据库</a>
              <a href="/tags/InnoDB/" rel="tag"># InnoDB</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2019/12/01/Java%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E9%9B%86%E5%90%88%E7%B1%BB/" rel="prev" title="Java中的各种集合类">
      <i class="fa fa-chevron-left"></i> Java中的各种集合类
    </a></div>
      <div class="post-nav-item">
    <a href="/2019/12/01/InnoDB%E5%92%8CMyISAM%E5%8C%BA%E5%88%AB%E5%92%8C%E8%81%94%E7%B3%BB/" rel="next" title="InnoDB和MyISAM区别和联系">
      InnoDB和MyISAM区别和联系 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#索引组织表"><span class="nav-number">1.</span> <span class="nav-text">索引组织表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#InnoDB逻辑存储结构"><span class="nav-number">2.</span> <span class="nav-text">InnoDB逻辑存储结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#表空间"><span class="nav-number">2.1.</span> <span class="nav-text">表空间</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#段"><span class="nav-number">2.2.</span> <span class="nav-text">段</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#区"><span class="nav-number">2.3.</span> <span class="nav-text">区</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#页"><span class="nav-number">2.4.</span> <span class="nav-text">页</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#行"><span class="nav-number">2.5.</span> <span class="nav-text">行</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#InnoDB行记录格式"><span class="nav-number">3.</span> <span class="nav-text">InnoDB行记录格式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Compact-行记录格式"><span class="nav-number">3.1.</span> <span class="nav-text">Compact 行记录格式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#行溢出数据"><span class="nav-number">3.2.</span> <span class="nav-text">行溢出数据</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#InnoDB数据页结构"><span class="nav-number">4.</span> <span class="nav-text">InnoDB数据页结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#约束"><span class="nav-number">5.</span> <span class="nav-text">约束</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#约束完整性"><span class="nav-number">5.1.</span> <span class="nav-text">约束完整性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#约束的创建和查找"><span class="nav-number">5.2.</span> <span class="nav-text">约束的创建和查找</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#约束和索引的区别"><span class="nav-number">5.3.</span> <span class="nav-text">约束和索引的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#对错误数据的约束"><span class="nav-number">5.4.</span> <span class="nav-text">对错误数据的约束</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#外键约束"><span class="nav-number">5.5.</span> <span class="nav-text">外键约束</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#视图"><span class="nav-number">6.</span> <span class="nav-text">视图</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#视图的作用"><span class="nav-number">6.1.</span> <span class="nav-text">视图的作用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#分区表"><span class="nav-number">7.</span> <span class="nav-text">分区表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#分区概述"><span class="nav-number">7.1.</span> <span class="nav-text">分区概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#分区类型"><span class="nav-number">7.2.</span> <span class="nav-text">分区类型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#RANGE-分区"><span class="nav-number">7.2.1.</span> <span class="nav-text">RANGE 分区</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#LIST-分区"><span class="nav-number">7.2.2.</span> <span class="nav-text">LIST 分区</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HASH-分区"><span class="nav-number">7.2.3.</span> <span class="nav-text">HASH 分区</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#KEY-分区"><span class="nav-number">7.2.4.</span> <span class="nav-text">KEY 分区</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#COLUMNS-分区"><span class="nav-number">7.2.5.</span> <span class="nav-text">COLUMNS 分区</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#子分区"><span class="nav-number">7.3.</span> <span class="nav-text">子分区</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#分区中的NULL值"><span class="nav-number">7.4.</span> <span class="nav-text">分区中的NULL值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#分区和性能"><span class="nav-number">7.5.</span> <span class="nav-text">分区和性能</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#在表和分区间交换数据"><span class="nav-number">7.6.</span> <span class="nav-text">在表和分区间交换数据</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Beritra"
      src="/images/avator.jpg">
  <p class="site-author-name" itemprop="name">Beritra</p>
  <div class="site-description" itemprop="description">Beritra's Blogs</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">28</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">16</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">40</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/beritra" title="Github → https:&#x2F;&#x2F;github.com&#x2F;beritra" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>Github</a>
      </span>
      <span class="links-of-author-item">
        <a href="http://weibo.com/u/3315421093" title="Weibo → http:&#x2F;&#x2F;weibo.com&#x2F;u&#x2F;3315421093" rel="noopener" target="_blank"><i class="fa fa-fw fa-weibo"></i>Weibo</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Beritra</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    <span title="站点总字数">190k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">5:16</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
