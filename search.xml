<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Java高级特性：泛型、反射、动态代理和注解</title>
    <url>/2020/05/10/Java%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%EF%BC%9A%E6%B3%9B%E5%9E%8B%E3%80%81%E5%8F%8D%E5%B0%84%E3%80%81%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%92%8C%E6%B3%A8%E8%A7%A3/</url>
    <content><![CDATA[<p>Java 高级特性有挺多，但是这几个一直没搞太通透，只会简单用用，为什么这么设计，有没有什么有意思的玩法都没探究过，今天就来整理一下。</p>
<a id="more"></a>

<h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p>说到泛型，肯定很熟悉了，我们天天用的 List:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list=<span class="keyword">new</span> ArrayList&lt;&gt;();</span></pre></td></tr></table></figure>

<p><code>ArrayList</code>就是个泛型类，我们通过设定不同的类型，可以往集合里面存储不同的数据类型（而且只能存储设定的数据类型，这是泛型的优势之一）。“泛型”简单的意思就是泛指的类型（参数化类型）。</p>
<p>有人灵机一动，就问这里为什么不用<code>Object</code>，到时候再转呐？</p>
<p>问得好，在泛型出现之前，的确是这么做的。但是这样的有一个问题：如果集合里面数据很多，某一个数据转型出现错误，在编译期是无法发现的，但是在运行期会发生<code>java.lang.ClassCastException</code>。</p>
<p>泛型一方面让我们只能往集合中添加一种类型的数据，同时可以让我们在编译期就发现这些错误，避免运行时异常的发生，提升代码的健壮性。</p>
<p>我们可以从以下几个方面理解泛型：</p>
<ul>
<li>泛型通配符</li>
<li>泛型类</li>
<li>泛型接口</li>
<li>泛型方法</li>
<li>泛型擦除</li>
<li>泛型数组</li>
</ul>
<h3 id="泛型符号"><a href="#泛型符号" class="headerlink" title="泛型符号"></a>泛型符号</h3><p>可能有人注意到有不同的泛型符号，其实泛型可以使用任何大写字母定义，把 T 换成 A 也一样，这里 T 只是名字上的意义而已。以下是一般约定俗成的符号意义：</p>
<blockquote>
<p> E - Element (在集合中使用，因为集合中存放的是元素)<br> T - Type（Java 类）<br> K - Key（键）<br> V - Value（值）<br> N - Number（数值类型）<br> ？-  表示不确定的 Java 类型</p>
</blockquote>
<p>对于<code>？</code>类型的泛型，我们称之为通配符，又有以下三种情况：</p>
<h4 id="无限通配符-lt-gt"><a href="#无限通配符-lt-gt" class="headerlink" title="无限通配符&lt;?&gt;"></a>无限通配符&lt;?&gt;</h4><p>无限通配符可以表示所有的类型。可能一般会有疑惑，泛型本来就具备泛化的功能，可以表示所有类型，那么<code>&lt;T&gt;</code>和<code>&lt;?&gt;</code>区别是什么？无限通配符的主要作用就是让泛型能够接受未知类型的数据。</p>
<p>？和 T 都表示不确定的类型，区别在于我们可以对 T 进行操作，但是对 ？不行，比如如下这种 ：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 可以</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">T t = operate();</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 不可以</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">？ car = operate();</span></pre></td></tr></table></figure>

<p>T 是用于定义的时候，而 ? 用于使用的时候，我们可以这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    T t;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>但是不可以：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>&lt;?&gt; </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ? t;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>在调用的时候想法，我们可以用 ? 表示一个未知的泛型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Test&lt;?&gt; test = <span class="keyword">new</span> Test&lt;&gt;();</span></pre></td></tr></table></figure>

<p>这时候就不能用 T 了。但是注意，这里<code>Test&lt;?&gt;</code>类型的<code>test</code>独享是不能对其属性进行赋值的，也就是说下面的操作是不允许的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Test&lt;?&gt; test = <span class="keyword">new</span> Test&lt;String&gt;();</span></pre></td></tr><tr><td class="code"><pre><span class="line">test.t=<span class="string">"123"</span>;<span class="comment">//Incompatible types. Found: 'java.lang.String', required: 'capture&lt;?&gt;'</span></span></pre></td></tr></table></figure>

<p>虽然我们创建了一个泛型类型为 String 的对象，但是不能对其赋值。可以看出<code>Test&lt;?&gt;</code>只是用于声明变量的时候用，你不能用它来实例化，尤其是用于当你不知道声明的泛型类型的时候。</p>
<h4 id="上界通配符-lt-extends-T-gt"><a href="#上界通配符-lt-extends-T-gt" class="headerlink" title="上界通配符&lt;? extends T&gt;"></a>上界通配符&lt;? extends T&gt;</h4><p>使用固定上边界的通配符的泛型，就能够接受指定类及其子类类型的数据。要声明使用该类通配符，采用<code>&lt;? extends E&gt;</code>的形式，这里的 T 就是该泛型的上边界。注意：这里虽然用的是<code>extends</code>关键字，却不仅限于继承了父类 T 的子类，也可以代指显现了接口 T 的类。</p>
<p>举个栗子，我们定义两个类，水果和苹果，水果是苹果的父类。然后定义一个泛型类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fruit</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple</span> <span class="keyword">extends</span> <span class="title">Fruit</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>测试一下上界通配符可以发现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Test&lt;Fruit&gt; fruit = <span class="keyword">new</span> Test&lt;&gt;();</span></pre></td></tr><tr><td class="code"><pre><span class="line">Test&lt;Apple&gt; apple = <span class="keyword">new</span> Test&lt;&gt;();</span></pre></td></tr><tr><td class="code"><pre><span class="line">Test&lt;Object&gt; object = <span class="keyword">new</span> Test&lt;&gt;();</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">Test&lt;? extends Fruit&gt;  newTest;</span></pre></td></tr><tr><td class="code"><pre><span class="line">newTest=fruit;<span class="comment">//可以</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">newTest=apple;<span class="comment">//可以</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">newTest=object;<span class="comment">//ide报错</span></span></pre></td></tr></table></figure>



<h4 id="下界通配符-lt-extends-T-gt"><a href="#下界通配符-lt-extends-T-gt" class="headerlink" title="下界通配符&lt;? extends T&gt;"></a>下界通配符&lt;? extends T&gt;</h4><p>跟上界通配符是相对应的，只接受指定类及其父类，很好理解。直接看栗子，还是用苹果和水果举例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Test&lt;Fruit&gt; fruit = <span class="keyword">new</span> Test&lt;&gt;();</span></pre></td></tr><tr><td class="code"><pre><span class="line">Test&lt;Apple&gt; apple = <span class="keyword">new</span> Test&lt;&gt;();</span></pre></td></tr><tr><td class="code"><pre><span class="line">Test&lt;Object&gt; object = <span class="keyword">new</span> Test&lt;&gt;();</span></pre></td></tr><tr><td class="code"><pre><span class="line">Test&lt;String&gt; string = <span class="keyword">new</span> Test&lt;&gt;();</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">Test&lt;? extends Fruit&gt;  newTest;</span></pre></td></tr><tr><td class="code"><pre><span class="line">newTest=fruit;<span class="comment">//可以</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">newTest=apple;<span class="comment">//可以</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">newTest=object;<span class="comment">//可以</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">newTest=string;<span class="comment">//ide报错</span></span></pre></td></tr></table></figure>

<p>跟上面有一点点不同的是，由于<code>Object</code>是所有类的父类，所以也可以。</p>
<p>另外跟上界通配符不同的是，下界通配符<code>&lt;? super T&gt;</code>不影响往里面存储，但是读取出来的数据只能是 Object 类型。</p>
<p>原因是，下界通配符规定了元素最小的粒度，必须是 T 及其基类，那么我往里面存储 T 及其派生类都是可以的，因为它都可以隐式的转化为 T 类型。但是往外读就不好控制了，里面存储的都是 T 及其基类，无法转型为任何一种类型，只有 Object 基类才能装下。</p>
<p>最后简单介绍下 Effective Java 这本书里面介绍的 PECS 原则。</p>
<ul>
<li>上界<code>&lt;? extends T&gt;</code>不能往里存，只能往外取，适合频繁往外面读取内容的场景。</li>
<li>下界<code>&lt;? super T&gt;</code>不影响往里存，但往外取只能放在<code>Object</code>对象里，适合经常往里面插入数据的场景。</li>
</ul>
<h3 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h3><p>类结构是面向对象中最基本的元素，如果我们的类需要有很好的扩展性，那么我们可以将其设置成泛型的。</p>
<p>泛型类定义时只需要在类名后面加上类型参数即可，当然你也可以添加多个参数，类似于<code>&lt;K,V&gt;</code>,<code>&lt;T,E,K&gt;</code>等。这样我们就可以在类里面使用定义的类型参数。当然需要注意，泛型的类型参数只能是 Object 类（包括自定义类），不能是基本类型。</p>
<h3 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h3><p>泛型接口与泛型类的定义及使用基本相同。泛型接口常被用在各种类的生产器中，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义一个泛型接口</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Generator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">next</span><span class="params">()</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>当实现泛型接口的类，未传入泛型实参时，需将泛型的声明也一起加到类中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * 未传入泛型实参时，与泛型类的定义相同，在声明类的时候，需将泛型的声明也一起加到类中</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * 即：class FruitGenerator&lt;T&gt; implements Generator&lt;T&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * 如果不声明泛型，如：class FruitGenerator implements Generator&lt;T&gt;，编译器会报错："Unknown class"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FruitGenerator</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Generator</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">next</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>在实现类实现泛型接口时，如已将泛型类型传入实参类型，则所有使用泛型的地方都要替换成传入的实参类型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * 传入泛型实参时：</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * 在实现类实现泛型接口时，如已将泛型类型传入实参类型，则所有使用泛型的地方都要替换成传入的实参类型</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * 即：Generator&lt;T&gt;，public T next();中的的T都要替换成传入的String类型。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FruitGenerator</span> <span class="keyword">implements</span> <span class="title">Generator</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">next</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="string">"Fruit"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>



<h3 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h3><p>在java中,泛型类的定义非常简单，但是泛型方法就比较复杂了。</p>
<p>泛型类，是在实例化类的时候指明泛型的具体类型；泛型方法，是在调用方法的时候指明泛型的具体类型。</p>
<p>需要注意的是：</p>
<ul>
<li><code>public</code>与返回值中间<code>&lt;T&gt;</code>非常重要，可以理解为声明此方法为泛型方法。</li>
<li>只有声明了<code>&lt;T&gt;</code>的方法才是泛型方法，泛型类中的使用了泛型的成员方法并不是泛型方法。</li>
<li><code>&lt;T&gt;</code>表明该方法将使用泛型类型 T，此时才可以在方法中使用泛型类型 T。</li>
<li>与泛型类的定义一样，此处 T 可以随便写为任意标识，常见的如 T、E、K、V 等形式的参数常用于表示泛型。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * 泛型方法的基本介绍</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * <span class="doctag">@param</span> tClass 传入的泛型实参</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * <span class="doctag">@return</span> T 返回值为T类型</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">genericMethod</span><span class="params">(Class&lt;T&gt; tClass)</span><span class="keyword">throws</span> InstantiationException ,</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">  IllegalAccessException</span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        T instance = tClass.newInstance();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> instance;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>



<h4 id="泛型类中的泛型方法"><a href="#泛型类中的泛型方法" class="headerlink" title="泛型类中的泛型方法"></a>泛型类中的泛型方法</h4><p>如果在泛型类中声明了一个泛型方法，使用泛型 E，这种泛型 E 可以为任意类型。可以类型与 T 相同，也可以不同，比如一个最刁钻的情况：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &lt;E&gt; <span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">(T t)</span> </span>&#123;<span class="comment">//这里传入的参数 t 跟类的泛型保持一致。所以这里的 E 是没有意义的，idea 会提示可以直接删掉。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">(T t)</span> </span>&#123;<span class="comment">//这里的两个泛型 T 都是新的泛型，和类的泛型 T 没有关系。这么写的话很容易引起误会，所以 idea 也会提示建议重命名。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &lt;E&gt; <span class="function"><span class="keyword">void</span> <span class="title">func3</span><span class="params">(E t)</span> </span>&#123;<span class="comment">//这个很清晰，E 和 T 是无关的泛型。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>



<h4 id="静态方法与泛型"><a href="#静态方法与泛型" class="headerlink" title="静态方法与泛型"></a>静态方法与泛型</h4><p>静态方法有一种情况需要注意一下，那就是在类中的静态方法使用泛型：静态方法无法访问类上定义的泛型，如果静态方法操作的引用数据类型不确定的时候，必须要将泛型定义在方法上。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     * 如果在类中定义使用泛型的静态方法，需要添加额外的泛型声明（将这个方法定义成泛型方法）</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     * 即使静态方法要使用泛型类中已经声明过的泛型也不可以。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     * 如：public static void show(T t)&#123;..&#125;,此时编译器会提示错误信息：</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">          "StaticGenerator cannot be refrenced from static context"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">(T t)</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>



<h3 id="泛型擦除"><a href="#泛型擦除" class="headerlink" title="泛型擦除"></a>泛型擦除</h3><p>泛型擦除，或者叫泛型的类型擦除，出现的根本原因是为了保证兼容性。</p>
<p>泛型是 Java 1.5 版本才引进的概念，在这之前是没有泛型的概念的，但显然，泛型代码能够很好地和之前版本的代码很好地兼容。这是因为，泛型信息只存在于代码编译阶段，在进入 JVM 之前，与泛型相关的信息会被擦除掉，专业术语叫做类型擦除。</p>
<p>在泛型类被类型擦除的时候，之前泛型类中的类型参数部分如果没有指定上限，如<code>&lt;T&gt;</code>则会被转译成普通的 Object 类型，如果指定了上限如<code>&lt;T extends String&gt;</code>则类型参数就被替换成类型上限。</p>
<p>如在代码中定义的<code>List&lt;object&gt;</code>和<code>List&lt;String&gt;</code>等类型，在编译后都会编程<code>List</code>。JVM 看到的只是<code>List</code>，而由泛型附加的类型信息对 JVM 来说是不可见的。Java 编译器会在编译时尽可能的发现可能出错的地方，但是仍然无法避免在运行时刻出现类型转换异常的情况。类型擦除也是 Java 的泛型实现方法与 C++ 模版机制实现方式之间的重要区别。</p>
<h3 id="泛型数组"><a href="#泛型数组" class="headerlink" title="泛型数组"></a>泛型数组</h3><p>关于泛型数组，还要提醒一下，在java中是“不能创建一个确切的泛型类型的数组”的。</p>
<p>也就是说下面的这个例子是不可以的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt;[] ls = <span class="keyword">new</span> ArrayList&lt;String&gt;[<span class="number">10</span>];</span></pre></td></tr></table></figure>

<p>而使用通配符创建泛型数组是可以的，如下面这个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;?&gt;[] ls = <span class="keyword">new</span> ArrayList&lt;?&gt;[<span class="number">10</span>];</span></pre></td></tr></table></figure>

<p>这样也是可以的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt;[] ls = <span class="keyword">new</span> ArrayList[<span class="number">10</span>];</span></pre></td></tr></table></figure>



<h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><p>关于反射，基本的用法应该都熟悉了，可以通过全类名找到对应的类，然后实例化一个对象，还可以访问其变量，调用他的方法。甚至可以绕过<code>private</code>关键字的限制等等。</p>
<p>虽然有一点基础了解，但是一直不知道反射什么原理，为什么要设计这样一个功能。</p>
<p>首先我们先明确反射提供的功能：</p>
<ul>
<li>在运行时判断任意一个对象所属的类；</li>
<li>在运行时构造任意一个类的对象；</li>
<li>在运行时判断任意一个类所具有的成员变量和方法（通过反射甚至可以调用private方法）；</li>
<li>在运行时调用任意一个对象的方法。</li>
</ul>
<p>首先为什么需要有反射？我们看下动态编译与静态编译的概念：</p>
<ul>
<li>静态编译：在编译时确定类型，绑定对象。即通过<code>new</code>关键字实例化一个对象。</li>
<li>动态编译：运行时确定类型，绑定对象。动态编译最大限度发挥了java的灵活性，体现了多态的应用，有以降低类之间的藕合性。</li>
</ul>
<p>另外不妨用大家接触最早的一个反射用例作为例子。刚接触 JDBC 的时候可能就有疑问，为什么连接数据库一定要先注册驱动，也就是用<code>Class.forName(驱动类)</code>来加载驱动类？</p>
<p>这里的原因就是包括：</p>
<ul>
<li>解耦：所有不同数据库的驱动类都是 JDK 提供的通用接口<code>NonRegisteringDriver</code>的实现，使用反射可以方便解耦，后需更换数据库驱动不需要修改代码，改个配置文件就行了。另外这里也是桥接模式的一个体现。</li>
<li>节省资源：我们加载驱动其实只是需要执行其静态代码块里的初始化代码，其他的都不会马上用到，所以更节省资源。</li>
</ul>
<p>另外，其实用<code>new com.mysql.jdbc.Driver();</code>的方式加载驱动，也不是不可以，只不过不是最优选择。</p>
<p>另外，使用代理的优缺点也很明显：</p>
<ul>
<li>优点<br>可以实现动态创建对象和编译，体现出很大的灵活性。采用静态的话，需要把整个程序重新编译一次才可以实现功能的更新，而采用反射机制的话，它就可以不用卸载，只需要在运行时才动态的创建和编译，就可以实现该功能。</li>
<li>缺点<br>对性能有影响。使用反射基本上是一种解释操作，我们可以告诉 JVM，我们希望做什么并且它满足我们的要求。这类操作总是慢于只直接执行相同的操作。</li>
</ul>
<h3 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h3><p>关于反射主要的用途，有一个知乎回答说得很好：</p>
<blockquote>
<p>比如你在开发一个 xxfreamwork，后续要初始化并管理其他开发者创建的类 Y y 的对象。你肯定不会在 freamwork 开发阶段就知道将来大家定义的类名，这时候可以把类名做参数初始化对象。</p>
</blockquote>
<p>像 Spring Framework 就是大量用到了反射，之前用 xml 配置 bean，Spring 框架就是通过反射来创建一个 bean 的实例，然后放到池子里进行管理。这时候就不能用 new 关键字来创建了，以为你根本不知道对方会有哪些类。</p>
<p>除此之外，下面我们要说的动态代理也是另外一大重要用途，这个在下面详细说。</p>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>对于最简单的一次反射使用样例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class actionClass=Class.forName(<span class="string">"MyClass"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">Object action=actionClass.newInstance();</span></pre></td></tr><tr><td class="code"><pre><span class="line">Method method = actionClass.getMethod(<span class="string">"myMethod"</span>,<span class="keyword">null</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">method.invoke(action,<span class="keyword">null</span>);</span></pre></td></tr></table></figure>

<p>前两行实现了类的加载、链接和初始化（<code>newInstance</code>方法实际上也是使用反射调用了<code>&lt;init&gt;</code>方法），后两行实现了从 class 对象中获取到 method 对象然后执行反射调用。</p>
<p>从上面的代码可以看出，如果我们自己想要实现<code>invoke</code>方法，其实只要实现这样一个 Method 类即可：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class Method&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">     <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object obj,Object[] param)</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        MyClass myClass=(MyClass)obj;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> myClass.myMethod();</span></pre></td></tr><tr><td class="code"><pre><span class="line">     &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>看起来很简单吧，那么实际上 JVM 是怎么做的呐？</p>
<p>首先来看一下Method对象是如何生成的：</p>
<p><img src="http://nas.beritra.com:18081/blog/202005/D17809940E1D4099BD319D343A262BDB.png" alt=""></p>
<p>上面的 Class 对象是在加载类时由 JVM 构造的，JVM 为每个类管理一个独一无二的 Class 对象，这份 Class 对象里维护着该类的所有 Method，Field，Constructor 的 cache，这份 cache 也可以被称作根对象。每次<code>getMethod</code>获取到的 Method 对象都持有对根对象的引用，因为一些重量级的 Method 的成员变量（主要是 MethodAccessor ），我们不希望每次创建 Method 对象都要重新初始化，于是所有代表同一个方法的 Method 对象都共享着根对象的 MethodAccessor，每一次创建都会调用根对象的 copy 方法复制一份。</p>
<p>获取到Method对象之后，调用invoke方法的流程如下：</p>
<p><img src="http://nas.beritra.com:18081/blog/202005/6828367BCC244C008F124B2A086B5B66.png" alt="img"></p>
<p>可以看到，调用<code>Method.invoke</code>之后，会直接去调<code>MethodAccessor.invoke</code>。MethodAccessor 就是上面提到的所有同名 method 共享的一个实例，由<code>ReflectionFactory</code>创建。创建机制采用了一种名为 inflation 的方式（JDK 1.4 之后）：如果该方法的累计调用次数&lt;=15，会创建出<code>NativeMethodAccessorImpl</code>，它的实现就是直接调用 native 方法实现反射；如果该方法的累计调用次数&gt;15，会由 Java 代码创建出字节码组装而成的<code>MethodAccessorImpl</code>。（是否采用 inflation 和 15 这个数字都可以在 JVM 参数中调整）。</p>
<p>更加细致的过程R大有一篇博文：<a href="https://www.iteye.com/blog/rednaxelafx-548536" target="_blank" rel="noopener">关于反射调用方法的一个log</a></p>
<h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><p>说道动态代理，就必须得回顾下代理模式这种设计模式了：</p>
<blockquote>
<p>代理模式：给某一个对象提供一个代理，并由代理对象来控制对真实对象的访问。代理模式是一种结构型设计模式。</p>
<p>代理模式角色分为 3 种：</p>
<p>Subject（抽象主题角色）：定义代理类和真实主题的公共对外方法，也是代理类代理真实主题的方法；</p>
<p>RealSubject（真实主题角色）：真正实现业务逻辑的类；</p>
<p>Proxy（代理主题角色）：用来代理和封装真实主题；</p>
<p>代理模式的结构比较简单，其核心是代理类，为了让客户端能够一致性地对待真实对象和代理对象，在代理模式中引入了抽象层。</p>
</blockquote>
<p>简单来说，代理模式就在真实的角色外面包装一层代理，可以在代理方法中执行真实的方法，还可以额外做一些逻辑判断和处理。</p>
<p>而动态代理，就是区别于静态代理的一种代理模式实现方式。二者根据字节码的创建时机来分类：</p>
<ul>
<li>所谓静态也就是在程序运行前就已经存在代理类的字节码文件，代理类和真实主题角色的关系在运行前就确定了。</li>
<li>而动态代理的源码是在程序运行期间由<strong>JVM</strong>根据反射等机制动态的生成，所以在运行前并不存在代理类的字节码文件。</li>
</ul>
<h3 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h3><p>我们先用更好理解的静态代理来了解一下代理的过程，然后理解静态代理的缺点，再来学习动态代理。</p>
<p>编写一个接口 UserService ，以及该接口的一个实现类 UserServiceImpl。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">select</span><span class="params">()</span></span>;   </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;  </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">select</span><span class="params">()</span> </span>&#123;  </span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.println(<span class="string">"查询 select 方法"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.println(<span class="string">"更新 update 方法"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>我们将通过静态代理对 UserServiceImpl 进行功能增强，在调用 <code>select</code> 和 <code>update</code> 之前记录一些日志。写一个代理类 UserServiceProxy，代理类需要实现 UserService：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceProxy</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> UserService target; <span class="comment">// 被代理的对象</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserServiceProxy</span><span class="params">(UserService target)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">this</span>.target = target;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">select</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        before();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        target.select();    <span class="comment">// 这里才实际调用真实主题角色的方法</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        after();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        before();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        target.update();    <span class="comment">// 这里才实际调用真实主题角色的方法</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        after();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;     <span class="comment">// 在执行方法之前执行</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.println(String.format(<span class="string">"log start time [%s] "</span>, <span class="keyword">new</span> Date()));</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span> </span>&#123;      <span class="comment">// 在执行方法之后执行</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.println(String.format(<span class="string">"log end time [%s] "</span>, <span class="keyword">new</span> Date()));</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>通过静态代理，我们达到了功能增强的目的，而且没有侵入原代码，这是静态代理的一个优点。</p>
<p>虽然静态代理实现简单，且不侵入原代码，但是，当场景稍微复杂一些的时候，静态代理的缺点也会暴露出来。</p>
<p>1、当需要代理多个类的时候，由于代理对象要实现与目标对象一致的接口，有两种方式：</p>
<ul>
<li>只维护一个代理类，由这个代理类实现多个接口，但是这样就导致代理类过于庞大；</li>
<li>新建多个代理类，每个目标对象对应一个代理类，但是这样会产生过多的代理类。</li>
</ul>
<p>2、 当接口需要增加、删除、修改方法的时候，目标对象与代理类都要同时修改，不易维护。</p>
<p>如何改进？就是使用动态代理。动态代理就是想办法，根据接口或目标对象，计算出代理类的字节码，然后再加载到 JVM 中使用。</p>
<h3 id="动态代理-1"><a href="#动态代理-1" class="headerlink" title="动态代理"></a>动态代理</h3><p>常见的字节码操作类库有如下几种：</p>
<blockquote>
<p>这里有一些介绍：<a href="https://java-source.net/open-source/bytecode-libraries" target="_blank" rel="noopener">java-source.net/open-source…</a></p>
</blockquote>
<ul>
<li>Apache BCEL (Byte Code Engineering Library)：是 Java classworking 广泛使用的一种框架，它可以深入到 JVM 汇编语言进行类操作的细节。</li>
<li>ObjectWeb ASM：是一个Java字节码操作框架。它可以用于直接以二进制形式动态生成 stub 根类或其他代理类，或者在加载时动态修改类。</li>
<li>CGLib(Code Generation Library)：是一个功能强大，高性能和高质量的代码生成库，用于扩展 JAVA 类并在运行时实现接口。</li>
<li>Javassist：是 Java 的加载时反射系统，它是一个用于在 Java 中编辑字节码的类库；它使 Java 程序能够在运行时定义新类，并在 JVM 加载之前修改类文件。</li>
<li>…</li>
</ul>
<p>为了让生成的代理类与目标对象（真实主题角色）保持一致性，实际使用中我们最常见的两种实现方式是：</p>
<ol>
<li>通过实现接口的方式 -&gt; JDK动态代理</li>
<li>通过继承类的方式 -&gt; CGLib动态代理</li>
</ol>
<h4 id="JDK-动态代理"><a href="#JDK-动态代理" class="headerlink" title="JDK 动态代理"></a>JDK 动态代理</h4><p>JDK 动态代理主要涉及两个类：<code>java.lang.reflect.Proxy</code> 和 <code>java.lang.reflect.InvocationHandler</code>。还是以上面的例子，我们用动态代理的方式实现对 UserService 的日志记录。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Object target;<span class="comment">//被代理的对象，实际的方法执行者。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LogProxy</span><span class="params">(Object target)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">this</span>.target = target;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 调用invoke方法之前执行</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.println(String.format(<span class="string">"log start time [%s] "</span>, <span class="keyword">new</span> Date()));</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 调用invoke方法之后执行</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.println(String.format(<span class="string">"log end time [%s] "</span>, <span class="keyword">new</span> Date()));</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        before();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Object result = method.invoke(target, args);  <span class="comment">// 调用 target 的 method 方法</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        after();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> result;  <span class="comment">// 返回方法的执行结果</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>这个就是日志记录代理类了，他的内部变量 target 是实际执行方法的对象，我们在执行对象的前后添加了日志记录方法。不同于静态代理中直接调用对象的方法，基于 JDK 的动态代理是利用反射来执行相应的方法。</p>
<p>执行代理的步骤如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">      <span class="comment">// 1. 创建被代理的对象，UserService接口的实现类</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">     UserServiceImpl userServiceImpl = <span class="keyword">new</span> UserServiceImpl();</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">     <span class="comment">// 2. 获取对应的 ClassLoader</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">     ClassLoader classLoader = userServiceImpl.getClass().getClassLoader();</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">     <span class="comment">// 3. 获取所有接口的Class，这里的UserServiceImpl只实现了一个接口UserService，</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">     Class&lt;?&gt;[] interfaces = userServiceImpl.getClass().getInterfaces();</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">     <span class="comment">// 4. 创建一个将传给代理类的调用请求处理器，处理所有的代理对象上的方法调用。这里创建的是一个自定义的日志处理器，须传入实际的执行对象 userServiceImpl</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">     InvocationHandler logHandler = <span class="keyword">new</span> LogProxy(userServiceImpl);</span></pre></td></tr><tr><td class="code"><pre><span class="line">     <span class="comment">/*</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">  5.根据上面提供的信息，创建代理对象。在这个过程中：</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">            a.JDK会通过根据传入的参数信息动态地在内存中创建和.class 文件等同的字节码</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">            b.然后根据相应的字节码转换成对应的class，</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">            c.然后调用newInstance()创建代理实例</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">*/</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">     UserService proxy = (UserService) Proxy.newProxyInstance(classLoader, interfaces, logHandler);</span></pre></td></tr><tr><td class="code"><pre><span class="line">     <span class="comment">// 调用代理的方法</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">     proxy.select();</span></pre></td></tr><tr><td class="code"><pre><span class="line">     proxy.update();</span></pre></td></tr></table></figure>

<p>JDK 动态代理最主要的几个方法如下：</p>
<blockquote>
<p><strong>java.lang.reflect.InvocationHandler</strong></p>
<p><code>Object invoke(Object proxy, Method method, Object[] args)</code> 定义了代理对象调用方法时希望执行的动作，用于集中处理在动态代理类对象上的方法调用</p>
<p><strong>java.lang.reflect.Proxy</strong></p>
<p><code>static InvocationHandler getInvocationHandler(Object proxy)</code>  用于获取指定代理对象所关联的调用处理器</p>
<p><code>static Class getProxyClass(ClassLoader loader, Class... interfaces)</code> 返回指定接口的代理类</p>
<p><code>static Object newProxyInstance(ClassLoader loader, Class[] interfaces, InvocationHandler h)</code> 构造实现指定接口的代理类的一个新实例，所有方法会调用给定处理器对象的 invoke 方法</p>
<p><code>static boolean isProxyClass(Class cl)</code> 返回 cl 是否为一个代理类</p>
</blockquote>
<p>在<code>newProxyInstance</code>中顺着代码可以看到整个动态代理的流程，简单来说就是对参数进行校验，然后生成一个代理类的字节码文件，如果你修改 jvm 参数<code>jdk.proxy.ProxyGenerator.saveGeneratedFiles</code>为 true 的话，还可以保存生成的字节码文件。</p>
<p>打印字节码文件我们可以看到生成的文件结构：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> $<span class="title">Proxy0</span> <span class="keyword">extends</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">static</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            m1 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"equals"</span>, Class.forName(<span class="string">"java.lang.Object"</span>));</span></pre></td></tr><tr><td class="code"><pre><span class="line">            m2 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"toString"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            m4 = Class.forName(<span class="string">"com.beritra.jdk.proxy.UserService"</span>).getMethod(<span class="string">"select"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            m0 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"hashCode"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            m3 = Class.forName(<span class="string">"com.beritra.jdk.proxy.UserService"</span>).getMethod(<span class="string">"update"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException var2) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchMethodError(var2.getMessage());</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException var3) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoClassDefFoundError(var3.getMessage());</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> <span class="keyword">throws</span>  </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m3, (Object[])<span class="keyword">null</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">throw</span> var2;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var3);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">select</span><span class="params">()</span> <span class="keyword">throws</span>  </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m4, (Object[])<span class="keyword">null</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">throw</span> var2;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var3);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//其他部分没贴</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>从这个生成的代理的代码中我们可以发现：</p>
<ul>
<li>继承了 Proxy 类，并且实现了被代理的所有接口，以及 equals、hashCode、toString 等方法</li>
<li>由于继承了 Proxy 类，所以每个代理类都会关联一个 InvocationHandler 方法调用处理器</li>
<li>类和所有方法都被 <code>public final</code> 修饰，所以代理类只可被使用，不可以再被继承</li>
<li>每个方法都有一个 Method 对象来描述，Method 对象在static静态代码块中创建，以 <code>m + 数字</code> 的格式命名</li>
<li>调用方法的时候通过 <code>super.h.invoke(this, m4, (Object[])null);</code> 调用，其中的 <code>super.h.invoke</code> 实际上是在创建代理的时候传递给 <code>Proxy.newProxyInstance</code> 的 LogHandler 对象，它继承 InvocationHandler 类，负责实际的调用处理逻辑。</li>
<li>而 LogHandler 的 invoke 方法接收到 method、args 等参数后，进行一些处理，然后通过反射让被代理的对象 target 执行方法</li>
</ul>
<p>流程如下：</p>
<p><img src="http://nas.beritra.com:18081/blog/202005/22c9b11092b511ea971c00d861792df0.png" alt="img"></p>
<h4 id="CGLib-动态代理"><a href="#CGLib-动态代理" class="headerlink" title="CGLib 动态代理"></a>CGLib 动态代理</h4><p>在 maven 依赖中加入 CGLib 的库：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/CGLib/CGLib --&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>CGLib<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>CGLib<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></pre></td></tr></table></figure>

<p>如果我们用 CGLib 的方式实现动态代理，代码更简单一点。还是跟上面 JDK 动态代理类似的例子，我们复用上面的 UserService 和 UserServiceImpl 两个类，但是重新写代理：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogInterceptor</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     * <span class="doctag">@param</span> object      表示要进行增强的对象</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     * <span class="doctag">@param</span> method      表示拦截的方法</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     * <span class="doctag">@param</span> objects     数组表示参数列表，基本数据类型需要传入其包装类型，如int--&gt;Integer、long-Long、double--&gt;Double</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     * <span class="doctag">@param</span> methodProxy 表示对方法的代理，invokeSuper方法表示对被代理对象方法的调用</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     * <span class="doctag">@return</span> 执行结果</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Throwable</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object object, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        before();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Object result = methodProxy.invokeSuper(object, objects);   <span class="comment">// 注意这里是调用 invokeSuper 而不是 invoke，否则死循环，methodProxy.invokesuper执行的是原始类的方法，method.invoke执行的是子类的方法</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        after();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> result;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.println(String.format(<span class="string">"log start time [%s] "</span>, <span class="keyword">new</span> Date()));</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.println(String.format(<span class="string">"log end time [%s] "</span>, <span class="keyword">new</span> Date()));</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>然后调用的时候：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LogInterceptor logInterceptor= <span class="keyword">new</span> LogInterceptor();</span></pre></td></tr><tr><td class="code"><pre><span class="line">Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span></pre></td></tr><tr><td class="code"><pre><span class="line">enhancer.setSuperclass(UserServiceImpl<span class="class">.<span class="keyword">class</span>)</span>;  <span class="comment">// 设置超类，CGLib是通过继承来实现的</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">enhancer.setCallback(logInterceptor);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">UserService service = (UserService) enhancer.create();   <span class="comment">// 创建代理类</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">service.update();</span></pre></td></tr><tr><td class="code"><pre><span class="line">service.select();</span></pre></td></tr></table></figure>

<p>执行代码实现了类似的效果。CGLib 还提供了更多的功能，比如我们实现 CallbackFilter 接口的话，可以执行回调。</p>
<p>CGLib 创建动态代理类的模式是：</p>
<ol>
<li>查找目标类上的所有非 final 的 public 类型的方法定义；</li>
<li>将这些方法的定义转换成字节码；</li>
<li>将组成的字节码转换成相应的代理的 class 对象；</li>
<li>实现 MethodInterceptor 接口，用来处理对代理类上所有方法的请求。</li>
</ol>
<h4 id="JDK-动态代理与-CGLib-动态代理对比"><a href="#JDK-动态代理与-CGLib-动态代理对比" class="headerlink" title="JDK 动态代理与 CGLib 动态代理对比"></a>JDK 动态代理与 CGLib 动态代理对比</h4><p>JDK 动态代理：基于 Java 反射机制实现，必须要实现了接口的业务类才能用这种办法生成代理对象。</p>
<p>CGLib 动态代理：基于 ASM 机制实现，通过生成业务类的子类作为代理类，所以代理的类不能是 final 修饰的。</p>
<p>JDK Proxy 的优势：</p>
<ul>
<li>最小化依赖关系，减少依赖意味着简化开发和维护，JDK 本身的支持，可能比 CGLib 更加可靠。</li>
<li>平滑进行 JDK 版本升级，而字节码类库通常需要进行更新以保证在新版 Java 上能够使用。</li>
<li>代码实现简单。</li>
</ul>
<p>基于类似 CGLib 框架的优势：</p>
<ul>
<li>无需实现接口，达到代理类无侵入。</li>
<li>只操作我们关心的类，而不必为其他相关类增加工作量。</li>
<li>高性能。</li>
</ul>
<p>Java 动态代理适合于那些有接口抽象的类代理，而 CGLib 则适合那些没有接口抽象的类代理。</p>
<p>关于二者的效率区别，有一条博客这么说：</p>
<blockquote>
<p>1、CGLib 底层采用 ASM 字节码生成框架，使用字节码技术生成代理类，在 jdk6 之前比使用 Java 反射效率要高。唯一需要注意的是，CGLib 不能对声明为 final 的方法进行代理，因为 CGLib 原理是动态生成被代理类的子类。</p>
<p>2、在 jdk6、jdk7、jdk8 逐步对 JDK 动态代理优化之后，在调用次数较少的情况下，JDK 代理效率高于 CGLib 代理效率，只有当进行大量调用的时候，jdk6 和 jdk7 比 CGLib 代理效率低一点，但是到 jdk8 的时候，jdk 代理效率高于 CGLib 代理。</p>
</blockquote>
<p><strong>Spring 框架怎么对二者进行选择的？</strong></p>
<ol>
<li><p>当 Bean 实现接口时，Spring 就会用 JDK 的动态代理。</p>
</li>
<li><p>当 Bean 没有实现接口时，Spring 使用 CGlib 实现。</p>
</li>
<li><p>可以强制使用 CGlib（在 spring 配置中加入<code>&lt;aop:aspectj-autoproxy proxy-target-class=&quot;true&quot;/&gt;</code>）。</p>
</li>
</ol>
<h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><p>注解（Annotation）在 JDK 1.5 之后增加的一个新特性，注解的引入意义很大，有很多非常有名的框架，比如 Hibernate、Spring 等框架中都大量使用注解。注解对于开发人员来讲既熟悉又陌生，熟悉是因为只要你是做开发，都会用到注解（常见的@Override）。陌生是因为即使不使用注解也照常能够进行开发，注解不是必须的。</p>
<h3 id="本质"><a href="#本质" class="headerlink" title="本质"></a>本质</h3><p><code>Java.lang.annotation.Annotation</code>接口中有这么一句话，用来描述注解。</p>
<blockquote>
<p>The common interface extended by all annotation types</p>
<p>所有的注解类型都继承自这个普通的接口（Annotation）</p>
</blockquote>
<p>这句话有点抽象，但却说出了注解的本质。我们看一个 JDK 内置注解的定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.SOURCE)</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Override &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>其实这个注解的本质就是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Override</span> <span class="keyword">extends</span> <span class="title">Annotation</span></span>&#123;  </span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>只不过是继承了<code>Annotation</code>接口的接口。如果想验证，你可以去反编译任意一个注解类，就会得到相同的结论。</p>
<p>所以注解说白了就是一个标签，甚至是一种特殊的注释，他本身不起作用，没有功能，需要额外的工具进行解析，实现它的功能。</p>
<p>解析一个类或者方法的注解往往有两种形式，一种是编译期直接的扫描，一种是运行期反射。反射的方式后面详细叙述，而编译器的扫描指的是编译器在对 Java 代码编译字节码的过程中，会检测到某个类或者方法被一些注解修饰，这时它就会对于这些注解进行某些处理。</p>
<p>典型的就是注解 @Override，一旦编译器检测到某个方法被修饰了 @Override 注解，编译器就会检查当前方法的方法签名是否真正重写了父类的某个方法，也就是比较父类中是否具有一个同样的方法签名。</p>
<p>这一种情况只适用于那些编译器已经熟知的注解类，比如 JDK 内置的几个注解，而你自定义的注解，编译器是不知道你这个注解的作用的，当然也不知道该如何处理，往往只是会根据该注解的作用范围来选择是否编译进字节码文件，仅此而已。</p>
<h3 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h3><p>什么东西只要一带上“元”就瞬间高大上了起来，类似“元数据”的意思是用来描述数据的数据。“元注解”就是用来修饰注解的注解，通常用在注解的定义上。</p>
<p>还是看 @Override 的定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.SOURCE)</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Override &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>其中的 @Target，@Retention 两个注解就是元注解。</p>
<p>JAVA 中有以下几个元注解：</p>
<ul>
<li>@Target：注解的作用目标</li>
<li>@Retention：注解的生命周期</li>
<li>@Documented：注解是否应当被包含在 JavaDoc 文档中</li>
<li>@Inherited：是否允许子类继承该注解</li>
</ul>
<p>@Target 用于指明被修饰的注解最终可以作用的目标是谁，也就是指明，你的注解到底是用来修饰方法的？修饰类的？还是用来修饰字段属性的。一共有以下几个属性：</p>
<p>被这个 @Target 注解修饰的注解将只能作用在成员字段上，不能用于修饰方法或者类。他的值 ElementType 是一个枚举类型，有以下一些值：</p>
<ul>
<li>ElementType.TYPE：允许被修饰的注解作用在类、接口和枚举上</li>
<li>ElementType.FIELD：允许作用在属性字段上</li>
<li>ElementType.METHOD：允许作用在方法上</li>
<li>ElementType.PARAMETER：允许作用在方法参数上</li>
<li>ElementType.CONSTRUCTOR：允许作用在构造器上</li>
<li>ElementType.LOCAL_VARIABLE：允许作用在本地局部变量上</li>
<li>ElementType.ANNOTATION_TYPE：允许作用在注解上</li>
<li>ElementType.PACKAGE：允许作用在包上</li>
</ul>
<p>@Retention 用于指明当前注解的生命周期，他的值 RetentionPolicy 也是枚举类型，包括以下几种：</p>
<ul>
<li>RetentionPolicy.SOURCE：当前注解编译期可见，不会写入 class 文件</li>
<li>RetentionPolicy.CLASS：类加载阶段丢弃，会写入 class 文件</li>
<li>RetentionPolicy.RUNTIME：永久保存，可以反射获取</li>
</ul>
<p>剩下两种类型的注解我们很少用，也比较简单。</p>
<p>@Documented 注解修饰的注解，当我们执行 JavaDoc 文档打包时会被保存进 doc 文档，反之将在打包时丢弃。</p>
<p>@Inherited 注解修饰的注解是具有可继承性的，也就说我们的注解修饰了一个类，而该类的子类将自动继承父类的该注解。</p>
<h3 id="写一个注解"><a href="#写一个注解" class="headerlink" title="写一个注解"></a>写一个注解</h3><p>现在我们尝试自己写一个注解，以一个最简单的为例，假设我们写的注解叫<code>PrintMethods</code>，作用在类上，作用就是打印这个类所有的方法。然后仿照官方的注解定义该注解如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> PrintMethods &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>然后找一个测试类加上注解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PrintMethods</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotationTest</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        AnnotationTest main = <span class="keyword">new</span> AnnotationTest();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        main.print();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.println(<span class="string">"print"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>执行一下，看看发生了什么。</p>
<p>答案是什么都没发生。之前说过了，注解就像一个标签，本身没什么功能。我们需要手动扫描注解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class&lt;?&gt; clazz = AnnotationTest<span class="class">.<span class="keyword">class</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">Annotation annotation = clazz.getAnnotation(PrintMethods<span class="class">.<span class="keyword">class</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (annotation != <span class="keyword">null</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (Method method : clazz.getDeclaredMethods()) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.println(method.getName());</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125; <span class="keyword">else</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    System.out.println(<span class="string">"No Annotation"</span>);</span></pre></td></tr></table></figure>

<p>执行这段代码，就会发现<code>AnnotationTest</code>这个类中的注解被顺利的打印了出来，包括<code>main</code>和<code>print</code>两个方法。</p>
<p>其实在框架中也是这样的，比如 SpringBoot 的<code>@Componen</code>注解，把一个类标注为 bean，让 Spring 去管理，原理就是我们先通过<code>@ComponentScan</code>注解指定了包，然后 Spring 去吧所有包下面的类都扫描一遍，然后找到带有<code>@Componen</code>注解的，然后进行后续处理。</p>
<p>参考文章：</p>
<p><a href="https://blog.csdn.net/s10461/article/details/53941091" target="_blank" rel="noopener">Java 泛型详解-绝对是对泛型方法讲解最详细的，没有之一</a></p>
<p><a href="https://blog.csdn.net/LonelyRoamer/article/details/7868820" target="_blank" rel="noopener">java泛型（二）、泛型的内部原理：类型擦除以及类型擦除带来的问题</a></p>
<p><a href="http://tengj.top/2016/04/28/javareflect/" target="_blank" rel="noopener">Java基础与提高干货系列——Java反射机制</a></p>
<p><a href="[http://www.fanyilun.me/2015/10/29/Java%E5%8F%8D%E5%B0%84%E5%8E%9F%E7%90%86/](http://www.fanyilun.me/2015/10/29/Java反射原理/)">Java反射原理简析</a></p>
<p><a href="https://juejin.im/post/5c1ca8df6fb9a049b347f55c" target="_blank" rel="noopener">Java 动态代理详解</a></p>
<p><a href="https://juejin.im/post/5b45bd715188251b3a1db54f" target="_blank" rel="noopener">JAVA 注解的基本原理</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Minio+Nginx搭建图床一键上传博客图片</title>
    <url>/2020/05/10/Minio-Nginx%E6%90%AD%E5%BB%BA%E5%9B%BE%E5%BA%8A%E4%B8%80%E9%94%AE%E4%B8%8A%E4%BC%A0%E5%8D%9A%E5%AE%A2%E5%9B%BE%E7%89%87/</url>
    <content><![CDATA[<p>本方案要求：有一台有公网 IP 的服务器，可以是云服务器或者有公网 IP 的家庭网络。</p>
<p>如果事先了解 Docker、Nginx 等可能会更方便。</p>
<a id="more"></a>

<h2 id="前因"><a href="#前因" class="headerlink" title="前因"></a>前因</h2><p>写博客的时候一大痛点就是图片的处理，MarkDown 格式好用是好用，但是没办法直接附带图片信息，只能放一个链接，图片存在本地的话发给别人的文档里图就没了，存在网上就涉及图床的选择问题，又是另一个麻烦事。大家分享出来的解决方案也是五花八门，有用公有云块存储的，有用收费图床的，前些年还有用微博当图床的，现在微博禁止外链了该方案也不行了，还有其他奇技淫巧比如放到 GitHub 上。</p>
<p>作为不折腾会死星人+对广大乱七八糟免费服务抱着怀疑心态，我决定还是自己搭建，牺牲一点点稳定性和易用性（其实故障率也没多高）。自己的宽带是北京联通，恰好有公网 IP，只不过不是固定的，之前找了个 ddns 的脚本自己更新 IP 倒也没多大问题。</p>
<p>开始我使用的方案是用的一个叫 Lychee 的图床，功能简单，用起来感觉还行，就是跟写博客的流程不能很好的配合，往往插入图片的时候步骤是这样的：</p>
<ul>
<li>准备好图片，剪切板上的话先保存到本地，网络图片粘贴一下url</li>
<li>打开 Lychee，选择相应的方式上传</li>
<li>上传完毕之后点开图片，右键选择图片地址</li>
<li>把地址粘回 Typora 想要插入图片的位置</li>
</ul>
<p>可以看出来这个流程太蛋疼了，插入一张图片就得十几秒，这一点都不 geek。</p>
<p>针对这个问题，Typora 最近更新了个功能，就是检测到插入图片之后会自动上传到指定的位置，可以是几种内置的服务，也可以自己写脚本。这种方式大大减少了插入图片的工作量，无论是剪切板上的图，还是网图，你只要粘贴到 Typora 上，就可以自动上传到图床，然后把图床中的链接替换掉开始的链接。这个功能的详细介绍可以去官网查看，或者看其他博主的介绍。下面分享下我用 Minio+Python 脚本实现的整个流程。</p>
<h2 id="Minio"><a href="#Minio" class="headerlink" title="Minio"></a>Minio</h2><p>Minio 是亚马逊开源的一个文件存储系统，官方介绍这么说：</p>
<blockquote>
<p>MinIO 是一个基于Apache License v2.0开源协议的对象存储服务。它兼容亚马逊S3云存储服务接口，非常适合于存储大容量非结构化的数据，例如图片、视频、日志文件、备份数据和容器/虚拟机镜像等，而一个对象文件可以是任意大小，从几kb到最大5T不等。</p>
</blockquote>
<p>他的 API 非常简洁，而且如果你要求高的话，很方便做高可用，又提供了官方 Docker 镜像和一个简单的管理界面，所以我选择了他作为图床。</p>
<p>废话少说，直接贴我的 Docker 命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run  -itd -p 9000:9000 --name minio -v ~/docker/minio/data:/data -v ~/docker/minio/config:/root/.minio   -e <span class="string">"MINIO_ACCESS_KEY=你的账号"</span> -e <span class="string">"MINIO_SECRET_KEY=你的密码"</span>  minio/minio server /data</span></pre></td></tr></table></figure>

<p>把里面 data 和 config 文件夹改成你想要存储数据和配置文件的文件夹，然后把账号密码填进去就行了。</p>
<p>如果想用 docker-compose 或者 k8s 启动，请参考官方文档，挺详细的而且竟然还有中文版。</p>
<p>启动之后，打开 9000 端口之后就可以看到自带的管理界面了。</p>
<p>Minio 的存储逻辑很简单，分成多个 bucket（桶），没个桶内部就是以文件夹为层级，而且所有文件是直接存储在文件系统上的，没有分成小文件块之类的，因此你可以直接复制到你的 data 文件夹内。</p>
<p>但是，你没办法直接用链接访问放在 Minio 中的文件，虽然它提供了分享等功能，但是提供的是一个下载链接，我们需要的是类似于图片预览，因此需要一个 Nginx 作为文件服务器。</p>
<h2 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h2><p>Nginx 就不用赘述了，我也是用 Docker 启动的，命令如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -itd --name image -p 8081:80 -v ~/docker/image/conf:/etc/nginx/conf.d -v ~/docker/minio/data:/data nginx</span></pre></td></tr></table></figure>

<p>可以看到，我把 Minio 的数据文件夹挂载进去了，挂载到了 Nginx 容器的<code>/data</code>目录。然后修改 Nginx 配置文件如下：</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="attribute">listen</span>       <span class="number">80</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="attribute">server_name</span>  localhost;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="attribute">charset</span> koi8-r;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="attribute">access_log</span>  /var/log/nginx/host.access.log  main;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="attribute">location</span><span class="regexp"> ^~</span> /blog/ &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="attribute">root</span>   /data/;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>这里，我是在 Minio 中创建了一个桶，名字叫 blog，它其实对应着 Minio 存储目录中的 blog文件夹。配置完 Nginx 之后，其实我如果想查看 Minio 中 blog 桶中的<code>/testpath/test.png</code>，只需要访问<code>http://localhost:8081/blog/testpath/test.png</code>就可以了。</p>
<p>于是只要我向 blog 这个桶中上传文件，文件就可以直接通过 Nginx 预览了。</p>
<h2 id="Typora-和-Python-脚本"><a href="#Typora-和-Python-脚本" class="headerlink" title="Typora 和 Python 脚本"></a>Typora 和 Python 脚本</h2><p>现在只需要准备一个脚本，让 Typora 能够向 Minio 上传文件就行了。选择 Python 是因为 Minio 官方提供了 API，而且我正好熟悉。</p>
<p>Typora 上传的规则是这样，它会让你填写你的命令，比如你填写<code>python upload.py</code>，它就会执行<code>python upload.py &quot;image1-path&quot; &quot;image2-path&quot;</code>等等把图片位置作为参数穿进去。然后约定好需要你传回来上传完毕后的每张图片位置，每张图片占一行。比如上面的例子，传了两张，它就会自动从后往前查两行，作为 URL 替换掉原本的图片链接。</p>
<p>于是我写了个脚本如下，写的比较糙，可以作为参考：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> uuid</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> minio <span class="keyword">import</span> Minio</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> minio.error <span class="keyword">import</span> ResponseError</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> warnings</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">warnings.filterwarnings(<span class="string">'ignore'</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">images = sys.argv[<span class="number">1</span>:]</span></pre></td></tr><tr><td class="code"><pre><span class="line">minioClient = Minio(<span class="string">"这里写你的Minio地址，格式为域名：端口，不带http://"</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    access_key=<span class="string">'你的Minio账号'</span>, secret_key=<span class="string">'你的Minio密码'</span>, secure=<span class="literal">False</span>)//secure为<span class="literal">True</span>的话第一项会填充为https://</span></pre></td></tr><tr><td class="code"><pre><span class="line">result = <span class="string">"Upload Success:\n"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">date = time.strftime(<span class="string">"%Y%m"</span>, time.localtime())</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">download</span><span class="params">(image_url)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    local_path = os.getcwd() + <span class="string">"/temp"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    r = requests.get(image_url, verify=<span class="literal">False</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">with</span> open(local_path, <span class="string">"wb"</span>) <span class="keyword">as</span> code:</span></pre></td></tr><tr><td class="code"><pre><span class="line">        code.write(r.content)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> local_path</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> image <span class="keyword">in</span> images:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> os.path.isfile(image):</span></pre></td></tr><tr><td class="code"><pre><span class="line">        file_type = os.path.splitext(image)[<span class="number">-1</span>]</span></pre></td></tr><tr><td class="code"><pre><span class="line">        new_file_name = str(uuid.uuid1()).replace(<span class="string">'-'</span>, <span class="string">''</span>) + file_type</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">elif</span> image.startswith(<span class="string">"https://"</span>) <span class="keyword">or</span> image.startswith(<span class="string">"http://"</span>)://处理网络图片</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> image.endswith(<span class="string">".png"</span>) <span class="keyword">or</span> image.endswith(<span class="string">".jpg"</span>) <span class="keyword">or</span> image.endswith(<span class="string">".jpeg"</span>) <span class="keyword">or</span> image.endswith(<span class="string">".gif"</span>):</span></pre></td></tr><tr><td class="code"><pre><span class="line">            url = image.split(<span class="string">"/"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> len(url) &gt; <span class="number">1</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">                image = download(image)//先把网图下载到本地了，然后在传到Minio</span></pre></td></tr><tr><td class="code"><pre><span class="line">                new_file_name = url[<span class="number">-1</span>]</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">else</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">                result = result + <span class="string">"error:parsing image error!"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">continue</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">else</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">            result = result + <span class="string">"error:parsing image error!"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">continue</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">else</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">        result = result + <span class="string">"error:parsing image error!"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">continue</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">try</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">        minioClient.fput_object(bucket_name=<span class="string">'blog'</span>, object_name=date + <span class="string">"/"</span> + new_file_name, file_path=image)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> image.endswith(<span class="string">"temp"</span>):</span></pre></td></tr><tr><td class="code"><pre><span class="line">            os.remove(image)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        result = result +<span class="string">"你的Nginx地址，比如http://yourdomain:8081"</span> + <span class="string">"/blog/"</span> + date + <span class="string">"/"</span> + new_file_name + <span class="string">"\n"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">except</span> ResponseError <span class="keyword">as</span> err:</span></pre></td></tr><tr><td class="code"><pre><span class="line">        result = result + <span class="string">"error:"</span> + err.message + <span class="string">"\n"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">print(result)</span></pre></td></tr></table></figure>

<p>我是把博客图片都放到了 blog 这个桶，然后按照月份创建文件夹，每个月的都放在同一个文件夹，文件名是用的 uuid。具体的逻辑想要修改的话自己改上面的脚本吧。</p>
<p>搞定之后在 Typora 里面填上脚本，然后点击测试，就可以看看结果了，测试通过就万事大吉了，写个博客插入图片看看吧！</p>
<p><img src="http://nas.beritra.com:18081/blog/202005/705793b8gy1g5ruls77t2g208c08ct97.gif" alt="汤圆手势OK _斗图表情包"></p>
]]></content>
      <categories>
        <category>Blog</category>
      </categories>
      <tags>
        <tag>Blog</tag>
        <tag>Typora</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot中的事务</title>
    <url>/2020/04/21/SpringBoot%E4%B8%AD%E7%9A%84%E4%BA%8B%E5%8A%A1/</url>
    <content><![CDATA[<p>SpringBoot 是怎么处理事务？事务注解怎么用？有哪些需要注意的问题？我们自己动手一步一步的从实验中学习。</p>
<a id="more"></a>

<h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p>众所周知 SpringBoot 支持声明式事务和编程式事务，本文讨论的是基于声明式事务，或者叫注解式事务。</p>
<p>为了方便同步，文章中的代码用到了以下框架和类库：</p>
<ul>
<li>spring-boot-starter</li>
<li>spring-boot-starter-web</li>
<li>mybatis-plus-boot-starter</li>
<li>mysql-connector-java</li>
</ul>
<p>首先我们复习下前置知识点。</p>
<p>数据库事务有 ACID 四大原则：</p>
<ul>
<li>原子性（Atomicity）指事务包含的所有操作要么全部成功，要么全部失败回滚，这和前面两篇博客介绍事务的功能是一样的概念，因此事务的操作如果成功就必须要完全应用到数据库，如果操作失败则不能对数据库有任何影响。</li>
<li>一致性（Consistency）指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态。</li>
<li>隔离性（Isolation）隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。即要达到这么一种效果：对于任意两个并发的事务 T1 和 T2，在事务 T1 看来，T2 要么在 T1 开始之前就已经结束，要么在 T1 结束之后才开始，这样每个事务都感觉不到有其他事务在并发地执行。</li>
<li>持久性（Durability）指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。</li>
</ul>
<p>还有数据库经常出现的几种错误情况：</p>
<ul>
<li><p>脏读：是指在一个事务处理过程里读取了另一个未提交的事务中的数据。比如一个人的名字叫张三，事务 A 这时候修改为了李四，但是没有提交事务，事务 B 此时读取姓名，如果读到了张三，就产生了脏读，一旦事务 A 回滚了，B 读到的李四就是脏数据。</p>
</li>
<li><p>不可重复读：是指在对于数据库中的某个数据，一个事务范围内多次查询却返回了不同的数据值，这是由于在查询间隔，被另一个事务修改并提交了。不可重复读和脏读的区别是，脏读是某一事务读取了另一个事务未提交的脏数据，而不可重复读则是读取了前一事务提交的数据。比如事务 A，读取<code>id=1</code>的人的名字，得到是张三，这时候事务 B 把<code>id=1</code>的人的名字改为了李四，并且提交了事务。这时候事务 A 再查询一遍<code>id=1</code>的人的名字，发现变成了李四。</p>
</li>
<li><p>幻读(虚读)：幻读是事务非独立执行时发生的一种现象，是指操作记录数的变化。幻读的定义其实经常引起争议。</p>
<p>高性能 mysql 中这么定义幻读：</p>
<blockquote>
<p>事务A读取某个范围的记录，事务B在该范围插入了新的记录，事务A再次读取该范围的记录，会产生幻行。</p>
<p>InnoDB 使用 mvcc 解决了幻读的问题。</p>
</blockquote>
<p>在这种意义下，InnoDB 中的 Repeatable Read 隔离级别是直接解决了幻读的，但是还有如下情况：</p>
<p>事务 A 对先查询一条不存在的数据，结果显示为空，然后插入该数据，在事务 A 插入之前，事务 B 率先插入了数据，导致事务 A 插入失败，就现了幻觉。也有人将这种情况称之为幻读，但是我觉得高性能 MySQL 中的定义更准确，另外后面这种情况可以用<code>for update</code>解决。</p>
</li>
</ul>
<p>然后就是事务的隔离级别，MySQL 中的隔离级别和 SpringBoot 是一样的（或者应该反过来说），为了解决以上三种问题，有四种不同的隔离级别，具体作用如图：</p>
<p><img src="http://nas.beritra.com:18081/uploads/medium/598e93545f0cc1539b063849dfd379c1.png" alt=""></p>
<h2 id="Transactional-注解"><a href="#Transactional-注解" class="headerlink" title="Transactional 注解"></a>Transactional 注解</h2><p>Spring 事务最简单方便的使用方式是使用<code>Transactional</code>注解，可以被应用于接口定义和接口方法、类定义和类的 public 方法上。但是不推荐用在接口上面，因为一旦标注在 Interface 上并且配置了Spring AOP 使用 CGLib 动态代理，将会导致<code>Transactional</code>注解失效。</p>
<p>Transactional 注解的原理是这样：</p>
<p>在应用系统调用声明<code>@Transactional</code>的目标方法时，Spring Framework 默认使用 AOP 代理，在代码运行时生成一个代理对象，根据<code>@Transactional</code>的属性配置信息，这个代理对象决定该声明<code>@Transactional</code>的目标方法是否由拦截器 <code>TransactionInterceptor</code>来使用拦截，在<code>TransactionInterceptor</code>拦截时，会在在目标方法开始执行之前创建并加入事务，并执行目标方法的逻辑, 最后根据执行情况是否出现异常，利用抽象事务管理器<code>AbstractPlatformTransactionManager</code>操作数据源 DataSource 提交或回滚事务。</p>
<p>注解的所有属性如下：</p>
<p><img src="http://nas.beritra.com:18081/uploads/medium/e899c8713bc69fd99236c0d39160b083.png" alt=""></p>
<p>第一个属性<code>value</code>的作用是：当在配置文件中有多个<code>TransactionManager</code>，可以用该属性指定选择哪个事务管理器。</p>
<p>事务的传播和隔离级别下面详细叙述。</p>
<p><code>readOnly</code>和<code>timeout</code>都很好理解。</p>
<p>最后面的四个是指定事务回滚规则，事务回滚规则定义了哪些异常会导致事务回滚而哪些不会。默认情况下，只有未检查异常（<code>RuntimeException</code>和<code>Error</code>类型的异常）会导致事务回滚。</p>
<h2 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h2><p>Spring 事务支持四种隔离级别：</p>
<ol>
<li><p>ISOLATION_DEFAULT： 这是一个<code>PlatfromTransactionManager</code>默认的隔离级别，使用数据库默认的事务隔离级别。另外四个与 JDBC 的隔离级别相对应。MySQL 默认的事务处理级别是<code>REPEATABLE-READ</code>。</p>
</li>
<li><p>ISOLATION_READ_UNCOMMITTED： 这是事务最低的隔离级别，它充许令外一个事务可以看到这个事务未提交的数据。这种隔离级别会产生脏读，不可重复读和幻像读。</p>
</li>
<li><p>ISOLATION_READ_COMMITTED：保证一个事务修改的数据提交后才能被另外一个事务读取。另外一个事务不能读取该事务未提交的数据。这种隔离级别有可能产生不可重复读和幻读。</p>
</li>
<li><p>ISOLATION_REPEATABLE_READ： 这种事务隔离级别可以防止脏读，不可重复读。但是可能出现幻像读。</p>
</li>
<li><p>ISOLATION_SERIALIZABLE： 这是花费最高代价但是最可靠的事务隔离级别。事务被处理为顺序执行。除了防止脏读，不可重复读外，还避免了幻像读。</p>
</li>
</ol>
<p>好，原理看完了，开始实验。SpringBoot 的项目搭建就不赘述了，我们先准备一个表：</p>
<p><img src="http://nas.beritra.com:18081/uploads/big/64a7d9fb9aa45b62140b89f23453af5e.png" alt=""></p>
<p>图省事只有三个字段，自增主键<code>id</code>和姓名年龄。</p>
<p>我们先看默认的情况，添加一个开启事务的插入操作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional</span>()</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testInsert</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    TestTable data = <span class="keyword">new</span> TestTable();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    data.setName(<span class="string">"张三"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    data.setAge(<span class="number">20</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> result = testTableMapper.insert(data);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (result == <span class="number">1</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        logger.info(<span class="string">"添加数据&#123;&#125;成功"</span>, data);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"RuntimeException"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>可以看到日志提示添加成功，然后去数据库里没有这条，因为抛出异常回滚了。</p>
<p>如果在这个事务已经添加，但是没提交的情况下，另一个会话去读的话会发生什么？</p>
<p>我们添加一个读去全部数据的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSelect</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    List&lt;TestTable&gt; list = testTableMapper.selectList(Wrappers.emptyWrapper());</span></pre></td></tr><tr><td class="code"><pre><span class="line">    logger.info(<span class="string">"读取数据：&#123;&#125;"</span>, list.toString());</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>然后在上面那个插入的方法中添加线程休眠，模拟事务未提交的情况。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional</span>()</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testInsert</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    TestTable data = <span class="keyword">new</span> TestTable();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    data.setName(<span class="string">"张三"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    data.setAge(<span class="number">20</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> result = testTableMapper.insert(data);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (result == <span class="number">1</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        logger.info(<span class="string">"添加数据&#123;&#125;成功"</span>, data);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Thread.sleep(<span class="number">10000000</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        e.printStackTrace();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"RuntimeException"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>这时候你会发现，不光第一个插入的方法阻塞了，查询的方法也阻塞了。这是因为虽然你没开启事务，但是数据库实际上用了默认的隔离级别。</p>
<p>我们切换到最低的隔离级别：<code>READ_UNCOMMITTED</code>。就是说一个事务可以看到另一个事务未提交的数据。</p>
<p>把查询方法也加上事务，并且切换隔离级别：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional</span>(isolation = Isolation.READ_UNCOMMITTED)</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSelect</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    List&lt;TestTable&gt; list = testTableMapper.selectList(Wrappers.emptyWrapper());</span></pre></td></tr><tr><td class="code"><pre><span class="line">    logger.info(<span class="string">"读取数据：&#123;&#125;"</span>, list.toString());</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>可以看到，这次就读到了插入事务里未提交的张三。<code>READ_UNCOMMITTED</code>作为级别最低的隔离级别，一般很少会用。</p>
<p>然后我们来测试<code>READ_COMMITTED</code>，还是上面完全一样的代码，把查询方法的隔离级别改成<code>READ_COMMITTED</code>，就会发现张三看不到了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional</span>(isolation = Isolation.READ_COMMITTED)</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSelect</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    List&lt;TestTable&gt; list = testTableMapper.selectList(Wrappers.emptyWrapper());</span></pre></td></tr><tr><td class="code"><pre><span class="line">    logger.info(<span class="string">"读取数据：&#123;&#125;"</span>, list.toString());</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>然后我们插入一条张三的数据：</p>
<p><img src="http://nas.beritra.com:18081/uploads/big/11f36f795a39114e6b2c73789448cdc9.png" alt=""></p>
<p>写一个更新的方法，把张三改名为李四：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testUpdate</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> result = testTableMapper.update(<span class="keyword">null</span>, Wrappers.lambdaUpdate(TestTable<span class="class">.<span class="keyword">class</span>)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            .set(TestTable::getName,"李四").eq(TestTable::getName, "张三"));</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (result == <span class="number">1</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        logger.info(<span class="string">"更新数据成功"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>我们把查询方法查询两次，分别打印查询到的数据，中间休眠五秒，休眠期间执行更新方法，看看两次有什么区别（注意，要把 mybatis-plus 的一个配置<code>local-cache-scope</code>改成<code>statement</code>，不然通过 id 查询数据的话，第二次会直接走缓存，没有实际去数据库查。）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional</span>(isolation = Isolation.READ_COMMITTED)</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSelect</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    TestTable data = testTableMapper.selectById(<span class="number">1</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    logger.info(<span class="string">"读取数据：&#123;&#125;"</span>, data);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Thread.sleep(<span class="number">3000</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        e.printStackTrace();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    data = testTableMapper.selectById(<span class="number">1</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    logger.info(<span class="string">"读取数据：&#123;&#125;"</span>, data);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>从日志里可以看出，查询方法第一次查询的时候，名字还是张三，执行更新方法之后，就变成了李四。也就是说，在事务还没提交的时候，受到了其他事务的影响。</p>
<p>当我们把查询方法的隔离级别改成<code>REPEATABLE_READ</code>的时候，这个问题就不复存在了，你会发现两次查询都是张三。</p>
<p>由于实质上的幻读已经被 InnoDB 干掉了，我们就先不看怎么用<code>SERIALIZABLE</code>级别来解决幻读了，而是直接看<code>SERIALIZABLE</code>级别能做什么吧。</p>
<p>这个代码比较简单</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional</span>(isolation = Isolation.SERIALIZABLE)</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSelect</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    logger.info(<span class="string">"进入testSelect方法"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    List&lt;TestTable&gt; list = testTableMapper.selectList(Wrappers.emptyWrapper());</span></pre></td></tr><tr><td class="code"><pre><span class="line">    logger.info(<span class="string">"读取数据：&#123;&#125;"</span>, list.toString());</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Thread.sleep(<span class="number">5000</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        e.printStackTrace();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>连续执行两次这个方法，你就会发现在第一次的线程休眠结束之前，第二次会阻塞。<code>SERIALIZABLE</code>的作用就是把事务串行化，所有该类型的事务都会排队一个一个的执行。同样的，如果另一个方法也是<code>SERIALIZABLE</code>级别，他和<code>testSelect</code>方法也是只能串行执行。比如下面这种，我们增加一个查询方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional</span>(isolation = Isolation.SERIALIZABLE)</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSelect2</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    List&lt;TestTable&gt; list = testTableMapper.selectList(Wrappers.emptyWrapper());</span></pre></td></tr><tr><td class="code"><pre><span class="line">    logger.info(<span class="string">"读取数据：&#123;&#125;"</span>, list.toString());</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>同样的，<code>testSelect2</code>也会阻塞等待前一个事务的执行完毕。但是注意当我们把<code>testSelect2</code>的隔离级别改回默认，即<code>REPEATABLE_READ</code>，就不会阻塞等待了。</p>
<h2 id="事务的传播级别"><a href="#事务的传播级别" class="headerlink" title="事务的传播级别"></a>事务的传播级别</h2><p>首先要清楚什么是事务的传播级别：用来描述由某一个事务传播行为修饰的方法被嵌套进另一个方法的时事务如何传播。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodA</span><span class="params">()</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">   methodB();</span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="comment">//doSomething</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">@Transaction</span>(Propagation=XXX)</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodB</span><span class="params">()</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="comment">//doSomething</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>代码中<code>methodA()</code>方法嵌套调用了<code>methodB()</code>方法，<code>methodB()</code>的事务传播行为由<code>@Transaction(Propagation=XXX)</code>设置决定。这里需要注意的是<code>methodA()</code>并没有开启事务，某一个事务传播行为修饰的方法并不是<strong>必须</strong>要在开启事务的外围方法中调用。</p>
<p>Spring 中有七大传播级别：</p>
<ul>
<li>PROPAGATION_REQUIRED：如果当前没有事务，就新建一个事务，如果已经存在一个事务中，加入到这个事务中。如果被调用端发生异常，那么调用端和被调用端事务都将回滚。这是最常见的选择。</li>
<li>PROPAGATION_SUPPORTS：支持当前事务，如果当前没有事务，就以非事务的方式执行。</li>
<li>PROPAGATION_MANDATORY：使用当前的事务，如果当前没有事务，就抛出异常。</li>
<li>PROPAGATION_REQUIRES_NEW：新建事务，如果外部存在事务，把外部事务挂起。这个内部的事务将被完全提交或回滚而不依赖于外部事务，它拥有自己的隔离范围，自己的锁，等等。</li>
<li>PROPAGATION_NOT_SUPPORTED：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。</li>
<li>PROPAGATION_NEVER：以非事务方式执行，如果当前存在事务，就抛出异常。</li>
<li>PROPAGATION_NESTED：如果当前方法正有一个事务在运行中，则该方法应该运行在一个嵌套事务中，被嵌套的事务可以独立于被封装的事务中进行提交或者回滚。</li>
</ul>
<p>好，我们开始一个一个的测试，加深理解。</p>
<p><strong>注意，由于内部方法抛出运行时异常，会在外层方法里面继续抛出，导致预期外的结果，所以我们不能用抛出异常的方式进行使用。所以下面的测试都是手动回滚。</strong></p>
<p>首先新建两个<code>ServiceA</code>和<code>ServiceB</code>，A 中注入 B，当然还有两个<code>mapper</code>，然后还是用之前的数据库表，先把表清空。两个类文件如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceA</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">@Resource</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    TestTableMapper testTableMapper;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">@Resource</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    ServiceB serviceB;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceB</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">@Resource</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    TestTableMapper testTableMapper;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>为什么需要两个<code>Service</code>而不是在同一个里面进行方法调用，这个涉及到<code>Spring</code>的依赖注入机制，这里先不展开。</p>
<p>我们用插入方法来测试，先插入一条记录，然后抛出异常，通过看数据库中是否真正执行了插入，来判断事务的执行状态。当然也可以打开日志的<code>debug</code>级别，直接看数据库的执行日志。</p>
<h3 id="PROPAGATION-REQUIRED"><a href="#PROPAGATION-REQUIRED" class="headerlink" title="PROPAGATION_REQUIRED"></a>PROPAGATION_REQUIRED</h3><p>如果没有事务，就新建事务，如果已经有了就加入。</p>
<p>我们先测试 A 没有事务，B 有事务的情况：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这是ServiceA</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">     serviceB.insert();</span></pre></td></tr><tr><td class="code"><pre><span class="line"> &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"> </span></pre></td></tr><tr><td class="code"><pre><span class="line"> <span class="comment">//这是ServiceB</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"> <span class="meta">@Transactional</span>(propagation = Propagation.REQUIRED)</span></pre></td></tr><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">     TestTable someOne = <span class="keyword">new</span> TestTable();</span></pre></td></tr><tr><td class="code"><pre><span class="line">     someOne.setId(<span class="number">1</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">     someOne.setName(<span class="string">"法外狂徒张三"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">     someOne.setAge(<span class="number">19</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">     testTableMapper.insert(someOne);</span></pre></td></tr><tr><td class="code"><pre><span class="line">     TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();</span></pre></td></tr><tr><td class="code"><pre><span class="line"> &#125;</span></pre></td></tr></table></figure>

<p>可以看出数据没有实际插入进去，事务进行了回滚。然后我们把<code>ServiceA</code>中的方法加上事务。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    serviceB.insert();</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>一样的结果。</p>
<p>如果调用端出错了呢？我们把<code>ServiceB</code>中的回滚去掉，让<code>ServiceA</code>中回滚试试：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    serviceB.insert();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>可以看出同样发生了回滚，两个事务其实合为一个了。</p>
<h3 id="PROPAGATION-SUPPORTS"><a href="#PROPAGATION-SUPPORTS" class="headerlink" title="PROPAGATION_SUPPORTS"></a>PROPAGATION_SUPPORTS</h3><p>如果不存在外层事务，就不开启事务，如果有就加入外部事务运行。</p>
<p>我们去掉<code>ServiceB</code>的事务，A 的还带着，在 A 中回滚。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;<span class="comment">//ServiceA</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    serviceB.insert();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"出错啦"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@Transactional</span>(propagation = Propagation.SUPPORTS)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">()</span> </span>&#123;<span class="comment">//ServiceB</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    TestTable someOne = <span class="keyword">new</span> TestTable();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    someOne.setId(<span class="number">1</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    someOne.setName(<span class="string">"法外狂徒张三"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    someOne.setAge(<span class="number">19</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    testTableMapper.insert(someOne);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>可以看出还是发生了回滚，证明 B 虽然自身没有异常，但是由于加入了 A 的事务，所以一起跟着回滚了。</p>
<p>我们把 A 的事务也去掉。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;<span class="comment">//ServiceA</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    serviceB.insert();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"出错啦"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>可以看到数据成功插入了，没有发生回滚。</p>
<h3 id="PROPAGATION-MANDATORY"><a href="#PROPAGATION-MANDATORY" class="headerlink" title="PROPAGATION_MANDATORY"></a>PROPAGATION_MANDATORY</h3><p>必须要有事务，没有事务就抛异常。</p>
<p>我们还是去掉 A 的事务和异常抛出，把 B 的传播级别改成<code>PROPAGATION_MANDATORY</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;<span class="comment">//ServiceA</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    serviceB.insert();</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional</span>(propagation = Propagation.MANDATORY)</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">()</span> </span>&#123;<span class="comment">//ServiceB</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    TestTable someOne = <span class="keyword">new</span> TestTable();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    someOne.setId(<span class="number">1</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    someOne.setName(<span class="string">"法外狂徒张三"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    someOne.setAge(<span class="number">19</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    testTableMapper.insert(someOne);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>可以看到直接抛出了异常</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">org.springframework.transaction.IllegalTransactionStateException: No existing transaction found for transaction marked with propagation &#39;mandatory&#39;</span></pre></td></tr></table></figure>

<p>我们给<code>ServiceA</code>加上事务：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;<span class="comment">//ServiceA</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    serviceB.insert();</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>整个事务顺利完成，没有问题。</p>
<h3 id="PROPAGATION-REQUIRES-NEW"><a href="#PROPAGATION-REQUIRES-NEW" class="headerlink" title="PROPAGATION_REQUIRES_NEW"></a>PROPAGATION_REQUIRES_NEW</h3><p>无论当前事务上下文中有没有事务，都会开启一个新的事务，如果有了外部事务就挂起，内部的事务将被完全提交或回滚而不依赖于外部事务。</p>
<p>我们先写一个外部的事务 ServiceA，调用了内部事务 ServiceB，让事务 A 进行回滚：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;<span class="comment">//ServiceA 中的方法，外部事务</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    System.out.println(<span class="string">"执行ServiceA"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    serviceB.insert();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    TestTable someOne = <span class="keyword">new</span> TestTable();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    someOne.setId(<span class="number">2</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    someOne.setName(<span class="string">"法外狂徒李四"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    someOne.setAge(<span class="number">28</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    testTableMapper.insert(someOne);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional</span>(propagation = Propagation.REQUIRES_NEW)</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">()</span> </span>&#123;<span class="comment">//ServiceB 的方法，内部事务</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    System.out.println(<span class="string">"执行ServiceB"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    TestTable someOne = <span class="keyword">new</span> TestTable();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    someOne.setId(<span class="number">1</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    someOne.setName(<span class="string">"法外狂徒张三"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    someOne.setAge(<span class="number">18</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    testTableMapper.insert(someOne);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>执行可以看到，外部事务 ServiceA 插入的内容被回滚了，内部事务 ServiceB 的动作执行不受影响。</p>
<p>类似的，如果我们反过来，B 中回滚而 A 不回滚，B 也不会影响到 A，二者相互独立。</p>
<h3 id="PROPAGATION-NOT-SUPPORTED"><a href="#PROPAGATION-NOT-SUPPORTED" class="headerlink" title="PROPAGATION_NOT_SUPPORTED"></a>PROPAGATION_NOT_SUPPORTED</h3><p>这个传播级别下，内部事务总是以非事务的形式运行，不管外面有没有事务，自身都是没有事务。</p>
<p>我们还是做测试，先让内部事务抛出异常：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional</span>(propagation = Propagation.NOT_SUPPORTED)</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">()</span> </span>&#123;<span class="comment">//ServiceB 内部事务</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    System.out.println(<span class="string">"执行ServiceB"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    TestTable someOne = <span class="keyword">new</span> TestTable();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    someOne.setId(<span class="number">1</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    someOne.setName(<span class="string">"法外狂徒张三"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    someOne.setAge(<span class="number">18</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    testTableMapper.insert(someOne);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"RuntimeException"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;<span class="comment">//ServiceA 外部事务</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    System.out.println(<span class="string">"执行ServiceA"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    TestTable someOne = <span class="keyword">new</span> TestTable();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    someOne.setId(<span class="number">2</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    someOne.setName(<span class="string">"法外狂徒李四"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    someOne.setAge(<span class="number">28</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    testTableMapper.insert(someOne);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    serviceB.insert();</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>可以看出内部事务由于没有事务，所以虽然抛出异常但是数据库操作正常结束，没有回滚。当然外面的事务收到了影响，因为  catch 到了内部事务的异常。</p>
<p>类似的，如果外面事务抛出异常，内部事务也不会回滚。</p>
<h3 id="PROPAGATION-NEVER"><a href="#PROPAGATION-NEVER" class="headerlink" title="PROPAGATION_NEVER"></a>PROPAGATION_NEVER</h3><p>这个级别更简单，外部不能有事务，有就抛异常。示例都不用写了，非常好理解，抛出的异常如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">org.springframework.transaction.IllegalTransactionStateException: Existing transaction found for transaction marked with propagation &#39;never&#39;</span></pre></td></tr></table></figure>



<h3 id="PROPAGATION-NESTED"><a href="#PROPAGATION-NESTED" class="headerlink" title="PROPAGATION_NESTED"></a>PROPAGATION_NESTED</h3><p>这个级别很有意思，如果外面没有事务就创建事务，如果有的话就嵌套进去。这个嵌套的意思是指的“暂存点”，如果子事务发生异常，会直接回滚到这个暂存点，而不会导致整体事务的回滚。</p>
<p>废话少说看测试：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional</span>(propagation = Propagation.NESTED)</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">()</span> </span>&#123;<span class="comment">//ServiceB，内部事务，插入然后抛出异常</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    System.out.println(<span class="string">"执行ServiceB"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    TestTable someOne = <span class="keyword">new</span> TestTable();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    someOne.setId(<span class="number">1</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    someOne.setName(<span class="string">"法外狂徒张三"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    someOne.setAge(<span class="number">18</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    testTableMapper.insert(someOne);</span></pre></td></tr><tr><td class="code"><pre><span class="line">   TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;<span class="comment">//ServiceA，外部事务，在调用 B 的前后分别插入。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    System.out.println(<span class="string">"执行ServiceA"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    TestTable someOne = <span class="keyword">new</span> TestTable();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    someOne.setId(<span class="number">2</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    someOne.setName(<span class="string">"法外狂徒李四"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    someOne.setAge(<span class="number">28</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    testTableMapper.insert(someOne);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    serviceB.insert();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    someOne.setId(<span class="number">3</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    someOne.setName(<span class="string">"王五"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    someOne.setAge(<span class="number">66</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    testTableMapper.insert(someOne);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>这个例子里面，内部事务回滚了，但是外部没有回滚。但是外部事务回滚，内部事务也会跟着回滚。</p>
<p>看出来跟<code>REQUIRED</code>，<code>REQUIRES_NEW</code>之间的不同了吗？区别如下：</p>
<ul>
<li>REQUIRED：内外是一个整体，无论内部还是外部的回滚，都会导致二者全回滚。</li>
<li>REQUIRES_NEW：内外相互独立，互相完全不影响。</li>
<li>NESTED：内部加入外部，但是外部不受内部影响。内部回滚的话外部正常，外部回滚的话内部会跟着回滚。</li>
</ul>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ul>
<li>在需要事务管理的地方加<code>@Transactional</code>注解。<code>@Transactional</code>注解可以被应用于接口定义和接口方法、类定义和类的 <code>public</code>方法上。</li>
<li><code>@Transactional</code>注解只能应用到<code>public</code>可见度的方法上。 如果你在<code>protected</code>、<code>private</code>或者<code>package-visible</code>的方法上使用<code>@Transactional</code>注解，它也不会报错， 但是这个被注解的方法将不会展示已配置的事务设置。</li>
<li><code>@Transactional</code>的事务开启 ，或者是基于接口的 或者是基于类的代理被创建。所以在同一个类中一个方法调用另一个方法有事务的方法，事务是不会起作用的。</li>
<li>在接口上使用<code>@Transactional</code>注解，只能当你设置了基于接口的代理时它才生效。</li>
</ul>
<h2 id="面试常见问题"><a href="#面试常见问题" class="headerlink" title="面试常见问题"></a>面试常见问题</h2><p>//TODO 后续补充</p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>framework</tag>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>Java并发包使用指南</title>
    <url>/2020/03/23/Java%E5%B9%B6%E5%8F%91%E5%8C%85%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<p>我们常说的“并发包”指的是<code>java.util.concurrent</code>这个包，后面简称 J.U.C，里面包含大量多线程和并发编程的工具。J.U.C 包是 JDK 1.5 版本引入，由 Doug Lea 和众多其他大神合力完成，包含大量对并发编程的思考精华，仔细观摩思考他们的设计思路，对于我们学习多线程和并发编程有非常大的帮助。本文所有内容基于 JDK11。</p>
<a id="more"></a>

<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>先从两个角度看下并发包的层次结构，一个是继承关系图：</p>
<p><img src="http://nas.beritra.com:18081/uploads/medium/3f4c527e12222b42e865eadcef7c18e0.png" alt=""></p>
<p>一个是功能结构：</p>
<p><img src="http://nas.beritra.com:18081/uploads/big/f76128db96dba6b6481a81c63a9f87ba.png" alt=""></p>
<p>并发包非常庞大，结构复杂，个人能力有限也不可能总结非常清楚，我们先从常见、常用的开始看起吧。</p>
<h2 id="工具类"><a href="#工具类" class="headerlink" title="工具类"></a>工具类</h2><p>工具包内主要有这几个工具：计数器<code>CountDownLatch</code>、回环栅栏（光看名字估计一头雾水）<code>CyclicBarrier</code>、信号量<code>Semaphore</code>、创建线程池的<code>Executors</code>，最后一个交换数据的<code>Exchanger</code>。本章几个工具的原理都是基于 AQS，关于 AQS 和<code>ReentrantLock</code>，都有单独的文章解读，就不专门介绍了。</p>
<h3 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h3><h4 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h4><p>一个计数器，常见这样一种场景：多个任务分发个不同的线程去执行，全部执行完毕后回到主线程。当然有不同的实现方式，用<code>CountDownLatch</code>实现起来就很简单：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> taskNum = <span class="number">20</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">CountDownLatch countLatch = <span class="keyword">new</span> CountDownLatch(taskNum);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; taskNum; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            Thread.sleep(<span class="number">200</span>); <span class="comment">//假装做了点什么</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"执行完毕"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            e.printStackTrace();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        countLatch.countDown();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;).start();</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    countLatch.await();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    System.out.println(<span class="string">"全部任务执行完毕"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    e.printStackTrace();</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>



<h3 id="Seamphore"><a href="#Seamphore" class="headerlink" title="Seamphore"></a>Seamphore</h3><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>信号量，类似于控制并发的时候用到的“令牌桶”算法，通过控制信号总数，不断释放和回收信号来控制并发数量。假设有这么一个场景，假设我们有五个通道可以执行任务，任务总数是 40，所以同一时刻只能有最多五个线程执行，其余的要等待，因此我们使用<code>Seamphore</code>来不断方法许可和收回许可：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">5</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">40</span>; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            semaphore.acquire();</span></pre></td></tr><tr><td class="code"><pre><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"取得许可，开始执行任务"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            Thread.sleep(<span class="keyword">new</span> Random().nextInt(<span class="number">2000</span>));</span></pre></td></tr><tr><td class="code"><pre><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"任务完成，释放许可"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            semaphore.release();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            e.printStackTrace();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;).start();</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>



<h3 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h3><h4 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h4><p>回环栅栏光看名字不好理解，其实作用很上面的计数器类似，有点类似于 Java 虚拟机中的“安全点”。执行一个任务的时候，所有线程到达栅栏之后停止，等待所有其他线程都到达这个点，然后一起进入下一阶段。与计数器不同的是，<code>CyclicBarrier</code>可以重复使用，举个栗子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CyclicBarrier cyclicBarrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">20</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">           <span class="keyword">new</span> Thread(() -&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">               <span class="keyword">long</span> timeStamp = System.currentTimeMillis();</span></pre></td></tr><tr><td class="code"><pre><span class="line">               <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                   Thread.sleep(<span class="keyword">new</span> Random().nextInt(<span class="number">2000</span>));</span></pre></td></tr><tr><td class="code"><pre><span class="line">                   System.out.println(Thread.currentThread().getName() + <span class="string">":一阶段任务完成，花费了"</span> + (System.currentTimeMillis() - timeStamp) + <span class="string">"毫秒，开始等待其他线程"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                   cyclicBarrier.await();</span></pre></td></tr><tr><td class="code"><pre><span class="line">                   System.out.println(Thread.currentThread().getName() + <span class="string">":所有线程执行完成，开始下一阶段"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                   timeStamp = System.currentTimeMillis();</span></pre></td></tr><tr><td class="code"><pre><span class="line">                   Thread.sleep(<span class="keyword">new</span> Random().nextInt(<span class="number">2000</span>));</span></pre></td></tr><tr><td class="code"><pre><span class="line">                   System.out.println(Thread.currentThread().getName() + <span class="string">":二阶段任务完成，花费了"</span> + (System.currentTimeMillis() - timeStamp) + <span class="string">"毫秒，开始等待其他线程"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                   cyclicBarrier.await();</span></pre></td></tr><tr><td class="code"><pre><span class="line">                   System.out.println(Thread.currentThread().getName() + <span class="string">":所有线程任务完成"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">               &#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                   e.printStackTrace();</span></pre></td></tr><tr><td class="code"><pre><span class="line">               &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">           &#125;).start();</span></pre></td></tr><tr><td class="code"><pre><span class="line">       &#125;</span></pre></td></tr></table></figure>



<h3 id="Exchanger"><a href="#Exchanger" class="headerlink" title="Exchanger"></a>Exchanger</h3><h4 id="使用-2"><a href="#使用-2" class="headerlink" title="使用"></a>使用</h4><p>交换器顾名思义，就是用来交换数据，理解和使用起来是最简单的，但是内部实现很精巧复杂。使用很简单，只有两个方法，作用就是两个线程在一个安全点交换数据，产生数据慢的那个会阻塞等待。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Exchanger&lt;Integer&gt; exchanger = <span class="keyword">new</span> Exchanger&lt;&gt;();</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> num = <span class="keyword">new</span> Random().nextInt(<span class="number">1000</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    System.out.println(<span class="string">"交换之前：Thread1:"</span> + num);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        num = exchanger.exchange(num);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.println(<span class="string">"交换完毕：Thread1:"</span> + num);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        e.printStackTrace();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;).start();</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> num = <span class="keyword">new</span> Random().nextInt(<span class="number">1000</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    System.out.println(<span class="string">"交换之前：Thread2:"</span> + num);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Thread.sleep(<span class="number">2000</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        num = exchanger.exchange(num);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.println(<span class="string">"交换完毕：Thread2:"</span> + num);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        e.printStackTrace();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;).start();</span></pre></td></tr></table></figure>



<h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><p>在 J.U.C 包中，创建线程池有两种方式，一种是手动创建，一种是通过<code>Executors</code>工厂类创建预设的几种线程池。</p>
<p>基础的线程有如下几个：</p>
<p><img src="http://nas.beritra.com:18081/uploads/big/6de5c2ec64cd89e92fa688a813301622.png" alt=""></p>
<p>而<code>Executors</code>默认提供了六种线程池，但是不推荐在生产环境中直接使用，因为默认的设置对数据量没有进行限制，有可能出现问题。</p>
<h3 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h3><p><code>ThreadPoolExecutor</code>提供了四个构造方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,<span class="keyword">int</span> maximumPoolSize, <span class="keyword">long</span> keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue)</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,<span class="keyword">int</span> maximumPoolSize,<span class="keyword">long</span> keepAliveTime,TimeUnit unit,BlockingQueue&lt;Runnable&gt; workQueue, RejectedExecutionHandler handler)</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize, <span class="keyword">int</span> maximumPoolSize,<span class="keyword">long</span> keepAliveTime,TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue,   ThreadFactory threadFactory)</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,<span class="keyword">int</span> maximumPoolSize,<span class="keyword">long</span> keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler)</span></span></span></pre></td></tr></table></figure>

<p>可以看出参数都类似，首先要确定初始化线程数量和最大数量，然后是存活时间和时间单位。如果线程池已满，就会把多余的任务放到一个阻塞队列中，你需要定义这么一个队列。如果队列也满了，还需要指定拒绝策略。同时还可以传入一个线程工厂来确定线程生成策略。</p>
<p>一个最简单的线程池就可以这么创建了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ThreadPoolExecutor executor = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">2</span>, <span class="number">20</span>, <span class="number">10</span>, TimeUnit.SECONDS,  <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">10</span>));</span></pre></td></tr></table></figure>

<p>这里要注意线程池的扩容策略，在创建了线程池后，默认情况下，线程池中并没有任何线程，而是等待有任务到来才创建线程去执行任务，除非调用了<code>prestartAllCoreThreads()</code>或者<code>prestartCoreThread()</code>方法，从这 2 个方法的名字就可以看出，是预创建线程的意思，即在没有任务到来之前就创建<code>corePoolSize</code>个线程或者一个线程。当线程池中的线程数目达到<code>corePoolSize</code>后，就会把到达的任务放到缓存队列当中，只有当缓存队列也满了才会出发扩容，创建新的线程，然后当线程池容量扩建到设定的最大值之后，如果还有新的任务，就会触发拒绝策略，返回相应的结果或者默认抛出异常。</p>
<p><code>keepAliveTime</code>是线程池维护线程所允许的空闲时间。当线程池中的线程数量大于<code>corePoolSize</code>的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等待，直到等待的时间超过了<code>keepAliveTime</code>。</p>
<p>关于拒绝策略，除了自行实现以外，提供了四种预设的策略：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ThreadPoolExecutor.AbortPolicy:丢弃任务并抛出RejectedExecutionException异常。 </span></pre></td></tr><tr><td class="code"><pre><span class="line">ThreadPoolExecutor.DiscardPolicy：也是丢弃任务，但是不抛出异常。 </span></pre></td></tr><tr><td class="code"><pre><span class="line">ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）</span></pre></td></tr><tr><td class="code"><pre><span class="line">ThreadPoolExecutor.CallerRunsPolicy：由调用线程处理该任务</span></pre></td></tr></table></figure>

<p>线程中的任务通过<code>execute()</code>或者<code>submi()</code>方法来提交，二者的区别是有没有返回值。</p>
<ul>
<li><code>execute()</code>方法实际上是<code>Executor</code>中声明的方法，在<code>ThreadPoolExecutor</code>进行了具体的实现，这个方法是<code>ThreadPoolExecutor</code>的核心方法，通过这个方法可以向线程池提交一个任务，交由线程池去执行。</li>
<li><code>submit()</code>方法是在<code>ExecutorService</code>中声明的方法，在<code>AbstractExecutorService</code>就已经有了具体的实现，在<code>ThreadPoolExecutor</code>中并没有对其进行重写，这个方法也是用来向线程池提交任务的，但是它和<code>execute()</code>方法不同，它能够返回任务执行的结果，去看<code>submit()</code>方法的实现，会发现它实际上还是调用的<code>execute()</code>方法，只不过它利用了<code>Future</code>来获取任务执行结果。</li>
</ul>
<p>执行任务还可以通过<code>invokeAll</code>方法，需要预先创建<code>Callable</code>的集合，然后放到线程池中执行，<code>invokeAll</code>会创建线程依次执行任务，主线程阻塞等待结果。但是，需要注意一种特殊情况：</p>
<p>当批量执行的任务数量大于线程池数量+队列数量，这时根据拒绝策略不同，会产生不同的结果，<strong>DiscardPolicy，DiscardOldestPolicy 这两种策略会导致线程池锁住</strong>。所以要是使用这两种拒绝策略的时候，就要控制任务数量，或者准备足够大的线程池。</p>
<h4 id="ForkJoinPool"><a href="#ForkJoinPool" class="headerlink" title="ForkJoinPool"></a>ForkJoinPool</h4><p><code>ForkJoinPool</code>主要思想就是分而治之，在能够用分治算法的场景下，<code>ForkJoinPool</code>有很高的效率。</p>
<p>ForkJoinPool的本质就是两点：</p>
<ol>
<li>如果任务很小：直接计算得出结果</li>
<li>如果任务很大<ul>
<li>拆分成N个子任务</li>
<li>调用子任务的<code>fork()</code>进行计算</li>
<li>调用子任务的<code>join()</code>合并结果</li>
</ul>
</li>
</ol>
<p>我们要使用 ForkJoin 框架，必须首先创建一个 ForkJoin 任务。它提供在任务中执行 fork() 和 join() 操作的机制，通常情况下我们不需要直接继承 ForkJoinTask 类，而只需要继承它的子类，ForkJoin 框架提供了以下两个子类：</p>
<ul>
<li>RecursiveAction：用于没有返回结果的任务。</li>
<li>RecursiveTask ：用于有返回结果的任务。</li>
</ul>
<p>比如这样一个场景：我们想要计算从 1 到 2000 的数字累加和，假设这个任务很消耗资源，我们打算交给多个线程分开去计算，最后把每个线程的结果加到一起。拆分任务的规则是每个线程计算不超过 20 个数字的累加和，我们就可以创建这么一个对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTask</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> start;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> end;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyTask</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyTask</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">this</span>.start = start;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">this</span>.end = end;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">protected</span> Integer <span class="title">compute</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (end - start &lt; <span class="number">20</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">int</span> count = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt;= end; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                count += i;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span> count;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> middle = (start + end) / <span class="number">2</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        MyTask leftTask = <span class="keyword">new</span> MyTask(start, middle);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        MyTask rightTask = <span class="keyword">new</span> MyTask(middle + <span class="number">1</span>, end);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        invokeAll(leftTask, rightTask);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        leftTask.fork();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        rightTask.fork();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> leftTask.join() + rightTask.join();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>可以看出，当计算量小于 20 的时候，开始计算，然后返回结果。如果计算量大于 20，就拆分任务，然后再创建两个子任务，等待子任务返回。这里的例子只是一个简单类比，实际上<code>ForkJoinPool</code>更适合计算密集型的任务，像这种小规模的简单累加线程调度的开销比计算本身大多了。</p>
<p>使用<code>ForkJoinPool</code>有几点需要注意：</p>
<ol>
<li>活跃线程数被控制在 CPU 核心数以内，所以不需要创建过多的线程，线程池内部调度的时候就会做限制。</li>
<li>最大线程数被限制在<code>0x7fff</code>，即 32767。</li>
<li>可以选择队列模式是 FOFO 或者 LIFO。</li>
<li>任务队列的初始化容量是 8192，最大容量限制是 67108864 即 64M，超过的话会抛异常。\</li>
</ol>
<p>相比<code>ThreadPoolExecutor</code>，<code>ForkJoinPool</code>的优势是什么？</p>
<p>使用<code>ForkJoinPool</code>能够使用数量有限的线程来完成非常多的具有父子关系的任务，比如使用 4 个线程来完成超过 200 万个任务。但是，使用<code>ThreadPoolExecutor</code>时，是不可能完成的，因为<code>ThreadPoolExecutor</code>中的<code>Thread</code>无法选择优先执行子任务，需要完成 200 万个具有父子关系的任务时，也需要 200 万个线程，显然这是不可行的。</p>
<h4 id="ScheduledPoolExecutor"><a href="#ScheduledPoolExecutor" class="headerlink" title="ScheduledPoolExecutor"></a>ScheduledPoolExecutor</h4><p>自 JDK1.5 开始，JDK 提供了<code>ScheduledThreadPoolExecutor</code>类来支持周期性任务的调度。在这之前的实现需要依靠<code>Timer</code>和<code>TimerTask</code>或者其它第三方工具来完成。</p>
<p><code>ScheduledThreadPoolExecutor</code>继承<code>ThreadPoolExecutor</code>来重用线程池的功能，它的实现方式如下：</p>
<ul>
<li><p>将任务封装成<code>ScheduledFutureTask</code>对象，<code>ScheduledFutureTask</code>基于相对时间，不受系统时间的改变所影响；</p>
</li>
<li><p><code>ScheduledFutureTask</code>实现了<code>java.lang.Comparable</code>接口和<code>java.util.concurrent.Delayed</code>接口，所以有两个重要的方法：<code>compareTo</code>和<code>getDelay</code>。<code>compareTo</code>方法用于比较任务之间的优先级关系，如果距离下次执行的时间间隔较短，则优先级高；<code>getDelay</code>方法用于返回距离下次任务执行时间的时间间隔；</p>
</li>
<li><p><code>ScheduledThreadPoolExecutor</code>定义了一个<code>DelayedWorkQueue</code>，它是一个有序队列，会通过每个任务按照距离下次执行时间间隔的大小来排序；</p>
</li>
<li><p><code>ScheduledFutureTask</code>继承自<code>FutureTask</code>，可以通过返回Future对象来获取执行的结果。</p>
<p><code>ScheduledThreadPoolExecutor</code>的构造函数有以下几个：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用给定核心池大小创建一个新 ScheduledThreadPoolExecutor。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">ScheduledThreadPoolExecutor(<span class="keyword">int</span> corePoolSize)  </span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 使用给定初始参数创建一个新 ScheduledThreadPoolExecutor。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">ScheduledThreadPoolExecutor(<span class="keyword">int</span> corePoolSize, RejectedExecutionHandler handler)  </span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 使用给定的初始参数创建一个新 ScheduledThreadPoolExecutor。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">ScheduledThreadPoolExecutor(<span class="keyword">int</span> corePoolSize, ThreadFactory threadFactory)  </span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 使用给定初始参数创建一个新 ScheduledThreadPoolExecutor。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">ScheduledThreadPoolExecutor(<span class="keyword">int</span> corePoolSize, ThreadFactory threadFactory, RejectedExecutionHandler handler)</span></pre></td></tr></table></figure>

<p><code>ScheduledThreadPoolExecutor</code>最多支持 3 个参数：核心线程数量，线程工厂，拒绝策略。</p>
<p>为什么没有最大线程数量？由于 <code>ScheduledThreadPoolExecutor</code> 内部是个无界队列，<code>maximumPoolSize</code> 也就没有意思了。</p>
<p>常用的方法有以下几个：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建并执行在给定延迟后启用的一次性操作。  </span></span></pre></td></tr><tr><td class="code"><pre><span class="line">ScheduledFuture&lt;?&gt;	schedule(Runnable command, <span class="keyword">long</span> delay, TimeUnit unit) </span></pre></td></tr><tr><td class="code"><pre><span class="line">  </span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 创建并执行一个在给定初始延迟后首次启用的定期操作，后续操作具有给定的周期；也就是将在 initialDelay 后开始执行，然后在 initialDelay+period 后执行，接着在 initialDelay + 2 * period 后执行，依此类推。 </span></span></pre></td></tr><tr><td class="code"><pre><span class="line">ScheduledFuture&lt;?&gt;	scheduleAtFixedRate(Runnable command, <span class="keyword">long</span> initialDelay, <span class="keyword">long</span> period, TimeUnit unit) </span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 创建并执行一个在给定初始延迟后首次启用的定期操作，随后，在每一次执行终止和下一次执行开始之间都存在给定的延迟。       </span></span></pre></td></tr><tr><td class="code"><pre><span class="line">ScheduledFuture&lt;?&gt;	scheduleWithFixedDelay(Runnable command, <span class="keyword">long</span> initialDelay, <span class="keyword">long</span> delay, TimeUnit unit)</span></pre></td></tr></table></figure>

<p><code>schedule</code>方法很好理解，是一次性操作，只不过加了个延迟。后面两个方法的区别就是：</p>
<ul>
<li><code>cheduleAtFixedRate</code>是两次执行开始时间的间隔固定，不管单次执行的时长，有可能上次还没执行完毕下次就开始了。</li>
<li><code>scheduleWithFixedDelay</code>是上次结束和下次开始之间的间隔固定，永远不会出现上次还没执行完毕下次就开始的情况。</li>
</ul>
<p>需要注意的是，任务的排序是通过 <code>ScheduledFutureTask</code>的 <code>compareTo</code>方法排序的，规则是先比较执行时间，如果时间相同，再比较加入时间。</p>
<p>还要注意一点就是：如果任务执行过程中异常了，那么将不会再次重复执行。因为 <code>ScheduledFutureTask</code>的 <code>run</code>方法没有做<code>catch</code>处理。所以程序员需要手动处理，相对于<code>Timer</code>异常就直接费了调度系统来说，要好很多。</p>
<h4 id="Executors"><a href="#Executors" class="headerlink" title="Executors"></a>Executors</h4><p>除了以上三种创建方式，J.U.C 包中还提供了<code>Executors</code>工厂方法直接创建几种预设好的线程池，包括以下几类：</p>
<ul>
<li><code>newCachedThreadPool()</code><ul>
<li>缓存型线程池，先查看有没有以前建立的线程，如果有，就 reuse 如果没有，就建一个新的线程加入池中。</li>
<li>缓存型线程池通常用于执行一些生存期很短的异步型任务。</li>
<li>能 reuse 的线程，必须是<code>timeout IDLE</code>内的池中线程，缺省<code>timeout</code>是 60s,超过这个时长，线程实例将被终止及移出池。</li>
</ul>
</li>
<li><code>newFixedThreadPool(int)</code><ul>
<li>固定大小的线程池。</li>
<li>每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小。线程池的大小一旦达到最大值就会保持不变，在提交新任务，任务将会进入等待队列中等待。</li>
<li>如果某个线程因为执行异常而结束，那么线程池会补充一个新线程。</li>
</ul>
</li>
<li><code>newScheduledThreadPool(int)</code><ul>
<li>创建一个大小无限的线程池。此线程池支持定时以及周期性执行任务的需求。</li>
<li><code>newSingleThreadScheduledExecutor</code>也是类似的延迟任务线程池，只不过只是单线程执行。</li>
</ul>
</li>
<li><code>SingleThreadExecutor()</code><ul>
<li>一个单线程的线程池。这个线程池只有一个线程在工作，也就是相当于单线程串行执行所有任务。</li>
<li>如果唯一的线程因为异常结束，那么会有一个新的线程来替代它。此线程池保证所有任务的执行顺序按照任务的提交顺序执行。</li>
</ul>
</li>
<li><code>newWorkStealingPool()</code><ul>
<li>一个基于<code>Fork/Join</code>模型的线程池，内部通过<code>ForkJoinPool</code>创建。</li>
<li>用法跟<code>ForkJoinPool</code>一样，体现“分而治之” 的思想。</li>
</ul>
</li>
</ul>
<p>但是，虽然鼓励使用线程池而不是直接新建线程，但是在生产系统中不建议直接使用<code>Executors</code>创建的线程池，阿里巴巴Java手册中是这么解释的：</p>
<p><img src="http://nas.beritra.com:18081/uploads/big/55c4329c2c7069b9ad6ace96ee6a806e.png" alt=""></p>
<h2 id="并发集合"><a href="#并发集合" class="headerlink" title="并发集合"></a>并发集合</h2><h3 id="Map-系列"><a href="#Map-系列" class="headerlink" title="Map 系列"></a>Map 系列</h3><p>最知名也最常用<code>ConcurrentHashMap</code>本文就先不讲了，已经单独分析过，请参考那篇文章。</p>
<h3 id="ConcurrentSkipListMap"><a href="#ConcurrentSkipListMap" class="headerlink" title="ConcurrentSkipListMap"></a>ConcurrentSkipListMap</h3><p>Skip List（跳表）是一种可以代替平衡树的数据结构，默认是按照 Key 值升序的。Skip List 让已排序的数据分布在多层链表中，以 0-1 随机数决定一个数据的向上攀升与否，通过“空间来换取时间”的一个算法，在每个节点中增加了向前的指针，在插入、删除、查找时可以忽略一些不可能涉及到的结点，从而提高了效率。</p>
<p>简单介绍跳表的原理，这里盗用了博客<a href="https://juejin.im/post/5d9beab85188251d805f3f6c" target="_blank" rel="noopener">J.U.C 之 ConcurrentSkipListMap</a>上的解释：</p>
<p>我们先看一个简单的链表，如下：</p>
<p><img src="http://nas.beritra.com:18081/uploads/big/a34fe5c2c3cf419385068fc264deac54.jpeg" alt=""></p>
<p>如果我们需要查询9、21、30，则需要比较次数为3 + 6 + 8 = 17 次，那么有没有优化方案呢？有！我们将该链表中的某些元素提炼出来作为一个比较“索引”，如下：</p>
<p><img src="http://nas.beritra.com:18081/uploads/big/3c7d5a05c382cf73cae257e990813670.jpeg" alt=""></p>
<p>我们先与这些索引进行比较来决定下一个元素是往右还是下走，由于存在“索引”的缘故，导致在检索的时候会大大减少比较的次数。当然元素不是很多，很难体现出优势，当元素足够多的时候，这种索引结构就会大显身手。</p>
<p>当然，实际上 Skip List 的原理要更复杂，就不在这详细叙述了。</p>
<p>总之，跟<code>ConcurrentHashMap</code>相比，<code>ConcurrentSkipListMap</code>的key是有序的。有的文章提到<code>ConcurrentSkipListMap</code>支持更高的并发，线程越多性能越强，但是经过我实际测试，从 10 个线程到 100 个线程，无论<code>put</code>还是<code>get</code>，都没有快于<code>ConcurrentHashMap</code>，只有超过三百个线程之后，<code>put</code>操作会略微快一点点。</p>
<h3 id="CopyOnWrite-系列"><a href="#CopyOnWrite-系列" class="headerlink" title="CopyOnWrite 系列"></a>CopyOnWrite 系列</h3><p>CopyOnWrite，或者叫写入时复制，其实是一种策略，以下是维基百科的说明：</p>
<blockquote>
<p>其核心思想是，如果有多个调用者（callers）同时请求相同资源（如内存或磁盘上的数据存储），他们会共同获取相同的指针指向相同的资源，直到某个调用者试图修改资源的内容时，系统才会真正复制一份专用副本（private copy）给该调用者，而其他调用者所见到的最初的资源仍然保持不变。这过程对其他的调用者都是透明的（<a href="https://zh.wikipedia.org/w/index.php?title=Transparency_(computing)&action=edit&redlink=1" target="_blank" rel="noopener">transparently</a>）。</p>
</blockquote>
<p>通俗的理解是当我们往一个容器添加元素的时候，不直接往当前容器添加，而是先将当前容器进行 Copy，复制出一个新的容器，然后新的容器里添加元素，添加完元素之后，再将原容器的引用指向新的容器。这样做的好处是我们可以对 CopyOnWrite 容器进行并发的读，而不需要加锁，因为当前容器不会添加任何元素。所以 CopyOnWrite 容器也是一种读写分离的思想，读和写不同的容器。</p>
<p>J.U.C 包中提供了两个 CopyOnWrite 容器，分别是<code>CopyOnWriteArrayList</code>和<code>CopyOnWriteArraySet</code>。这两个的性质很相似，只不过在原本的 List 和 Set 上使用了 COW 的思想，而且<code>CopyOnWriteArraySet</code>的实现原理就是在内部维护了一个<code>CopyOnWriteArrayList</code>。</p>
<p>CopyOnWrite 并发容器用于读多写少的并发场景。比如白名单，黑名单，商品类目的访问和更新场景。</p>
<p><code>CopyOnWriteArrayList</code>容器的原理也不复杂，只是需要在<code>add</code>方法中加锁，添加完成之后用新的数组替代原有的数组，而<code>get</code>操作不需要加锁</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">synchronized</span> (lock) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Object[] es = getArray();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> len = es.length;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        es = Arrays.copyOf(es, len + <span class="number">1</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        es[len] = e;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        setArray(es);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>代码很简单，但是使用CopyOnWriteMap需要注意两件事情：</p>
<ol>
<li><p>减少扩容开销。根据实际需要，初始化<code>CopyOnWriteMap</code>的大小，避免写时<code>CopyOnWriteMap</code>扩容的开销。</p>
</li>
<li><p>使用批量添加。因为每次添加，容器每次都会进行复制，所以减少添加次数，可以减少容器的复制次数。</p>
</li>
</ol>
<p>CopyOnWrite 容器有很多优点，但是同时也存在两个问题，即内存占用问题和数据一致性问题。所以在开发的时候需要注意一下。</p>
<h3 id="Queue-系列"><a href="#Queue-系列" class="headerlink" title="Queue 系列"></a>Queue 系列</h3><p>从 J.U.C 的导图就可以看出，提供给我们最多的集合类就是队列，主要分为三个方面：<code>ConcurrentLinkedQueue</code>、<code>BlockingQueue</code>和<code>Deque</code></p>
<h4 id="ConcurrentLinkedQueue"><a href="#ConcurrentLinkedQueue" class="headerlink" title="ConcurrentLinkedQueue"></a>ConcurrentLinkedQueue</h4><p><code>ConcurrentLinkedQueue</code>底层使用单链表存储数据，增加了空的头尾节点，是非阻塞、无界的线程安全队列。它采用先进先出的规则对节点进行排序，当我们添加一个元素的时候，它会添加到队列的尾部，当我们获取一个元素时，它会返回队列头部的元素。由于是无界队列，所以<code>add()</code>和<code>offer()</code>方法没有区别，都不会抛出异常。</p>
<p>跟线程不安全的队列比如<code>PriorityQueue</code>相比，由于数据存储是链表而不是数组，因此没有并发扩容的问题，但是入队出队是通过 CAS 实现的，大并发下有可能有效率问题，而且遍历的时候数据不是准确的。</p>
<p>BlockingQueue</p>
<p><code>BlockingQueue</code>是一个接口，定义了阻塞队列的基本方法，J.U.C 包中有多个该接口的实现类。定义的常用方法如下：</p>
<p><img src="http://nas.beritra.com:18081/uploads/medium/36bf52c412ece67796ff2ab27c24bba5.png" alt=""></p>
<p><code>BlockingQueue</code>的特点：</p>
<ol>
<li><code>BlockingQueue</code>可以是限定容量的。它在任意给定时间都可以有一个<code>remainingCapacity</code>，超出此容量，便无法无阻塞地<code>put</code>附加元素。没有任何内部容量约束的<code>BlockingQueue</code>总是报告<code>Integer.MAX_VALUE</code>的剩余容量。</li>
<li><code>BlockingQueue</code>实现主要用于生产者-使用者队列，但它另外还支持<code>Collection</code>接口。因此，举例来说，使用<code>remove(x)</code>从队列中移除任意一个元素是有可能的。然而，这种操作通常不会有效执行，只能有计划地偶尔使用，比如在取消排队信息时。</li>
<li><code>BlockingQueue</code>实现是线程安全的。所有排队方法都可以使用内部锁或其他形式的并发控制来自动达到它们的目的。然而，大量的<code>Collection</code>操作（<code>addAll</code>、<code>containsAll</code>、<code>retainAll</code> 和<code>removeAll</code>）没有 必要自动执行，除非在实现中特别说明。因此，举例来说，在只添加了<code>c</code>中的一些元素后，<code>addAll(c)</code>有可能失败（抛出一个异常）。</li>
<li><code>BlockingQueue</code>实质上不 支持使用任何一种“close”或“shutdown”操作来指示不再添加任何项。这种功能的需求和使用有依赖于实现的倾向。例如，一种常用的策略是：对于生产者，插入特殊的 end-of-stream 或 Poison 对象，并根据使用者获取这些对象的时间来对它们进行解释。</li>
</ol>
<p><code>BlockingQueue</code>的实现类：</p>
<p><img src="http://nas.beritra.com:18081/uploads/medium/a73ab20cdf64b55d77e2cd7364602d54.png" alt=""></p>
<ol>
<li>BlockingDeque：阻塞的双端队列，<code>LinkedBlockingDeque</code>是其基于链表的实现类，如果没有设置容量，那么容量将是Int的最大值。<code>LinkedBlockingQueue</code>可以同时有两个线程在两端执行操作，这点与<code>LinkedBlockingQeque</code>不同。</li>
<li>TransferQueue：基于队列扩展的一种有趣的生产-消费者模型，其实现类是<code>BlockingTransferQueue</code>，能够实现元素在线程之间的传递。</li>
<li>SynchronousQueue：跟<code>TransferQueue</code>很类似，线程 A 通过<code>put</code>方法存入数据到队列中，如果没有别的线程通过<code>take</code>方法去获取这个数据，那线程 A 进入阻塞状态；当有别的线程获取了这个值之后，线程 A 就恢复执行。这个特点跟TransferQueue很像，<a href="http://cs.oswego.edu/pipermail/concurrency-interest/2009-February/005888.html" target="_blank" rel="noopener">Doug Lea说</a>从功能角度来讲，<code>LinkedTransferQueue</code>实际上是<code>ConcurrentLinkedQueue</code>、<code>SynchronousQueue</code>（公平模式）和<code>LinkedBlockingQueue</code>的超集。而且<code>LinkedTransferQueue</code>更好用，因为它不仅仅综合了这几个类的功能，同时也提供了更高效的实现。所以<code>SynchronousQueue</code>的使用场景就很少了。</li>
<li>PriorityBlokcingQueue：可以理解成<code>PriorityQueue</code>的线程安全版本，基于优先堆的一个无界队列。不允许 null 值，不允许不可比较的对象。</li>
<li>DelayQueue：一个有趣的延迟队列，它的特殊之处在于队列的元素必须实现<code>Delayed</code>接口，该接口需要实现<code>compareTo</code>和<code>getDelay</code>方法。这个在下面用法里再详细介绍。</li>
<li>ArrayBlockingQueue：基于数组的有界阻塞队列，必须指定大小。</li>
<li>LinkedBlockingQueue：基于链表的有界阻塞队列，可以不指定队列大小，默认是<code>Integer.MAX_VALUE</code></li>
</ol>
<h4 id="ArrayBlockingQueue-和-LinkedBlockingQueue"><a href="#ArrayBlockingQueue-和-LinkedBlockingQueue" class="headerlink" title="ArrayBlockingQueue 和 LinkedBlockingQueue"></a>ArrayBlockingQueue 和 LinkedBlockingQueue</h4><p>由于这两个类的相关性，就放在一起说。同样是阻塞的有界队列，使用方法也基本一致，就着重说明两者间的区别：</p>
<ol>
<li><p>队列中锁的实现不同</p>
<p><code>ArrayBlockingQueue</code>实现的队列中的锁是没有分离的，即生产和消费用的是同一个锁，但是两个条件</p>
<p><code>LinkedBlockingQueue</code>实现的队列中的锁是分离的，即生产用的是<code>putLock</code>，消费是<code>takeLock</code></p>
</li>
<li><p>在生产或消费时操作不同</p>
<p><code>ArrayBlockingQueue</code>实现的队列中在生产和消费的时候，是直接将枚举对象插入或移除的</p>
<p><code>LinkedBlockingQueue</code>实现的队列中在生产和消费的时候，需要把枚举对象转换为<code>Node&lt;E&gt;</code>进行插入或移除，会影响性能</p>
</li>
<li><p>队列大小初始化方式不同</p>
<p><code>ArrayBlockingQueue</code>实现的队列中必须指定队列的大小</p>
<p><code>LinkedBlockingQueue</code>实现的队列中可以不指定队列的大小，但是默认是<code>Integer.MAX_VALUE</code></p>
</li>
</ol>
<p>为了对两个队列的效率有个更直观的认识，我进行了一个简单的测试，对一千万的数据量进行操作，首先是单线程存，然后单线程取：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">blockingQueueBench</span><span class="params">(BlockingQueue&lt;Integer&gt; queue)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> count = <span class="number">1000</span> * <span class="number">10000</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">long</span> timestamp = System.currentTimeMillis();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            queue.put(i);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            e.printStackTrace();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    System.out.println(System.currentTimeMillis() - timestamp);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    timestamp = System.currentTimeMillis();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            queue.take();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            e.printStackTrace();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    System.out.println(System.currentTimeMillis() - timestamp);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>然后分别对比两个队列存和取的效率：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> QueueTest().blockingQueueBench(<span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;(<span class="number">10000000</span>));</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//结果存1909毫秒，取196毫秒</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> QueueTest().blockingQueueBench(<span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">10000000</span>));</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//结果存237毫秒，取135毫秒</span></span></pre></td></tr></table></figure>

<p>然后是两个线程，一个存一个取：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">blockingQueueBench</span><span class="params">(BlockingQueue&lt;Integer&gt; queue)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> count = <span class="number">1000</span> * <span class="number">10000</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">long</span> timestamp = System.currentTimeMillis();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            queue.put(i);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            e.printStackTrace();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Thread thread = <span class="keyword">new</span> Thread(() -&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                queue.take();</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                e.printStackTrace();</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    thread.start();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        thread.join();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        e.printStackTrace();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    System.out.println(System.currentTimeMillis() - timestamp);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>然后看存取都完成的时间，<code>LinkedBlockingQueue</code>是 2141 毫秒，<code>ArrayBlockingQueue</code>是 370 毫秒。单线程的情况下，无论如何<code>ArrayBlockingQueue</code>都是要快的。</p>
<p>同样的，我测试了 10 线程和 100 线程下的效率，总的数据量也是一千万。也是分为先存后取和同时存取。结果如下</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">LinkedBlockingQueue</th>
<th align="center">ArrayBlockingQueue</th>
</tr>
</thead>
<tbody><tr>
<td align="center">10 线程先存后取</td>
<td align="center">存2147ms 取624ms</td>
<td align="center">存466ms 取339ms</td>
</tr>
<tr>
<td align="center">10 线程同时存取</td>
<td align="center">1974ms</td>
<td align="center">724ms</td>
</tr>
<tr>
<td align="center">100 线程先存后取</td>
<td align="center">存2347ms 取1040ms</td>
<td align="center">存464ms 取306ms</td>
</tr>
<tr>
<td align="center">100 线程同时存取</td>
<td align="center">1957ms</td>
<td align="center">976ms</td>
</tr>
</tbody></table>
<p>代码基于下面这个，稍有改动：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">blockingQueueMultiBench</span><span class="params">(BlockingQueue&lt;Integer&gt; queue, <span class="keyword">int</span> threadNum)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> count = <span class="number">1000</span> * <span class="number">10000</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">long</span> timestamp = System.currentTimeMillis();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(threadNum);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threadNum; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; count / threadNum; j++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    queue.put(j);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    e.printStackTrace();</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            latch.countDown();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;).start();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        latch.await();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        e.printStackTrace();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    System.out.println(System.currentTimeMillis() - timestamp);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    CountDownLatch latch2 = <span class="keyword">new</span> CountDownLatch(threadNum);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    timestamp = System.currentTimeMillis();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threadNum; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; count / threadNum; j++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    queue.take();</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    e.printStackTrace();</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            latch2.countDown();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;).start();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">        latch2.await();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        e.printStackTrace();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    System.out.println(System.currentTimeMillis() - timestamp);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>可以看出，对于效率来讲大多数时候用<code>ArrayBlockingQueue</code>比较合适。</p>
<h4 id="BlockingDeque"><a href="#BlockingDeque" class="headerlink" title="BlockingDeque"></a>BlockingDeque</h4><p>就跟 Queue 与 Deque 的区别一样，<code>BlockingDeque</code>只是单端队列变成了双端队列，添加了在两端存取元素的方法。比如<code>Quque</code>原本的<code>offer、poll、put、take</code>等方法，都扩展了<code>offerFirst、offerLast</code>等等在对首位元素分别进行操作的方法。内部使用<code>ReentrantLock</code>保证了线程安全，其他没有什么特殊之处，就不详细讲了。</p>
<h4 id="TransferQueue-和-SynchronousQueue"><a href="#TransferQueue-和-SynchronousQueue" class="headerlink" title="TransferQueue 和 SynchronousQueue"></a>TransferQueue 和 SynchronousQueue</h4><p>这两个也是性质非常相似的队列，用法也基本一样，主要用于不同线程一对一的传递数据。<a href="http://cs.oswego.edu/pipermail/concurrency-interest/2009-February/005888.html" target="_blank" rel="noopener">Doug Lea说</a>从功能角度来讲，<code>LinkedTransferQueue</code>实际上是<code>ConcurrentLinkedQueue</code>、<code>SynchronousQueue</code>（公平模式）和<code>LinkedBlockingQueue</code>的超集。而且<code>LinkedTransferQueue</code>更好用，因为它不仅仅综合了这几个类的功能，同时也提供了更高效的实现。所以我们就尽量使用<code>LinkedTransferQueue</code>吧。</p>
<p><code>TransferQueue</code>的<code>transfer()</code>方法是这样，一次只能传递一个东西过去，如果上次穿的没有被消费掉，新的方法就就会阻塞。同样的，<code>SynchronousQueue</code>的<code>put()</code>方法也是一样。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testTransferQueue</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    LinkedTransferQueue&lt;Integer&gt; transferQueue = <span class="keyword">new</span> LinkedTransferQueue&lt;&gt;();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                System.out.println(transferQueue.take());</span></pre></td></tr><tr><td class="code"><pre><span class="line">                Thread.sleep(<span class="number">1000</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            e.printStackTrace();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;).start();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        transferQueue.transfer(<span class="number">1</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        transferQueue.transfer(<span class="number">2</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        transferQueue.transfer(<span class="number">3</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        e.printStackTrace();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>从这个示例中可以看出，虽然三行<code>transfer</code>方法是连续的，但是在<code>take</code>方法取走之前的元素之前是阻塞的。另外还有个有趣的地方，由于内部没有维护容器，所以<code>LinkedTransferQueue</code>的<code>size()</code>方法和迭代器都是没有意义的。</p>
<h4 id="PriorityBlockingQueue"><a href="#PriorityBlockingQueue" class="headerlink" title="PriorityBlockingQueue"></a>PriorityBlockingQueue</h4><p>是线程安全阻塞版本的<code>PriorityQueue</code>，对比<code>PriorityQueue</code>而言在存取删除元素和扩容的时候都有<code>ReentrantLock</code>锁，所以实现了线程安全。元素为空的时候再取元素会阻塞。有内部结构是基于完全二叉树的小顶堆，所以不允许 null 值，不允许不可比较的对象。</p>
<h4 id="DelayQueue"><a href="#DelayQueue" class="headerlink" title="DelayQueue"></a>DelayQueue</h4><p><code>DelayQueue</code>是一个延迟队列，想要用它存取元素，必须实现<code>Delayed</code>接口，可以看出其定义如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DelayQueue</span>&lt;<span class="title">E</span> <span class="keyword">extends</span> <span class="title">Delayed</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">BlockingQueue</span>&lt;<span class="title">E</span>&gt;</span></span></pre></td></tr></table></figure>

<p>而<code>Delayed</code>接口继承自<code>Comparable</code>，所以其实现类需要实现<code>getDelay</code>和<code>compareTo</code>方法。</p>
<p><code>getDelay</code>方法是这样的：当返回值小于 0 的时候，该元素才能被取出。我们创建一个实现类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDelayed</span> <span class="keyword">implements</span> <span class="title">Delayed</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">     <span class="keyword">int</span> num;</span></pre></td></tr><tr><td class="code"><pre><span class="line">     <span class="keyword">long</span> time;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">     <span class="function"><span class="keyword">public</span> <span class="title">TestDelayed</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">     &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">     <span class="function"><span class="keyword">public</span> <span class="title">TestDelayed</span><span class="params">(<span class="keyword">int</span> num, <span class="keyword">int</span> delay)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">         <span class="keyword">this</span>.num = num;</span></pre></td></tr><tr><td class="code"><pre><span class="line">         <span class="keyword">this</span>.time = System.currentTimeMillis() + delay;</span></pre></td></tr><tr><td class="code"><pre><span class="line">     &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">     <span class="meta">@Override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getDelay</span><span class="params">(TimeUnit unit)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">         <span class="keyword">return</span> time - System.currentTimeMillis();</span></pre></td></tr><tr><td class="code"><pre><span class="line">     &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">     <span class="meta">@Override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Delayed o)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">         <span class="keyword">return</span> Long.compare(getDelay(TimeUnit.SECONDS), o.getDelay(TimeUnit.SECONDS));</span></pre></td></tr><tr><td class="code"><pre><span class="line">     &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"> &#125;</span></pre></td></tr></table></figure>

<p>这个类的作用就是在指定的时间之后取回元素，时间单位是毫秒，然后进行测试：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testDelayQueue</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    DelayQueue&lt;TestDelayed&gt; delayQueue = <span class="keyword">new</span> DelayQueue&lt;&gt;();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">int</span> num = delayQueue.take().num;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                System.out.println(System.currentTimeMillis() + <span class="string">",take:"</span> + num);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            e.printStackTrace();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;).start();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    delayQueue.put(<span class="keyword">new</span> TestDelayed(<span class="number">1</span>, <span class="number">1000</span>));</span></pre></td></tr><tr><td class="code"><pre><span class="line">    delayQueue.put(<span class="keyword">new</span> TestDelayed(<span class="number">2</span>, <span class="number">2000</span>));</span></pre></td></tr><tr><td class="code"><pre><span class="line">    delayQueue.put(<span class="keyword">new</span> TestDelayed(<span class="number">6</span>, <span class="number">6000</span>));</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>可以看出，三个元素分别在第一秒、第二秒和第六秒被取出，然后线程阻塞等待取回下一个元素。</p>
<h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><p>并法包中的接口有<code>Lock</code>、<code>ReadWriteLock</code>、<code>Condition</code>、<code>LockSupport</code>等。</p>
<p>Lock 接口和其实现类<code>ReentrantLock</code>已经专门讲过，就不赘述。我们先看看读写锁的用法。</p>
<h3 id="ReadWriteLock"><a href="#ReadWriteLock" class="headerlink" title="ReadWriteLock"></a>ReadWriteLock</h3><p>该接口只有两个方法，读锁和写锁。也就是说，我们在写文件的时候，可以将读和写分开，分成 2 个锁来分配给线程，从而可以做到读和读互不影响，读和写互斥，写和写互斥，提高读写文件的效率。该接口也有一个实现类<code>ReentrantReadWriteLock</code>，下面我们就来学习下这个类。</p>
<p>读写锁的用法很简单，以<code>ReentrantReadWriteLock</code>为例，使用<code>lock.writeLock()</code>和<code>lock.readLock()</code>分别创建锁对象。我们编写一个测试类来验证读写锁的互斥逻辑，先写两个方法，线程休眠来模拟耗时的读写操作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    System.out.println(Thread.currentThread().getName() + <span class="string">"正在进行读操作"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Thread.sleep(<span class="number">1000</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        e.printStackTrace();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    System.out.println(Thread.currentThread().getName() + <span class="string">"读操作完毕"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    System.out.println(Thread.currentThread().getName() + <span class="string">"正在进行写操作"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Thread.sleep(<span class="number">1000</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        e.printStackTrace();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    System.out.println(Thread.currentThread().getName() + <span class="string">"写操作完毕"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>然后分别创建读写锁，然后进行 5 线程同时读、同时写、同时读写等等操作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ReadWriteLock lock = <span class="keyword">new</span> ReentrantReadWriteLock();</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">Lock writeLock = lock.writeLock();</span></pre></td></tr><tr><td class="code"><pre><span class="line">Lock readLock = lock.readLock();</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        readLock.lock();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        lockTest.read();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        readLock.unlock();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;).start();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        writeLock.lock();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        lockTest.write();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        writeLock.unlock();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;).start();</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>可以看出，读锁加锁之后，可以同时进行读操作，但是写锁加锁之后不能同时写。而读写互相之间也是互斥的，不能在读的同时写。</p>
<h3 id="Condition"><a href="#Condition" class="headerlink" title="Condition"></a>Condition</h3><p><code>Condition</code>是在 Java 1.5 中才出现的，它用来替代传统的<code>wait()</code>、<code>notify()</code>实现线程间的协作，相比使用<code>Object</code>的<code>wait()</code>、<code>notify()</code>，使用<code>Condition</code>的<code>await()</code>、<code>signal()</code>这种方式实现线间协作更加安全和高效。因此通常来说比较推荐使用<code>Condition</code>，阻塞队列实际上是使用了<code>Condition</code>来模拟线程间协作。</p>
<p><code>Condition</code>是与<code>Lock</code>绑定的，所以就有<code>Lock</code>的公平性特性：如果是公平锁，线程为按照 FIFO 的顺序从<code>Condition.await</code>中释放，如果是非公平锁，那么后续的锁竞争就不保证 FIFO 顺序了。</p>
<p>调用<code>Condition</code>的<code>await()</code>和<code>signal()</code>方法，都必须在持有锁，就是说必须在<code>lock.lock()</code>和<code>lock.unlock</code>之间才可以使用。</p>
<p>一个简单的示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Lock lock = <span class="keyword">new</span> ReentrantLock();</span></pre></td></tr><tr><td class="code"><pre><span class="line">     Condition condition1 = lock.newCondition();</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">     <span class="keyword">new</span> Thread(() -&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">         <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">             lock.lock();</span></pre></td></tr><tr><td class="code"><pre><span class="line">             condition1.await();</span></pre></td></tr><tr><td class="code"><pre><span class="line">             lock.unlock();</span></pre></td></tr><tr><td class="code"><pre><span class="line">             System.out.println(Thread.currentThread().getName() + <span class="string">"被唤醒"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">         &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">             e.printStackTrace();</span></pre></td></tr><tr><td class="code"><pre><span class="line">         &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">     &#125;).start();</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">     <span class="keyword">new</span> Thread(() -&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">         <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">             Thread.sleep(<span class="number">2000</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">             System.out.println(Thread.currentThread().getName() + <span class="string">"开始唤醒"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">         &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">             e.printStackTrace();</span></pre></td></tr><tr><td class="code"><pre><span class="line">         &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">         lock.lock();</span></pre></td></tr><tr><td class="code"><pre><span class="line">         condition1.signalAll();</span></pre></td></tr><tr><td class="code"><pre><span class="line">         lock.unlock();</span></pre></td></tr><tr><td class="code"><pre><span class="line">     &#125;).start();</span></pre></td></tr></table></figure>



<h3 id="LockSupport"><a href="#LockSupport" class="headerlink" title="LockSupport"></a>LockSupport</h3><p>在之前介绍 AQS 的底层实现，已经在介绍 Java 中的 Lock 时，比如<code>ReentrantLock</code>，<code>ReentReadWriteLocks</code>，已经在介绍线程间等待/通知机制使用的 Condition 时都会调用<code>LockSupport.park()</code>方法和<code>LockSupport.unpark()</code>方法。<br>LockSupport 主要有以下几个方法：</p>
<ol>
<li><code>void park()</code>：阻塞当前线程，如果调用<code>unpark</code>方法或者当前线程被中断，从能从<code>park()</code>方法中返回 </li>
<li><code>void park(Object blocker)</code>：功能同方法 1，入参增加一个<code>Object</code>对象，用来记录导致线程阻塞的阻塞对象，方便进行问题排查；</li>
<li><code>void parkNanos(long nanos)</code>：阻塞当前线程，最长不超过<code>nanos</code>纳秒，增加了超时返回的特性；</li>
<li><code>void parkNanos(Object blocker, long nanos)</code>：功能同方法 3，入参增加一个 Object 对象，用来记录导致线程阻塞的阻塞对象，方便进行问题排查；</li>
<li><code>void parkUntil(long deadline)</code>：阻塞当前线程， 直到 deadline；</li>
<li><code>void parkUntil(Object blocker, long deadline</code>：功能同方法 5，入参增加一个<code>Object</code>对象，用来记录导致线程阻塞的阻塞对象，方便进行问题排查；</li>
<li><code>Object getBlocker(Thread t)</code>：获取线程<code>park</code>入参的对象。</li>
</ol>
<p>注意，LockSupport 是<strong>不可重入</strong>的，如果一个线程连续 2 次调用<code>LockSupport.park()</code>，那么该线程一定会一直阻塞下去。</p>
<p>LockSupport 很类似于二元信号量(只有 1 个许可证可供使用)，如果这个许可还没有被占用，当前线程获取许可并继续执行；如果许可已经被占用，当前线程阻塞，等待获取许可。</p>
<p>比如我们写一个最简单的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LockSupport.park();</span></pre></td></tr><tr><td class="code"><pre><span class="line">System.out.println(<span class="string">"xxx"</span>);</span></pre></td></tr></table></figure>

<p>线程会被阻塞，因为许可默认是被占用的，相当于许可证为 0，线程阻塞等待直到许可证为 1。</p>
<p>而我们可以先<code>unpark</code>，释放一个许可，相当于把许可证添加为 1：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread thread = Thread.currentThread();</span></pre></td></tr><tr><td class="code"><pre><span class="line">LockSupport.unpark(thread);</span></pre></td></tr><tr><td class="code"><pre><span class="line">LockSupport.park();<span class="comment">// 获取许可</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">System.out.println(<span class="string">"xxx"</span>);</span></pre></td></tr></table></figure>

<p>这次就不阻塞，正常执行了。</p>
<h2 id="原子类"><a href="#原子类" class="headerlink" title="原子类"></a>原子类</h2><p>J.U.C 包中的原子类可以分为五类：</p>
<ul>
<li>基本类型：AtomicBoolean、AtomicInteger、AtomicLong</li>
<li>引用类型：AtomicReference、AtomicStampedRerence、AtomicMarkableReference</li>
<li>数组：AtomicIntegerArray、AtomicLongArray、AtomicReferenceArray</li>
<li>对象的属性：AtomicIntegerFieldUpdater、AtomicLongFieldUpdater、AtomicReferenceFieldUpdater</li>
<li>JDK1.8新增：DoubleAccumulator、LongAccumulator、DoubleAdder、LongAdder</li>
</ul>
<p><code>AtomicBoolean</code>、<code>AtomicInteger</code>、<code>AtomicLong</code>和<code>AtomicReference</code>的实例各自提供对相应类型单个变量的原子方式访问和更新功能。例如<code>AtomicBoolean</code>提供对 int 类型单个变量的原子方式访问和更新功能。每个类也为该类型提供适当的实用工具方法。例如，类<code>AtomicLong</code>和<code>AtomicInteger</code>提供了原子增量方法，可以用于生成序列号。</p>
<p><code>AtomicStampedRerence</code>维护带有整数“标志”的对象引用，可以用原子方式对其进行更新。<code>AtomicMarkableReference</code>维护带有标记位的对象引用，可以原子方式对其进行更新。</p>
<p><code>AtomicIntegerArray</code>、<code>AtomicLongArray</code>和<code>AtomicReferenceArray</code>类进一步扩展了原子操作，对这些类型的数组提供了支持。例如<code>AtomicIntegerArray</code>是可以用原子方式更新其元素的 int 数组。</p>
<p><code>AtomicReferenceFieldUpdater</code>、<code>AtomicIntegerFieldUpdater</code>和<code>AtomicLongFieldUpdater</code>是基于反射的实用工具，可以提供对关联字段类型的访问。例如<code>AtomicIntegerFieldUpdater</code>可以对指定类的指定<code>volatile int</code>字段进行原子更新。</p>
<p><code>DoubleAccumulator</code>、<code>LongAccumulator</code>、<code>DoubleAdder</code>、<code>LongAdder</code>是 JDK1.8 新增的部分，是对<code>AtomicLong</code>等类的改进。比如<code>LongAccumulator</code>与<code>LongAdder</code>在高并发环境下比<code>AtomicLong</code>更高效。</p>
<p>参考文章：</p>
<p><a href="https://juejin.im/post/5aeb07ab6fb9a07ac36350c8" target="_blank" rel="noopener">深入理解AbstractQueuedSynchronizer(AQS)</a></p>
<p><a href="https://mingshan.fun/2019/01/25/aqs-exclusive/" target="_blank" rel="noopener">AQS源码分析</a></p>
<p><a href="https://www.jianshu.com/p/63246a750e35" target="_blank" rel="noopener">JAVA进阶之AQS</a></p>
<p><a href="https://juejin.im/post/5ae755606fb9a07ab97942a4" target="_blank" rel="noopener">并发编程——详解 AQS CLH 锁</a></p>
<p><a href="https://blog.csdn.net/vernonzheng/article/details/8247564" target="_blank" rel="noopener">Java多线程（五）之BlockingQueue深入分析</a></p>
<p><a href="https://blog.csdn.net/panweiwei1994/article/details/78646390" target="_blank" rel="noopener">Java并发编程札记-(三)JUC原子类-01概述</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>AQS原理解析</title>
    <url>/2020/03/23/AQS%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<p><code>AbstractQueuedSynchronizer</code>，可以叫做抽象队列同步器，可以说是 J.U.C 并发包里大多数工具的基石，并发包里的几个工具类，还有包括之前已经分析过得<code>ReentrantLock</code>统统是基于该同步器所设立的框架。 就让我们看看这个东西到底有什么精巧的设计。</p>
<a id="more"></a>

<p>AQS 实现了对同步状态的管理，以及对阻塞线程进行排队、等待通知等等一些底层的实现处理。AQS 的核心也包括了这些方面：同步队列，独占式锁的获取和释放，共享锁的获取和释放以及可中断锁，超时等待锁获取这些特性的实现，这些实际上是AQS提供出来的模板方法。AQS 是一个抽象类，当我们继承 AQS 去实现自己的同步器时，要做的仅仅是根据自己同步器需要满足的性质实现线程获取和释放资源的方式（修改同步状态变量的方式）即可，至于具体线程等待队列的维护（如获取资源失败入队、唤醒出队、以及线程在队列中行为的管理等），AQS 在其顶层已经帮我们实现好了，AQS 的这种设计使用的正是模板方法模式。</p>
<p>AQS 支持两种模式：</p>
<ul>
<li>独占模式（exclusive mode）：同一时刻只允许一个线程访问共享资源，如<code>ReentrantLock</code>等<ul>
<li>公平模式：获取锁失败的线程需要按照顺序排列，前面的先拿到锁</li>
<li>非公平模式： 当线程需要获取锁时，会尝试直接获取锁</li>
</ul>
</li>
<li>共享模式（shared mode）：同一时刻允多个线程访问共享资源</li>
</ul>
<p>AQS 使用了 CLH 内部队列，也叫 CLH 锁。这个 CLH 听起来很厉害的样子，实际上是三位创作者的名字简称：<code>Craig, Landin, and Hagersten</code>。CLH 锁是基于链表的可扩展、高性能、公平的自旋锁，申请线程只在本地变量上自旋，它不断轮询前驱的状态，如果发现前驱释放了锁就结束自旋。</p>
<p>AQS 维护了一个内部类，包括以下内容：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Node SHARED = <span class="keyword">new</span> Node();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Node EXCLUSIVE = <span class="keyword">null</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED =  <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIGNAL    = -<span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CONDITION = -<span class="number">2</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PROPAGATE = -<span class="number">3</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> waitStatus;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">volatile</span> Node prev;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">volatile</span> Node next;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">volatile</span> Thread thread;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    Node nextWaiter;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isShared</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> nextWaiter == SHARED;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">final</span> Node <span class="title">predecessor</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Node p = prev;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">else</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span> p;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    Node() &#123;    <span class="comment">// Used to establish initial head or SHARED marker</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">/** Constructor used by addWaiter. */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    Node(Node nextWaiter) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">this</span>.nextWaiter = nextWaiter;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        THREAD.set(<span class="keyword">this</span>, Thread.currentThread());</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">/** Constructor used by addConditionWaiter. */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    Node(<span class="keyword">int</span> waitStatus) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        WAITSTATUS.set(<span class="keyword">this</span>, waitStatus);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        THREAD.set(<span class="keyword">this</span>, Thread.currentThread());</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">/** CASes waitStatus field. */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSetWaitStatus</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> WAITSTATUS.compareAndSet(<span class="keyword">this</span>, expect, update);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">/** CASes next field. */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSetNext</span><span class="params">(Node expect, Node update)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> NEXT.compareAndSet(<span class="keyword">this</span>, expect, update);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setPrevRelaxed</span><span class="params">(Node p)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        PREV.set(<span class="keyword">this</span>, p);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// VarHandle mechanics</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> VarHandle NEXT;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> VarHandle PREV;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> VarHandle THREAD;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> VarHandle WAITSTATUS;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">static</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            MethodHandles.Lookup l = MethodHandles.lookup();</span></pre></td></tr><tr><td class="code"><pre><span class="line">            NEXT = l.findVarHandle(Node.class, "next", Node.class);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            PREV = l.findVarHandle(Node.class, "prev", Node.class);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            THREAD = l.findVarHandle(Node.class, "thread", Thread.class);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            WAITSTATUS = l.findVarHandle(Node.class, "waitStatus", int.class);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; <span class="keyword">catch</span> (ReflectiveOperationException e) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ExceptionInInitializerError(e);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>可以看出，该内部类是一个双向链表，保存前后节点，然后每个节点存储了当前的状态<code>waitStatus</code>、当前线程<code>thread</code>，还可以通过<code>SHARED</code>和<code>EXCLUSIVE</code>两个变量定义为共享模式或者独占模式，通过下面的方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 标识当前节点在共享模式</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Node SHARED = <span class="keyword">new</span> Node();</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 标识当前节点在独占模式</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Node EXCLUSIVE = <span class="keyword">null</span>;</span></pre></td></tr></table></figure>

<p>然后定义了四个常量：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CANCELLED，值为1，表示当前的线程被取消；</span></pre></td></tr><tr><td class="code"><pre><span class="line">SIGNAL，值为-1，表示当前节点的后继节点包含的线程需要运行，也就是unpark；</span></pre></td></tr><tr><td class="code"><pre><span class="line">CONDITION，值为-2，表示当前节点在等待condition，也就是在condition队列中；</span></pre></td></tr><tr><td class="code"><pre><span class="line">PROPAGATE，值为-3，表示当前场景下后续的acquireShared能够得以执行； </span></pre></td></tr><tr><td class="code"><pre><span class="line">默认值为0，表示当前节点在sync队列中，等待着获取锁。</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">waitStatus 表当前节点的状态值，取值为上面的四个常量。</span></pre></td></tr></table></figure>

<h3 id="独占模式"><a href="#独占模式" class="headerlink" title="独占模式"></a>独占模式</h3><p>首先我们来分析互斥模式，互斥模式作为最常用的模式使用范围很广，比如ReentrantLock，加锁和释放锁就是使用互斥模式来实现的。</p>
<p>独占模式中核心加锁方法是<code>acquire()</code>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span></pre></td></tr><tr><td class="code"><pre><span class="line">        selfInterrupt();</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>其中<code>tryAcquire()</code>方法是没有具体实现的，需要继承者自己实现。<code>tryAcquire()</code>方法返回成功或者失败，如果失败之后先执行<code>addWaiter()</code>添加一个独占式的节点:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * Creates and enqueues node for current thread and given mode.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> *</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * <span class="doctag">@param</span> mode Node.EXCLUSIVE for exclusive, Node.SHARED for shared</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * <span class="doctag">@return</span> the new node</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Node node = <span class="keyword">new</span> Node(mode);<span class="comment">//创建一个节点，此处mode是独占式的。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (;;) &#123;<span class="comment">//注意这里是循环</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        Node oldTail = tail;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (oldTail != <span class="keyword">null</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            node.setPrevRelaxed(oldTail);<span class="comment">// 如果 tail 节点不是 null，就将新节点(node)的前节点设置为 tail 节点，并且将新节点(node)设置成 tail 节点。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (compareAndSetTail(oldTail, node)) &#123;<span class="comment">//CAS 将 tail 更新为新节点(node)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                oldTail.next = node;<span class="comment">//把原 tail 的 next 设为 node。至此，完成了把新节点 node 插入到原来尾节点的后面，并设置成新的尾节点。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">return</span> node;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            initializeSyncQueue();<span class="comment">//还没有初始化，就调用 initializeSyncQueue() 方法</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p><code>initializeSyncQueue()</code>方法也很简单，就是初始化头结点和尾节点：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * Initializes head and tail fields on first contention.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">initializeSyncQueue</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Node h;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (HEAD.compareAndSet(<span class="keyword">this</span>, <span class="keyword">null</span>, (h = <span class="keyword">new</span> Node())))</span></pre></td></tr><tr><td class="code"><pre><span class="line">        tail = h;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>至此，我们添加了一个新的节点到原来的队列，并且把新加入的节点设置成了尾节点。然后看<code>acquireQueue()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * Acquires in exclusive uninterruptible mode for thread already in</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * queue. Used by condition wait methods as well as acquire.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> *</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * <span class="doctag">@param</span> node the node</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * <span class="doctag">@param</span> arg the acquire argument</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if interrupted while waiting</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> (;;) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                setHead(node);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">return</span> interrupted;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node))</span></pre></td></tr><tr><td class="code"><pre><span class="line">                interrupted |= parkAndCheckInterrupt();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        cancelAcquire(node);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (interrupted)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            selfInterrupt();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">throw</span> t;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p><code>shouldParkAfterFailedAcquire()</code>（注意该方法是在循环里面） 这个方法最终会返回<code>true</code>或者<code>false</code>，从这个方法的名称可以看出，该方法的作用是在当前线程获取资源失败后是否挂起当前线程，显然：</p>
<ul>
<li>返回<code>true</code>，说明前驱节点的<code>waitStatus==-1</code>，是正常情况，那么当前线程需要被挂起，等待以后被唤醒。当前节点是被前驱节点唤醒，就等着前驱节点拿到锁，然后释放锁的时候通知当前线程</li>
<li>返回<code>false</code>，说明当前线程不需要被挂起，因为不符合挂起的条件。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * Checks and updates status for a node that failed to acquire.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * Returns true if thread should block. This is the main signal</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * control in all acquire loops.  Requires that pred == node.prev.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> *</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * <span class="doctag">@param</span> pred node's predecessor holding status</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * <span class="doctag">@param</span> node the node</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if thread should block</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> ws = pred.waitStatus;<span class="comment">//ws是代表前节点的状态</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (ws == Node.SIGNAL)<span class="comment">//前节点状态是等待唤醒状态，那么当前线程需要被挂起，等待以后被唤醒。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">/*</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">         * This node has already set status asking a release</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">         * to signal it, so it can safely park.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">         */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;<span class="comment">//前节点状态是 CANCEL，代表可以忽略，我们删除掉这个节点，再看更前面的一个。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">/*</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">         * Predecessor was cancelled. Skip over predecessors and</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">         * indicate retry.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">         */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">do</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            node.prev = pred = pred.prev;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        pred.next = node;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">//前节点状态是0 或者 PROPAGATE，把状态改成 SIGNAL，但是不挂起。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">/*</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">         * waitStatus must be 0 or PROPAGATE.  Indicate that we</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">         * need a signal, but don't park yet.  Caller will need to</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">         * retry to make sure it cannot acquire before parking.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">         */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>继续往下看，如果<code>shouldParkAfterFailedAcquire(p, node)</code>返回<code>true</code>，接下来就会执行下面这段代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">interrupted |= parkAndCheckInterrupt();</span></pre></td></tr></table></figure>

<p>其实这段代码等价于：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">interrupted = interrupted | parkAndCheckInterrupt();</span></pre></td></tr></table></figure>

<p>接着就是<code>parkAndCheckInterrup</code>方法，用来挂起当前的线程，返回中断标志。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * Convenience method to park and then check if interrupted.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> *</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if interrupted</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    LockSupport.park(<span class="keyword">this</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> Thread.interrupted();</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>注意入队与挂起线程操作不响应中断，只是返回线程中断标志，这一点从上面的代码就可以看出来。</p>
<p>在<code>acquireQueued</code>方法中，<code>for</code>循环是在<code>try</code>语句块里面的，所以这块代码会出现异常，下面有<code>catch</code>语句块。在 JDK8 中，没有<code>catch</code>语句块，有一个<code>finally</code>语句块，这是两个版本之间的差异。这里捕获的异常是<code>tryAcquire</code>抛出的，因为<code>tryAcquire</code>需要继承的类自定义实现，有可能抛出异常。<code>catch</code>异常之后，执行以下方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">cancelAcquire(node);<span class="comment">//取消加锁，恢复状态</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (interrupted)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    selfInterrupt();</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">throw</span> t;</span></pre></td></tr></table></figure>

<p><code>cancelAcquire</code>方法的源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * Cancels an ongoing attempt to acquire.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> *</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * <span class="doctag">@param</span> node the node</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">cancelAcquire</span><span class="params">(Node node)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// Ignore if node doesn't exist</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    node.thread = <span class="keyword">null</span>;<span class="comment">// node节点内的线程置为空</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// Skip cancelled predecessors</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    Node pred = node.prev;    <span class="comment">// pred 是前驱节点</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>)<span class="comment">// 找到 pred 结点前面最近的一个状态不为 CANCELLED 的结点</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        node.prev = pred = pred.prev;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// predNext is the apparent node to unsplice. CASes below will</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// fail if not, in which case, we lost race vs another cancel</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// or signal, so no further action is necessary, although with</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// a possibility that a cancelled node may transiently remain</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// reachable.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    Node predNext = pred.next;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// Can use unconditional write instead of CAS here.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// After this atomic step, other Nodes can skip past us.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// Before, we are free of interference from other threads.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    node.waitStatus = Node.CANCELLED;<span class="comment">//当前节点的状态改成 CANCELLED</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// If we are the tail, remove ourselves.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (node == tail &amp;&amp; compareAndSetTail(node, pred)) &#123;<span class="comment">//如果当前节点是尾节点，则利用 CAS 设置尾结点为 pred 结点</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        pred.compareAndSetNext(predNext, <span class="keyword">null</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125; <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// If successor needs signal, try to set pred's next-link</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// so it will get one. Otherwise wake it up to propagate.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> ws;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">//如果 pred 结点不为头结点</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">//并且(pred 结点的状态为 SIGNAL 或者 (ws 小于 0 并且 CAS 设置等待状态为 SIGNAL 成功))</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">//并且 pred 结点内的线程不为空</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (pred != head &amp;&amp;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            ((ws = pred.waitStatus) == Node.SIGNAL || </span></pre></td></tr><tr><td class="code"><pre><span class="line">             (ws &lt;= <span class="number">0</span> &amp;&amp; pred.compareAndSetWaitStatus(ws, Node.SIGNAL))) &amp;&amp;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            pred.thread != <span class="keyword">null</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            Node next = node.next;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (next != <span class="keyword">null</span> &amp;&amp; next.waitStatus &lt;= <span class="number">0</span>)<span class="comment">//后继节点不为空 并且后继节点的等待状态小于等于0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                pred.compareAndSetNext(predNext, next);<span class="comment">//把当前节点的后节点设置成本节点的后节点，也就是说把本节点剔除出去。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            unparkSuccessor(node);<span class="comment">// 释放节点的后继节点</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">        node.next = node; <span class="comment">// help GC</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p><code>cancleAcquire</code>方法执行完成之后，node 节点就取消了加锁，恢复了队列原有的信号状态，然后从队列列删除了 node 节点。</p>
<p>最后一步，如果<code>interrupted</code>为<code>true</code>，就把当前线程挂起。</p>
<p>简化一点，以上所有做的就是以下几个工作：</p>
<ol>
<li>尝试获取锁</li>
<li>获取不到锁的话，加入队列并将队列中的前元素的状态改为<code>SIGNAL</code>。</li>
<li>如果出错，就恢复状态，抛出异常。</li>
<li>没有出错就按照需求判断是否需要中断，需要的话中断当前线程。</li>
</ol>
<p>上面研究了独占模式下 AQS 的原理，再让我们一起看看共享模式做了哪些工作。</p>
<h3 id="共享模式"><a href="#共享模式" class="headerlink" title="共享模式"></a>共享模式</h3><p>共享模式的获取和释放锁的方法也很容易找到：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        doAcquireShared(arg);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        doReleaseShared();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>需要注意到，获取锁除了基本的方法之外，还有两个增强的方法，这两个方法被用在<code>Semaphore</code>、<code>CountDownLatch</code>和<code>ReentrantReadWriteLock</code>中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span><span class="comment">//在acquireShared 方法基础上增加了能响应中断的功能；</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        doAcquireSharedInterruptibly(arg);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquireSharedNanos</span><span class="params">(<span class="keyword">int</span> arg, <span class="keyword">long</span> nanosTimeout)</span><span class="comment">//在acquireSharedInterruptibly基础上增加了超时等待的功能</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> tryAcquireShared(arg) &gt;= <span class="number">0</span> ||</span></pre></td></tr><tr><td class="code"><pre><span class="line">        doAcquireSharedNanos(arg, nanosTimeout);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>还是从获取锁开始看，<code>tryAcquireShared</code>方法跟<code>tryAcquire</code>类似，需要继承者手动实现，返回 0 代表当前线程能够执行，但之后的将会进入等待队列中；返回正数直接执行，之后的线程可能也可以直接执行。</p>
<p>我们还是先看实际主要逻辑所在的<code>doAcquireShared</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);<span class="comment">//创建一个分享模式的节点，CAS 循环加到队尾，node 就是新加到队尾的那个节点。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> (;;) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (p == head) &#123;<span class="comment">//前节点是 head，证明当前节点是队列里的第一个。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">int</span> r = tryAcquireShared(arg);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;<span class="comment">//获取锁成功</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                    setHeadAndPropagate(node, r);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                    <span class="keyword">return</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node))</span></pre></td></tr><tr><td class="code"><pre><span class="line">                interrupted |= parkAndCheckInterrupt();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        cancelAcquire(node);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">throw</span> t;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (interrupted)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            selfInterrupt();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>这里与上面独占的部分也很相似，只有一个<code>setHeadAndPropagate</code>方法是新的，主要就是把当前节点设置成<code>head</code>节点，然后依次唤醒后续节点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * Sets head of queue, and checks if successor may be waiting</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * in shared mode, if so propagating if either propagate &gt; 0 or</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * PROPAGATE status was set.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> *</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * <span class="doctag">@param</span> node the node</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * <span class="doctag">@param</span> propagate the return value from a tryAcquireShared</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setHeadAndPropagate</span><span class="params">(Node node, <span class="keyword">int</span> propagate)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Node h = head; <span class="comment">// Record old head for check below</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    setHead(node);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">/*</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     * Try to signal next queued node if:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     *   Propagation was indicated by caller,</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     *     or was recorded (as h.waitStatus either before</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     *     or after setHead) by a previous operation</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     *     (note: this uses sign-check of waitStatus because</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     *      PROPAGATE status may transition to SIGNAL.)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     * and</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     *   The next node is waiting in shared mode,</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     *     or we don't know, because it appears null</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     *</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     * The conservatism in both of these checks may cause</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     * unnecessary wake-ups, but only when there are multiple</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     * racing acquires/releases, so most need signals now or soon</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     * anyway.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (propagate &gt; <span class="number">0</span> || h == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span> ||</span></pre></td></tr><tr><td class="code"><pre><span class="line">        (h = head) == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Node s = node.next;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.isShared())</span></pre></td></tr><tr><td class="code"><pre><span class="line">            doReleaseShared();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>下面这一大长串判断的逻辑是这样：首先<code>propagate &gt; 0</code>代表当前线程已经获取到了资源，并且需要唤醒后面阻塞的节点；<code>h.waitStatus &lt; 0</code> 代表旧的头节点后面的节点可以被唤醒；<code>(h = head) == null || h.waitStatus &lt; 0</code> 这个操作是说新的头节点后面的节点可以被唤醒，总结来说：</p>
<ol>
<li><code>propagate &gt; 0</code>代表当前线程已经获取到了资源，并且需要唤醒后面阻塞的节点。</li>
<li>无论新旧头节点，只要其<code>waitStatus &lt; 0</code>，那么其后面的节点可以被唤醒。</li>
</ol>
<p>如果上面<code>if</code>返回<code>true</code>，接着获取当前节点的后继节点，这里又会有一个判断，如果后继节点是共享模式或者现在还看不到后继的状态，则都继续唤醒后继节点中的线程。上面<code>if</code>返回<code>true</code>，接着执行<code>doReleaseShared</code>方法，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * Release action for shared mode -- signals successor and ensures</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * propagation. (Note: For exclusive mode, release just amounts</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * to calling unparkSuccessor of head if it needs signal.)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">/*</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     * Ensure that a release propagates, even if there are other</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     * in-progress acquires/releases.  This proceeds in the usual</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     * way of trying to unparkSuccessor of head if it needs</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     * signal. But if it does not, status is set to PROPAGATE to</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     * ensure that upon release, propagation continues.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     * Additionally, we must loop in case a new node is added</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     * while we are doing this. Also, unlike other uses of</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     * unparkSuccessor, we need to know if CAS to reset status</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     * fails, if so rechecking.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (;;) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Node h = head;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h != tail) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">int</span> ws = h.waitStatus;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;<span class="comment">//如果状态是等待信号</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">if</span> (!h.compareAndSetWaitStatus(Node.SIGNAL, <span class="number">0</span>))<span class="comment">//cas 操作失败的话就循环继续</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                    <span class="keyword">continue</span>;            <span class="comment">// loop to recheck cases</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                unparkSuccessor(h);<span class="comment">// 唤醒后继节点</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="comment">// 如果后继节点还未设置前驱节点的waitStatus为SIGNAL，代表目前无需唤醒或者不存在。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="comment">// 那么就将头节点的waitStatus设置为PROPAGATE，代表在下次acquireShared时无条件地传播</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                     !h.compareAndSetWaitStatus(<span class="number">0</span>, Node.PROPAGATE))</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">continue</span>;                <span class="comment">// loop on failed CAS</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (h == head)                   <span class="comment">// loop if head changed</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">break</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>再回头看<code>doAcquireSharedInterruptibly</code>和<code>doAcquireSharedNanos</code>方法，提供了可以中断和可以超时的获取锁方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * Acquires in shared interruptible mode.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * <span class="doctag">@param</span> arg the acquire argument</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> (;;) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (p == head) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">int</span> r = tryAcquireShared(arg);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    setHeadAndPropagate(node, r);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                    <span class="keyword">return</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                parkAndCheckInterrupt())</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        cancelAcquire(node);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">throw</span> t;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>可中断获取锁的逻辑跟前面<code>acquire</code>很像，唯一的区别是当<code>parkAndCheckInterrupt</code>返回<code>true</code>时即线程阻塞时该线程被中断，代码抛出被中断异常。</p>
<p>通过调用<code>lock.tryLock(timeout,TimeUnit)</code>方式达到超时等待获取锁的效果，该方法会在三种情况下才会返回：</p>
<ol>
<li>在超时时间内，当前线程成功获取了锁；</li>
<li>当前线程在超时时间内被中断；</li>
<li>超时时间结束，仍未获得锁返回<code>false</code>。</li>
</ol>
<p>具体实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * Acquires in shared timed mode.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> *</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * <span class="doctag">@param</span> arg the acquire argument</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * <span class="doctag">@param</span> nanosTimeout max wait time</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if acquired</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">doAcquireSharedNanos</span><span class="params">(<span class="keyword">int</span> arg, <span class="keyword">long</span> nanosTimeout)</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0L</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> deadline = System.nanoTime() + nanosTimeout;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> (;;) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (p == head) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">int</span> r = tryAcquireShared(arg);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    setHeadAndPropagate(node, r);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            nanosTimeout = deadline - System.nanoTime();</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0L</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                cancelAcquire(node);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                nanosTimeout &gt; SPIN_FOR_TIMEOUT_THRESHOLD)</span></pre></td></tr><tr><td class="code"><pre><span class="line">                LockSupport.parkNanos(<span class="keyword">this</span>, nanosTimeout);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (Thread.interrupted())</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        cancelAcquire(node);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">throw</span> t;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>Java中的各种集合类</title>
    <url>/2020/03/13/Java%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E9%9B%86%E5%90%88%E7%B1%BB/</url>
    <content><![CDATA[<p>Java中的集合主要分为以下集合类：<code>Map</code>、<code>List</code>、<code>Set</code>、<code>Queue</code>和<code>concurrent</code>包里面供多线程环境下使用的以上几种集合类。</p>
<a id="more"></a>

<h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p><code>java.util</code>包中提供的常见Map类包括以下几种。这里乱入了个<code>ConcurrentHashMap</code>，放到下面和其他<code>concurrent</code>包的集合一起讲。</p>
<p><img src="http://nas.beritra.com:18081/uploads/big/745d97b3e18d919ffbb9ad3a7f61c61b.png" alt=""></p>
<h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><p> HashMap 是老生常谈的集合了，学习 HashMap 主要关注点是哈希算法、rehash、数据存储、扩容方式、性能区别和结合ConcurrentHashMap 了解为什么线程不安全，后者怎么解决线程安全问题。</p>
<h4 id="哈希算法"><a href="#哈希算法" class="headerlink" title="哈希算法"></a>哈希算法</h4><p>先看一下JDK中 hashCode 的生成方式，JDK8 以后都是如下方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> h;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>这里可以看到，key 不是 null 的情况下，都是取<code>key.hashCode()</code>之后无符号右移16位，然后取异或。这里的<code>key.hashCode()</code>是 native 方法，直接在 JVM 中返回 int 型散列值。</p>
<blockquote>
<p>无符号右移&gt;&gt;&gt; ：不管正负标志位为0还是1，将该数的二进制码整体右移，左边部分总是以0填充，右边部分舍弃。</p>
<p>位与：第一个操作数的的第n位于第二个操作数的第n位如果都是1，那么结果的第n为也为1，否则为0</p>
</blockquote>
<p>为什么要这么做？</p>
<p>理论上散列值是一个 int 型，如果直接拿散列值作为下标访问 HashMap 主数组的话，考虑到 2 进制 32 位带符号的 int 表值范围从<code>-2147483648</code>到<code>2147483648</code>。前后加起来大概 40 亿的映射空间。只要哈希函数映射得比较均匀松散，一般应用是很难出现碰撞的。</p>
<p>但问题是一个 40 亿长度的数组，内存是放不下的。你想，HashMap 扩容之前的数组初始大小才 16。所以这个散列值是不能直接拿来用的。用之前还要先做对数组的长度取模运算，得到的余数才能用来访问数组下标。</p>
<p>顺便说一下，这也正好解释了为什么 HashMap 的数组长度要取 2 的整次幂。因为这样（数组长度 -1）正好相当于一个“低位掩码”。“与”操作的结果就是散列值的高位全部归零，只保留低位值，用来做数组下标访问。以初始长度 16 为例，16-1=15。2 进制表示是<code>00000000 00000000 00001111</code>。和某散列值做“与”操作如下，结果就是截取了最低的四位值。即</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">		10100101 11000100 00100101</span></pre></td></tr><tr><td class="code"><pre><span class="line">&amp;	  00000000 00000000 00001111</span></pre></td></tr><tr><td class="code"><pre><span class="line">-------------------------------------------------</span></pre></td></tr><tr><td class="code"><pre><span class="line">		00000000 00000000 00000101    &#x2F;&#x2F;高位全部归零，只保留末四位</span></pre></td></tr></table></figure>

<p>但这时候问题就来了，这样就算我的散列值分布再松散，要是只取最后几位的话，碰撞也会很严重。更要命的是如果散列本身做得不好，分布上成等差数列的漏洞，恰好使最后几个低位呈现规律性重复，就无比蛋疼。</p>
<p>这时候“扰动函数”的价值就体现出来了，说到这里大家应该猜出来了。看下面这个图:</p>
<p><img src="http://nas.beritra.com:18081/uploads/big/e2865f788f40d13b29e204649820a9bf.jpg" alt=""></p>
<p>右位移 16 位，正好是 32bit 的一半，自己的高半区和低半区做异或，就是为了混合原始哈希码的高位和低位，以此来加大低位的随机性。而且混合后的低位掺杂了高位的部分特征，这样高位的信息也被变相保留下来。</p>
<h4 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h4><p>HashMap两个关键的初始化参数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span></pre></td></tr></table></figure>

<p>前者是初始化容量 16，即新建一个 HashMap 的时候，如果不指定长度，则容量为 16。</p>
<p>后者是加载因子，即当实际长度除以容量高于该因子的时候，进行扩容操作。默认为 0.75，所以 HashMap 空间占用大于 3/4 的时候就开始扩容了。扩容后的容量是原来的两倍。</p>
<p>HashMap 的 resize 不是简单的把长度扩大，而是有下面两个步骤：</p>
<ol>
<li>扩容：创建一个新的 Entry 空数组，长度是原数组的2倍。</li>
<li>reash：遍历原 Entry 数组，把所有的 Entry 重新 hash 到新数组。为什么要重新 hash 呢？因为长度扩大以后，hash 的规则也随之改变。</li>
</ol>
<p>让我们回顾一下 hash 公式：</p>
<p><code>index = hashCode(key) &amp; (length - 1)</code></p>
<p>当原数组长度为 8 时，hash 运算是和<code>111B</code>做与运算；新数组长度为 16，hash 运算是和<code>1111B</code>做与运算。hash 结果显然不同。</p>
<p>那么这里为什么要用 map 容量减去 1 这个数字哪？好处有两个：</p>
<ol>
<li>分布均匀</li>
<li>速度更快</li>
</ol>
<p>在 HashMap 的源码中。<code>get</code>和<code>put</code>方法会根据 key 的 hash 值找到这个 entry 在 hash 表数组中的位置，源码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if ((p &#x3D; tab[i &#x3D; (n - 1) &amp; hash]) &#x3D;&#x3D; null)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    tab[i] &#x3D; newNode(hash, key, value, null);</span></pre></td></tr></table></figure>

<p>按照我们理想的状况，hashMap 的存取就是 O(1)，也就是直接根据 hashcode 就可以找到它，每个 bucket 只存储一个节点，链表指向都是<code>null</code>，这样就比较开心了，不要出现一个链表很长的情况。</p>
<p>所以我们希望它能分布的均匀一点，如果让我们设计的话，我们肯定是直接对长度取模：<code>hashcode % length</code>，但 HashMap 的设计者却不是这样写的，它写成了 2 进制运算，因为当容量一定是<code>2^n</code>时，<code>h &amp; (length - 1) == h % length</code>，并且位运算的速度要高于取模。</p>
<p>另外，元素在重新计算 hash 之后，因为 n 变为 2 倍，新的 index 的二进制就是在前面多了一位，比如原来的容量为 8 的时候，元素下标为 5，扩容到 16 之后，根据多的那一位是 0 还是 1，元素下标只需要 +8 或者在原位置就可以了，也就是说 resize 操作也会更快。</p>
<h4 id="存储方式"><a href="#存储方式" class="headerlink" title="存储方式"></a>存储方式</h4><p>HashMap 实际是一种“数组+链表”数据结构。在 put 操作中，通过内部定义算法寻止找到数组下标，将数据直接放入此数组元素中，若通过算法得到的该数组元素已经有了元素（俗称 hash 冲突，链表结构出现的实际意义也就是为了解决 hash 冲突的问题）。将会把这个数组元素上的链表进行遍历，将新的数据放到链表末尾。</p>
<p>通过哈希算法从寻止上能够高效的找到对应的下标，但是随着数据的增长，哈希冲突碰撞过多。在寻找数据时，先找到链表，然后通过遍历在寻找对应数据，如此将会使得 get 数据效率越来越低。在 JDK1.8 中，链表元素数量大于等于 8 将会重组该链表结构形成为“红黑树结构”，这种结构使得在 hash 冲突碰撞过多情况下，<code>get</code>效率比链表的效率高很多。</p>
<h4 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h4><p>在没有哈希冲突的情况下，HashMap 存取元素的时间复杂度是 O(1)，但是这只是理想情况。当冲突不多的时候，重复元素以链表形式存储，时间复杂度是 O(N)，当数据量大的时候，链表转换为红黑树，时间复杂度变成 O(LogN)</p>
<h4 id="线程安全和其他局限"><a href="#线程安全和其他局限" class="headerlink" title="线程安全和其他局限"></a>线程安全和其他局限</h4><p>HashMap 不是线程安全的，另外如果 HashMap 的 key 是自定义类，需要重写<code>hashCode()</code>方法，并且由于 HashMap 的效率高度依赖<code>hashCode()</code>，需要保证散列分布尽量均匀。</p>
<p>都知道 HashMap 不是线程安全的，那么在哪些环节导致了他线程不安全？</p>
<ol>
<li><p>插入数据的时候</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span></pre></td></tr></table></figure>

<p>假如 A 线程和 B 线程同时添加元素，然后计算出了相同的哈希值对应了相同的数组位置，因为此时该位置还没数据，然后对同一个数组位置添加，B 的写入操作就会覆盖 A 的写入操作造成 A 的写入操作丢失。</p>
</li>
<li><p>修改数据的时候</p>
<p>跟上面同样，多个线程同时修改数据，可能产生错误。</p>
</li>
<li><p>扩容的时候</p>
<p>线程1执行<code>put</code>时，因为元素个数超出<code>threshold</code>而导致 rehash，线程2此时执行<code>get</code>，有可能导致这个问题。</p>
<p>因为在 resize 的时候，是计算新的容量和<code>threshold</code>，在创建一个新 hash 表，最后将旧 hash 表中元素 rehash 到新的 hash 表中。如果在这个期间，另一个线程执行读取操作，有可能<code>get</code>到<code>null</code>。</p>
</li>
</ol>
<p>那么 ConcurrentHashMap 如何保证线程安全？这个在另一篇文章中单独叙述。</p>
<h3 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h3><p>LinkedHashMap是继承自HashMap的，跟HashMap最大的区别是，他是基于Hash表和链表的实现，并且依靠着双向链表保证了迭代顺序是插入的顺序。</p>
<p>来看看 HashMap 和 LinkedHashMap 的结构图，是不是秒懂了。LinkedHashMap 其实就是可以看成 HashMap 的基础上，多了一个双向链表来维持顺序。</p>
<p><img src="http://nas.beritra.com:18081/uploads/big/61bd32fe80e6c936034c93389cc99c0a.jpg" alt=""></p>
<p><img src="http://nas.beritra.com:18081/uploads/big/f7855185a5577918835416203aa831ae.jpg" alt=""></p>
<p>可以用 LinkedHashMap 实现最近访问算法，即最近访问过的元素在最前面， LinkedHashMap 有这么一个构造方法。</p>
<p><code>public LinkedHashMap(int initialCapacity, float loadFactor,boolean accessOrder)</code></p>
<p><code>accessOrde</code>为<code>true</code>的时候按照元素最后访问时间排序（LRU算法：最近最久使用），为<code>false</code>则是按照插入顺序排序，默认为<code>false</code>.</p>
<h3 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h3><p>TreeMap 是基于红黑树的实现，具有如下特点：</p>
<ul>
<li>不允许出现重复的 key；</li>
<li>可以插入<code>null</code>键，<code>null</code>值；</li>
<li>可以对元素进行排序；</li>
<li>无序集合（插入和遍历顺序不一致）；</li>
</ul>
<p>由于是基于红黑树，TreeMap 在插入、删除、搜索的时候，时间复杂度都是O(LogN)。红黑树的结构单独另外说明，这里就不赘述。</p>
<h3 id="EnumMap"><a href="#EnumMap" class="headerlink" title="EnumMap"></a>EnumMap</h3><p>EnumMap 是专门为枚举类型量身定做的Map实现。虽然使用其它的 Map 实现（如HashMap）也能完成枚举类型实例到值得映射，但是使用 EnumMap 会更加高效：它只能接收同一枚举类型的实例作为键值，并且由于枚举类型实例的数量相对固定并且有限，所以 EnumMap 使用数组来存放与枚举类型对应的值。这使得 EnumMap 的效率非常高。EnumMap 在内部使用枚举类型的<code>ordinal()</code>得到当前实例的声明次序，并使用这个次序维护枚举类型实例对应值在数组的位置。</p>
<p>在 key 是枚举类的时候，EnumMap 可以用来代替 HashMap，并且由于是数组实现，性能更好。</p>
<h3 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a>HashTable</h3><h4 id="Hashtable-与-HashMap-的简单比较"><a href="#Hashtable-与-HashMap-的简单比较" class="headerlink" title="Hashtable 与 HashMap 的简单比较"></a>Hashtable 与 HashMap 的简单比较</h4><ol>
<li><p>HashTable 基于 Dictionary 类，而 HashMap 是基于 AbstractMap。Dictionary 是任何可将键映射到相应值的类的抽象父类，而 AbstractMap 是基于 Map 接口的实现，它以最大限度地减少实现此接口所需的工作。</p>
</li>
<li><p>HashMap 的 key 和 value 都允许为<code>null</code>，而 Hashtable 的 key 和 value 都不允许为<code>null</code>。HashMap 遇到 key 为<code>null</code>的时候，调用<code>putForNullKey</code>方法进行处理，而对 value 没有处理；Hashtable遇到<code>null</code>，直接返回<code>NullPointerException</code>。</p>
</li>
<li><p>Hashtable 方法是同步，而HashMap则不是。我们可以看一下源码，Hashtable 中的几乎所有的 public 的方法都是<code>synchronized</code>的，而有些方法也是在内部通过<code>synchronized</code>代码块来实现。所以有人一般都建议如果是涉及到多线程同步时采用 HashTable，没有涉及就采用 HashMap，但是在 Collections 类中存在一个静态方法：<code>synchronizedMap()</code>，该方法创建了一个线程安全的 Map 对象，并把它作为一个封装的对象来返回。</p>
</li>
<li><p>HashMap的初始容量为 16，Hashtable初始容量为 11，两者的填充因子默认都是0.75。</p>
</li>
<li><p>两者计算 hash 的方法不同</p>
<p>Hashtable 计算 hash 是直接使用 key 的 hashcode 对 table 数组的长度直接进行取模</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> hash = key.hashCode();</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span></pre></td></tr></table></figure>

<p>HashMap 计算 hash 对 key 的 hashcode 的前后16为进行了异或操作，以获得更好的散列值，然后对table数组长度取模(实际上是位操作，增加效率)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="keyword">int</span> h;</span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">   &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">   </span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexFor</span><span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> length)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="keyword">return</span> h &amp; (length-<span class="number">1</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">   &#125;</span></pre></td></tr></table></figure>



</li>
</ol>
<h3 id="IdentityHashMap"><a href="#IdentityHashMap" class="headerlink" title="IdentityHashMap"></a>IdentityHashMap</h3><p>IdentityHashMap 是一致性哈希表，使用引用相等，而不是<code>equals</code>方法来比较两个对象的相等性。因此，IdentityHashMap 中，如果存在两个键 key1 和 key2，当且仅当<code>key1==key2</code>时，两个键相等，而其他大部分的哈希表，当且仅当<code>k1 == null ? k2 == null : k1.equals(k2)</code>时，两个键才认为是相等的。</p>
<p>IdentityHashMap 使用<code>System.identityHashCode</code>来确定对象的哈希码，该方法返回对象的地址。</p>
<p>看下<code>IdentityHashMap</code>的存储原理图，和 HashMap 不同，HashMap 是通过数组+拉链法存储元素并解决哈希冲突的。IdentityHashMap 将所有的 key 和 value 都存储到<code>Object[]</code>数组 table 中，并且 key 和 value 相邻存储，当出现哈希冲突时，会往下遍历数组，直到找到一个空闲的位置。注意，数组第一个位置存储的是 key，第二个位置存储的是 value。因此奇数位置处存储的是 key，偶数位置处存储的是 value。</p>
<p>IdentityHashMap 同样允许空的键和值，但是不保证 map 中的顺序，尤其是不保证顺序会恒定不变。</p>
<h3 id="WeakHashMap"><a href="#WeakHashMap" class="headerlink" title="WeakHashMap"></a>WeakHashMap</h3><p>和 HashMap 一样，WeakHashMap 也是一个散列表，它存储的内容也是键值对(key-value)映射，而且键和值都可以是<code>null</code>。不过 WeakHashMap 的键是“弱键”。</p>
<p>当弱引用指向的对象只能通过弱引用（没有强引用或弱引用）访问时，GC会清理掉该对象，之后，引用对象会被放到ReferenceQueue中。在 Entry 的构造函数中可以得知，通过<code>super(key, queue)</code>将 key 保存为弱引用，通过<code>this.value = value</code>将 value 保存为强引用。当 key 中的引用被 gc 掉之后，在下次访问 WeakHashMap（调用<code>expungeStaleEntries</code>函数）时相应的 entry 也会自动被移除。</p>
<p>WeakHashMap 并不是你什么也不干它就能自动释放内部不用的对象的，而是在你访问它的内容的时候释放内部不用的对象。</p>
<h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><p><code>java.util</code>包中提供的常见List类包括以下几种。</p>
<p><img src="http://nas.beritra.com:18081/uploads/big/11d786f3c58fa393e519eca19c63fa67.png" alt=""></p>
<p>从刚学 Java 的前几天起，大概就会见到这个问题：LinkedList 和 ArrayList 有什么共同点和区别？</p>
<p>共同点：</p>
<ol>
<li>二者都是继承自 AbstractList 抽象类，AbstractList 实现了 List 接口中除了<code>size()</code>、<code>get(int location)</code>之外的方法。</li>
<li>二者都是线程不安全的。</li>
</ol>
<p>区别：</p>
<ol>
<li>ArrayList 是实现了<strong>基于动态数组</strong>的数据结构，而 LinkedList 是<strong>基于链表</strong>的数据结构；</li>
<li>数据更新和查找时，ArrayList 可以直接通过数组下标访问，所以效率更高。</li>
<li>数据增加和删除的时候，ArrayList 需要移动其他元素的位置，而 LinkedList 只需要修改一个指针，所以后者效率更高。</li>
</ol>
<h4 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h4><p>Vector 是同样继承于AbstractList的一个列表，而它是线程安全的，实现方式是对所有数据操作的方法添加了 synchronized 关键字。其与 ArrayList 的差别如下：</p>
<ul>
<li>构造函数，ArrayList 比 Vector 稍有深度，Vector 默认数组长度为 10，创建是设置。</li>
<li>扩容方法 <code>grow()</code>，ArrayList 通过位运算进行扩容，而 Vector 则通过增长系数（创建是设置，如果过为空，则增长一倍）</li>
<li>Vector 方法调用是线程安全的。</li>
<li>成员变量有所不同</li>
</ul>
<h4 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h4><p>Stack栈是Vector的一个子类，它实现了一个标准的后进先出的栈。</p>
<p>他的方法很简单，只有<code>empty()</code>、<code>peek()</code>、<code>pop()</code>、<code>push(Object element)</code>、<code>search(object element)</code>这几个。其中 peek 和 pop 的返回值都是堆栈顶部的对象，但是前者只是查看，后者是移除。</p>
<h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><p><code>java.util</code>包中提供的常见Set类包括以下几种。</p>
<p><img src="http://nas.beritra.com:18081/uploads/big/06530f14f76b79769887d3f1e8eebc27.png" alt=""></p>
<p>HashSet 没什么好说的，其实就是把 HashMap 封装了一层，从 HashSet 的构造方法可以看出，就是维护了一个 HashMap，数据的增删改查也是调用的 HashMap 的方法。</p>
<p>TreeSet 也是一样，其实就是 TreeMap 套了个皮。</p>
<p>EnumSet 就不一样了，跟 EnumMap 其实没有什么关系。EnumSet 是一个 Set 集合的抽象类，其有两个实现类 JumboEnumSet 和 RegularEnumSet，在使用的时候放入的必须是枚举类型，<strong>其特点是速度非常快。</strong></p>
<p>EnumSet 的默认子类 RegularEnumSet 和 JumboEnumSet 实现原理都是基于位运算向量，位运算向量的原理就是用一个位表示一个元素的状态（元素的状态只有两种），用一组位表示一个集合的状态，每个位对应一个元素，譬如一个枚举类 DemoEnum 有6个枚举值，则 EnumSet<DemoEnum> 集合就可以通过一个 byte 字节从右到左（二进制低到高位）来表示，不用的位上用 0 填充，用的位上每个 bit 位代表一个枚举值，1 表示包含该枚举值，0 表示不含该枚举值。因此位向量能表示的枚举值个数与向量长度有关，上面例子中一个 byte 类型最多能表示 8 个枚举值，所以 EnumSet 抽象类的两个实现类 RegularEnumSet 和 JumboEnumSet 分别定义了不同的向量长度。RegularEnumSet 使用 64 位的 long 类型变量作为位向量，而 JumboEnumSet 使用一个 long 类型数组作为向量（数组内存连续），故当我们通过 EnumSet 的工厂方法创建 EnumSet 集合时 EnumSet 会通过判断枚举类的枚举值数量决定使用两个子类的哪一个，如果枚举值个数小于等于 64 就用 RegularEnumSet，大于 64 就用 JumboEnumSet。</p>
<p>简单来说 EnumSet 就是一个高效的枚举类集合。</p>
<h2 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h2><p><img src="http://nas.beritra.com:18081/uploads/big/8fd5bf86f968ababd2e78669517c5c08.png" alt=""></p>
<p>队列(Queue)可以当做一种特殊的线性表，遵循先进先出原则。而双向队列(Deque),是 Queue 的一个子接口，双向队列是指该队列两端的元素既能入队(offer)也能出队(poll),如果将 Deque 限制为只能从一端入队和出队，则可实现栈的数据结构。</p>
<p>PriorityQueue 有一种特殊的队列，叫做优先队列。优先队列的作用是能保证每次取出的元素都是队列中权值最小的<strong>（Java的优先队列每次取最小元素，C++的优先队列每次取最大元素）。这里牵涉到了大小关系，</strong>元素大小的评判可以通过元素本身的自然顺序（natural ordering），也可以通过构造时传入的比较器（Comparator，类似于C++的仿函数）。</p>
<p>Java 中 PriorityQueue 实现了 Queue 接口，不允许放入<code>null</code>元素；其通过堆实现，具体说是通过完全二叉树（complete binary tree）实现的<strong>小顶堆</strong>（任意一个非叶子节点的权值，都不大于其左右子节点的权值），也就意味着可以通过数组来作为 PriorityQueue 的底层实现。</p>
<p>最小堆的完全二叉树有一个特性是根节点必定是最小节点，子女节点一定大于其父节点。还有一个特性是叶子节点数量=全部非叶子节点数量+1。</p>
<p>每次增删元素都有可能对树结构进行调整，所以 PriorityQueue 队列不适合进场出队入队的频繁操作，但是他的优先级特性非常适合一些对顺序有要求的数据处理场合。</p>
<h2 id="concurrent包"><a href="#concurrent包" class="headerlink" title="concurrent包"></a>concurrent包</h2><h4 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h4><p>上面 HashMap 已经说到了 HashMap 在多个线程同时存取或者触发扩容的时候，都有可能出现错误，导致操作被覆盖或者丢失，那么怎么解决这个问题呐？</p>
<p>第一反应当然是加锁，HashTable 就是这么做的，使用了<code>synchronized</code>关键字。虽然解决了并发访问的安全性问题，但是性能不怎么样。HashTable 中的增删改、甚至<code>equals</code>、<code>toString</code>方法等等都是方法级的锁，所以同时只能一个线程去操作，导致效率问题。</p>
<p>在JDK1.7及之前版本，ConcurrentHashMap 采用的是 Segment 分段锁，即将数据分为一段一段的存储，然后给每一段数据加一把锁。当一个线程占用锁访问其中一个段数据时，其他段的数据也能被其他线程访问。</p>
<p>在JDK1.8以后，ConcurrentHashMap 取消了 Segment 分段锁，采用 CAS 和<code>synchronized</code>来保证并发安全。 数据结构与 HashMap 1.8 的结构类似，数组+链表/红黑二叉树(链表长度&gt;8 时，转换为红黑树)。</p>
<p>通过 JDK 的源码和官方文档看来， 他们认为的弃用分段锁的原因由以下几点：</p>
<ol>
<li>加入多个分段锁浪费内存空间。</li>
<li>生产环境中， map 在放入时竞争同一个锁的概率非常小，分段锁反而会造成更新等操作的长时间等待。</li>
<li>为了提高 GC 的效率。</li>
</ol>
<p>在 JDK11 下对 HashMap 和 ConcurrentHashMap 进行了简单测试，生成 5000 万条随机数然后插入，分别消耗 16348 毫秒和 19194 毫秒。其中包括随机数生成、插入和扩容的时间消耗，可见两者之间性能差距不大。</p>
<p>然后使用 HashTable 在单线程下插入，同样的数据量时间在 17 秒所有，跟 HashMap 差别不大，可以当做是误差范围内。然后使用 20 个线程插入，消耗时间在 15 秒左右，提升并不明显。奇怪的是 ConcurrentHashMap 却使用了 45 秒。然后缩小数据量，在 1000 万以下的时候，ConcurrentHashMap 的插入速度又好于 HashTable 了。这个现象很有意思，有空了详细研究一下产生这个问题的原因。</p>
<p>ConcurrentHashMap 的<strong>整体性能</strong>要优于 HashTable，但是某些场景不能替代 HashTable，例如<strong>强一致性</strong>的场景，ConcurrentHashMap 的<code>get</code>、<code>size</code>等方法都<strong>没有加锁</strong>，ConcurrentHashMap 是<strong>弱一致性</strong>的。更多关于 ConcurrentHashMap 的原理在另一个文章中单独分析。</p>
<h4 id="ConcurrentSkipListMap"><a href="#ConcurrentSkipListMap" class="headerlink" title="ConcurrentSkipListMap"></a>ConcurrentSkipListMap</h4><p>ConcurrentSkipListMap 提供了一种线程安全的并发访问的排序映射表。内部是 SkipList（跳表）结构实现，在理论上能够在 O(logN) 时间内完成查找、插入、删除操作。</p>
<p>ConcurrentHashMap 与 ConcurrentSkipListMap 性能测试<br>在4线程1.6万数据的条件下，ConcurrentHashMap 存取速度是 ConcurrentSkipListMap 的4倍左右。</p>
<p>但 ConcurrentSkipListMap 有几个 ConcurrentHashMap 不能比拟的优点：</p>
<p>1、ConcurrentSkipListMap 的 key 是有序的。</p>
<p>2、ConcurrentSkipListMap 支持更高的并发。ConcurrentSkipListMap 的存取时间是 log(N)，和线程数几乎无关。也就是说在数据量一定的情况下，并发的线程越多， ConcurrentSkipListMap 越能体现出他的优势。 </p>
<h4 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h4><p>先讲一下什么是<code>Copy-On-Write</code>，通俗的理解是当我们往一个容器添加元素的时候，不直接往当前容器添加，而是先将当前容器进行 Copy，复制出一个新的容器，然后新的容器里添加元素，添加完元素之后，再将原容器的引用指向新的容器。对 CopyOnWrite 容器进行并发的读的时候，不需要加锁，因为当前容器不会添加任何元素。所以 CopyOnWrite 容器也是一种读写分离的思想，延时更新的策略是通过在写的时候针对的是不同的数据容器来实现的，放弃数据实时性达到数据的最终一致性。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">synchronized</span> (lock) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Object[] es = getArray();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> len = es.length;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        es = Arrays.copyOf(es, len + <span class="number">1</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        es[len] = e;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        setArray(es);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">synchronized</span> (lock) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Object[] es = getArray();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        E oldValue = elementAt(es, index);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (oldValue != element) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            es = es.clone();</span></pre></td></tr><tr><td class="code"><pre><span class="line">            es[index] = element;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            setArray(es);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> oldValue;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>CopyOnWriteArrayList 的实现也不复杂，对有并发风险的操作加了锁。注意这里的内部数组是<code>volatile</code>修饰的，写线程对数组引用的修改对读线程是可见的。由于在写数据的时候，是在新的数组中插入数据的，从而保证读写实在两个不同的数据容器中进行操作。</p>
<p><img src="http://nas.beritra.com:18081/uploads/big/9151c7a0b015e54bdc06bebfaec18be7.jpg" alt=""></p>
<p>参考资料：</p>
<p><a href="https://www.zhihu.com/question/20733617" target="_blank" rel="noopener">JDK 源码中 HashMap 的 hash 方法原理是什么？</a></p>
<p><a href="https://juejin.im/post/5c1c79b16fb9a049a711c97c" target="_blank" rel="noopener">HashMap底层实现原理</a></p>
<p><a href="https://blog.csdn.net/eson_15/article/details/51543812" target="_blank" rel="noopener">【java并发】造成HashMap非线程安全的原因</a></p>
<p><a href="https://blog.csdn.net/luanmousheng/article/details/78587547" target="_blank" rel="noopener">IdentityHashMap源码详解</a></p>
<p><a href="https://blog.csdn.net/itmyhome1990/article/details/77651165" target="_blank" rel="noopener">WeakHashMap实现原理及源码分析</a></p>
<p><a href="https://www.jianshu.com/p/fb37835a8103" target="_blank" rel="noopener">EnumSet 原理相关</a></p>
<p><a href="https://juejin.im/post/5aa5d8d26fb9a028d2079264#heading-27" target="_blank" rel="noopener">Java源码分析：HashMap 1.8 相对于1.7 到底更新了什么？</a>（这篇非常细致）</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>集合</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux文本处理三剑客grep、awk和sed</title>
    <url>/2020/03/07/Linux%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E4%B8%89%E5%89%91%E5%AE%A2grep%E3%80%81awk%E5%92%8Csed/</url>
    <content><![CDATA[<p>awk、grep、sed是linux操作文本的三大利器，合称文本三剑客，也是必须掌握的linux命令之一。三者的功能都是处理文本，但侧重点各不相同，其中属awk功能最强大，但也最复杂。grep更适合单纯的查找或匹配文本，sed更适合编辑匹配到的文本，awk更适合格式化文本，对文本进行较复杂格式处理。</p>
<a id="more"></a>

<h2 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h2><p>Linux 系统中 grep 命令是一种强大的文本搜索工具，它能使用正则表达式搜索文本，并把匹配的行打印出来。grep全称是 Global Regular Expression Print，表示全局正则表达式版本，它的使用权限是所有用户。</p>
<p>grep可用于shell脚本，因为grep通过返回一个状态值来说明搜索的状态，如果模板搜索成功，则返回0，如果搜索不成功，则返回1，如果搜索的文件不存在，则返回2。我们利用这些返回值就可进行一些自动化的文本处理工作。</p>
<p>命令的基本格式：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">grep [option] pattern file</span></pre></td></tr></table></figure>

<p>即便不熟悉这个命令，应该大多数同学也用过查询进程的命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ps -ef|grep xxxx</span></pre></td></tr></table></figure>

<p>这就是 grep 的一个基本用法，从所有进程中搜索某个进程。</p>
<p>grep 常用的参数如下：</p>
<ul>
<li>-A&lt;行数 x&gt;：除了显示符合范本样式的那一列之外，并显示该行之后的 x 行内容。</li>
<li>-B&lt;行数 x&gt;：除了显示符合样式的那一行之外，并显示该行之前的 x 行内容。</li>
<li>-C&lt;行数 x&gt;：除了显示符合样式的那一行之外，并显示该行之前后的 x 行内容。</li>
<li>-c：统计匹配的行数</li>
<li><strong>-e ：实现多个选项间的逻辑or 关系</strong></li>
<li><strong>-E：扩展的正则表达式</strong></li>
<li>-f 文件名：从文件获取 <code>PATTERN</code> 匹配</li>
<li>-F ：相当于<code>fgrep</code></li>
<li>-i –ignore-case #忽略字符大小写的差别。</li>
<li>-n：显示匹配的行号</li>
<li>-o：仅显示匹配到的字符串</li>
<li>-q： 静默模式，不输出任何信息</li>
<li>-s：不显示错误信息。</li>
<li><strong>-v：显示不被 <code>pattern</code> 匹配到的行，相当于[^] 反向匹配</strong></li>
<li>-w ：匹配 整个单词</li>
</ul>
<p>前三个 A、B、C 参数很容易理解，举个栗子，假设我们有一个文件，文件名是 test，内容是从 1 到 9，每个数字一行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜ grep -A2 7 <span class="built_in">test</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">7</span></pre></td></tr><tr><td class="code"><pre><span class="line">8</span></pre></td></tr><tr><td class="code"><pre><span class="line">9</span></pre></td></tr></table></figure>

<p><code>-A2 7</code> 的效果就是找到 7 ，然后输出 7 后面两行。</p>
<p>同理，<code>-B2 7</code>和<code>-C2 7</code>就是找到 7 ，然后分别输出 7 前面两行和前后两行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜ grep -B2 7 <span class="built_in">test</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">5</span></pre></td></tr><tr><td class="code"><pre><span class="line">6</span></pre></td></tr><tr><td class="code"><pre><span class="line">7</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">➜ grep -C2 7 <span class="built_in">test</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">5</span></pre></td></tr><tr><td class="code"><pre><span class="line">6</span></pre></td></tr><tr><td class="code"><pre><span class="line">7</span></pre></td></tr><tr><td class="code"><pre><span class="line">8</span></pre></td></tr><tr><td class="code"><pre><span class="line">9</span></pre></td></tr></table></figure>

<p>继续，假设我们有个名叫 test 的文件内容如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜ cat <span class="built_in">test</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">aaaa</span></pre></td></tr><tr><td class="code"><pre><span class="line">bbbbbb</span></pre></td></tr><tr><td class="code"><pre><span class="line">AAAaaa</span></pre></td></tr><tr><td class="code"><pre><span class="line">BBBBASDABBDA</span></pre></td></tr></table></figure>

<p><code>grep -c</code>命令的作用就是输出匹配到的行数，比如我们想找包含<code>aaa</code>的有几行，一眼就能看出来有两行，第一行和第三行都包含：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜ grep -c aaa <span class="built_in">test</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">2</span></pre></td></tr></table></figure>

<p><code>grep -e</code>命令是实现多个匹配之间的<code>或</code>关系，比如我们想找包含<code>aaaa</code>或者<code>bbbb</code>的，显然应该返回第一行和第二行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜ grep -e aaaa -e bbbb <span class="built_in">test</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">aaaa</span></pre></td></tr><tr><td class="code"><pre><span class="line">bbbbbb</span></pre></td></tr></table></figure>

<p><code>grep -F</code>相当于<code>fgrep</code>命令，就是将<code>pattern</code>视为固定字符串。比如搜索<code>&#39;aa*&#39;</code>不带<code>-F</code>和带上，区别如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜ grep <span class="string">'aa*'</span> <span class="built_in">test</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">aaaa</span></pre></td></tr><tr><td class="code"><pre><span class="line">AAAaaa</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">➜ grep -F <span class="string">'aa*'</span> <span class="built_in">test</span></span></pre></td></tr></table></figure>

<p>可以看到第二次就找不到了，因为搜索的是 <code>aa*</code>这个字符串，而不是正则表达式。</p>
<p><code>grep -f 文件名</code>的使用方法是把后面这个文件里的内容当做<code>pattern</code>。比如我们有个文件，名字是 grep.txt，然后内容是<code>aa*</code>，使用方法如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜ grep -f grep.txt <span class="built_in">test</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">aaaa</span></pre></td></tr><tr><td class="code"><pre><span class="line">AAAaaa</span></pre></td></tr></table></figure>

<p>实际上等同于<code>grep &#39;aa*&#39; test</code></p>
<p><code>grep -i --ignore-case</code>作用是忽略大小写。</p>
<p><code>grep -n</code>显示匹配的行号，就是多显示了个行号，不用细说。</p>
<p><code>grep -o</code>仅显示匹配到的字符串，还是用刚才的<code>aa*</code>距离，之前显示的都是匹配到的字符所在的整行，这个命令是只显示匹配到的字符：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">➜ grep -o <span class="string">'aa*'</span> test</span></pre></td></tr><tr><td class="code"><pre><span class="line">aaaa</span></pre></td></tr><tr><td class="code"><pre><span class="line">aaa</span></pre></td></tr></table></figure>

<p><code>grep -q</code>不打印匹配结果。刚看到这个我疑惑了半天，让你搜索字符串，你不给我结果那有啥用？然后发现还有一条很多教程没说：如果有匹配的内容则立即返回状态值 0。所以一般用在<code>shell</code>脚本中，在 <code>if</code> 判断里面。</p>
<p><code>grep -s</code>不显示错误信息，不解释。</p>
<p><code>grep -v</code>显示不被匹配到的行，相当于<code>[^]</code>反向匹配，最常见的还是用在查找线程的命令里，有时候会打印<code>grep</code>线程，可以再加上这么一个去除自己：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜ ps -ef|grep Typora</span></pre></td></tr><tr><td class="code"><pre><span class="line">  501 91616     1   0 五11上午 ??        13:39.32 /Applications/Typora.app/Contents/MacOS/Typora</span></pre></td></tr><tr><td class="code"><pre><span class="line">  501 14814 93748   0  5:33下午 ttys002    0:00.00 grep --color=auto --exclude-dir=.bzr --exclude-dir=CVS --exclude-dir=.git --exclude-dir=.hg --exclude-dir=.svn Typora</span></pre></td></tr><tr><td class="code"><pre><span class="line">  </span></pre></td></tr><tr><td class="code"><pre><span class="line">➜ ps -ef|grep Typora|grep -v grep</span></pre></td></tr><tr><td class="code"><pre><span class="line">  501 91616     1   0 五11上午 ??        13:39.32 /Applications/Typora.app/Contents/MacOS/Typora</span></pre></td></tr></table></figure>

<p>可以看到第二次就没有打印<code>grep</code>线程自身</p>
<p><code>grep -w</code>匹配整个单词，只有完全符合<code>pattern</code>的单次才会匹配到：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜ grep aaa <span class="built_in">test</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">aaaa</span></pre></td></tr><tr><td class="code"><pre><span class="line">AAAaaa</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">➜ grep -w aaa <span class="built_in">test</span></span></pre></td></tr></table></figure>

<p>可以看到第二次结果为空，因为没有<code>aaa</code>这个单词。</p>
<p>关于正则的高级用法就不再深入研究了，改日再统一整理。</p>
<h2 id="sed"><a href="#sed" class="headerlink" title="sed"></a>sed</h2><p><code>sed</code> 命令的作用是利用脚本来处理文本文件。使用方法：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sed [-hnV][-e&lt;script&gt;][-f&lt;script文件&gt;][文本文件]</span></pre></td></tr></table></figure>

<p><strong>参数说明</strong>：</p>
<ul>
<li><code>-e&lt;script&gt;</code>或<code>--expression=&lt;script&gt;</code> 以选项中指定的 <code>script</code> 来处理输入的文本文件，这个<code>-e</code>可以省略，直接写表达式。</li>
<li><code>-f&lt;script文件&gt;</code>或<code>--file=&lt;script文件&gt;</code>以选项中指定的 <code>script</code> 文件来处理输入的文本文件。</li>
<li><code>-h</code>或<code>--help</code>显示帮助。</li>
<li><code>-n</code> 或 <code>--quiet</code> 或 <code>--silent</code> 仅显示 <code>script</code> 处理后的结果。</li>
<li><code>-V</code> 或 <code>--version</code> 显示版本信息。</li>
</ul>
<p><strong>动作说明</strong>：</p>
<ul>
<li>a：新增， a 的后面可以接字串，而这些字串会在新的一行出现(目前的下一行)～</li>
<li>c：取代， c 的后面可以接字串，这些字串可以取代 n1,n2 之间的行！</li>
<li>d：删除，因为是删除啊，所以 d 后面通常不接任何咚咚；</li>
<li>i：插入， i 的后面可以接字串，而这些字串会在新的一行出现(目前的上一行)；</li>
<li>p：打印，亦即将某个选择的数据印出。通常 p 会与参数 sed -n 一起运行～</li>
<li>s：取代，通常这个 s 的动作可以搭配正规表示法，例如 1,20s/old/new/g 。</li>
</ul>
<p>我们先准备一个文件，名为<code>test</code>做测试，内容如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜ cat <span class="built_in">test</span> </span></pre></td></tr><tr><td class="code"><pre><span class="line">HELLO LINUX!  </span></pre></td></tr><tr><td class="code"><pre><span class="line">Linux is a free unix-type opterating system.  </span></pre></td></tr><tr><td class="code"><pre><span class="line">This is a linux testfile!  </span></pre></td></tr><tr><td class="code"><pre><span class="line">Linux <span class="built_in">test</span></span></pre></td></tr></table></figure>

<h4 id="增加内容"><a href="#增加内容" class="headerlink" title="增加内容"></a>增加内容</h4><p>使用命令<code>sed -e 3a\newLine testfile</code>这个命令的意思就是，在第三行后面追加<code>newLine</code>这么一行字符，字符前面要用反斜线作区分。执行完毕之后可以看到结果：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜ sed -e 3a\newline <span class="built_in">test</span>  </span></pre></td></tr><tr><td class="code"><pre><span class="line">HELLO LINUX!  </span></pre></td></tr><tr><td class="code"><pre><span class="line">Linux is a free unix-type opterating system.  </span></pre></td></tr><tr><td class="code"><pre><span class="line">This is a linux testfile!  </span></pre></td></tr><tr><td class="code"><pre><span class="line">newline</span></pre></td></tr><tr><td class="code"><pre><span class="line">Linux <span class="built_in">test</span></span></pre></td></tr></table></figure>

<p>但是注意，这个只是将文字处理了，没有写入到文件里，文件里还是之前的内容。</p>
<p>其实 a 前面是可以匹配字符串，比如我们只想在出现 Linux 的行后面追加，就可以：<code>sed -e /Linux/a\newline test</code> 两个斜线之间的内容是需要匹配的内容。可以看出，只有第二、第四行有<code>Linux</code>，所以结果如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜ sed -e /Linux/a\newline <span class="built_in">test</span> </span></pre></td></tr><tr><td class="code"><pre><span class="line">HELLO LINUX!  </span></pre></td></tr><tr><td class="code"><pre><span class="line">Linux is a free unix-type opterating system.  </span></pre></td></tr><tr><td class="code"><pre><span class="line">newline</span></pre></td></tr><tr><td class="code"><pre><span class="line">This is a linux testfile!  </span></pre></td></tr><tr><td class="code"><pre><span class="line">Linux <span class="built_in">test</span> </span></pre></td></tr><tr><td class="code"><pre><span class="line">newline</span></pre></td></tr></table></figure>

<p>这里用双引号把整个表达式括起来也可以，还方便处理带空格的字符。</p>
<p><code>sed -e /Linux/a\newline test</code>等效于<code>sed &quot;/Linux/a newline&quot; test</code></p>
<h4 id="插入内容"><a href="#插入内容" class="headerlink" title="插入内容"></a>插入内容</h4><p>跟 <code>a</code> 类似，<code>sed 3i\newline test</code>是在第三行前面插入<code>newline</code>:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜ sed 3i\newline <span class="built_in">test</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">HELLO LINUX!  </span></pre></td></tr><tr><td class="code"><pre><span class="line">Linux is a free unix-type opterating system.  </span></pre></td></tr><tr><td class="code"><pre><span class="line">newline</span></pre></td></tr><tr><td class="code"><pre><span class="line">This is a linux testfile!  </span></pre></td></tr><tr><td class="code"><pre><span class="line">Linux <span class="built_in">test</span></span></pre></td></tr></table></figure>

<p><code>sed /Linux/i\newline test</code>是在所有匹配到<code>Linux</code>的行前面插入：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜ sed /Linux/i\newline <span class="built_in">test</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">HELLO LINUX!  </span></pre></td></tr><tr><td class="code"><pre><span class="line">newline</span></pre></td></tr><tr><td class="code"><pre><span class="line">Linux is a free unix-type opterating system.  </span></pre></td></tr><tr><td class="code"><pre><span class="line">This is a linux testfile!  </span></pre></td></tr><tr><td class="code"><pre><span class="line">newline</span></pre></td></tr><tr><td class="code"><pre><span class="line">Linux <span class="built_in">test</span></span></pre></td></tr></table></figure>

<p>可以看出插入的用法和增加很相似。</p>
<h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><p>删除的字符是<code>d</code>，用法跟前面也很相似，就不赘述，例子如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜ sed <span class="string">'/Linux/d'</span> <span class="built_in">test</span>      </span></pre></td></tr><tr><td class="code"><pre><span class="line">HELLO LINUX!  </span></pre></td></tr><tr><td class="code"><pre><span class="line">This is a linux testfile!</span></pre></td></tr></table></figure>

<p>可以看到删除了匹配到的两行。</p>
<h4 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h4><p>替换也是一样，字符是<code>c</code>。举个栗子：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜ sed <span class="string">'/Linux/c\Windows'</span> <span class="built_in">test</span>                   </span></pre></td></tr><tr><td class="code"><pre><span class="line">HELLO LINUX!  </span></pre></td></tr><tr><td class="code"><pre><span class="line">Windows</span></pre></td></tr><tr><td class="code"><pre><span class="line">This is a linux testfile!  </span></pre></td></tr><tr><td class="code"><pre><span class="line">Windows</span></pre></td></tr></table></figure>

<p>替换还有个字符是 <code>s</code>，但是用法由不太一样了，最常见的用法：<code>sed &#39;s/old/new/g&#39;</code>其中<code>old</code>代表想要匹配的字符，<code>new</code>是想要替换的字符，比如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜ sed <span class="string">'s/Linux/Windows/g'</span> <span class="built_in">test</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">HELLO LINUX!  </span></pre></td></tr><tr><td class="code"><pre><span class="line">Windows is a free unix-type opterating system.  </span></pre></td></tr><tr><td class="code"><pre><span class="line">This is a linux testfile!  </span></pre></td></tr><tr><td class="code"><pre><span class="line">Windows <span class="built_in">test</span></span></pre></td></tr></table></figure>

<p>这里的<code>/g</code>的意思是一行中的每一次匹配，因为一行中可能匹配到很多次。我们拿一个新的文本文件做例子：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜ cat test2</span></pre></td></tr><tr><td class="code"><pre><span class="line">aaaaaaaaaaa</span></pre></td></tr><tr><td class="code"><pre><span class="line">bbbbbabbbbb</span></pre></td></tr><tr><td class="code"><pre><span class="line">cccccaacccc</span></pre></td></tr></table></figure>

<p>假设我们想把一行中的第三次及以后出现的<code>a</code>变成大写<code>A</code>，那应该这么写：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜ sed <span class="string">'s/a/A/3g'</span> test2</span></pre></td></tr><tr><td class="code"><pre><span class="line">aaAAAAAAAAA</span></pre></td></tr><tr><td class="code"><pre><span class="line">bbbbbabbbbb</span></pre></td></tr><tr><td class="code"><pre><span class="line">cccccaacccc</span></pre></td></tr></table></figure>

<p>可以看出只有第一行的有的改了，因为第二第三行没有这么多<code>a</code>出现。</p>
<p>关于<code>s</code>还有很多用法，还是回到第一个文件，比如可以用<code>/^/</code>和<code>/$/</code>分别代表行首和行尾：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜ sed <span class="string">'s/^/###/g'</span> <span class="built_in">test</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">###HELLO LINUX!  </span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">###Linux is a free unix-type opterating system.  </span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">###This is a linux testfile!  </span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">###Linux test </span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">➜ sed <span class="string">'s/$/---/g'</span> <span class="built_in">test</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">HELLO LINUX!  ---</span></pre></td></tr><tr><td class="code"><pre><span class="line">Linux is a free unix-type opterating system.  ---</span></pre></td></tr><tr><td class="code"><pre><span class="line">This is a linux testfile!  ---</span></pre></td></tr><tr><td class="code"><pre><span class="line">Linux <span class="built_in">test</span> ---</span></pre></td></tr></table></figure>

<p>这个其实就是正则表达式的语法，其他类似语法还有：</p>
<ul>
<li><code>^</code> 表示一行的开头。如：<code>/^#/</code> 以#开头的匹配。</li>
<li><code>$</code> 表示一行的结尾。如：<code>/}$/</code> 以}结尾的匹配。</li>
<li><code>\&lt;</code> 表示词首。 如：`\ 表示以 abc 为首的詞。</li>
<li><code>\&gt;</code> 表示词尾。 如：<code>abc\&gt;</code> 表示以 abc 結尾的詞。</li>
<li><code>.</code> 表示任何单个字符。</li>
<li><code>*</code> 表示某个字符出现了0次或多次。</li>
<li><code>[ ]</code> 字符集合。 如：<code>[abc]</code> 表示匹配a或b或c，还有 <code>[a-zA-Z]</code> 表示匹配所有的26个字符。如果其中有^表示反，如 <code>[^a]</code> 表示非a的字符</li>
</ul>
<p>以上的所有用法，还可以在字符前面增加行号或者匹配。什么意思呐？比如你想在第一和第二行后面增加一行内容<code>newline</code>，就是：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜ sed <span class="string">'1,2a\newline'</span> <span class="built_in">test</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">HELLO LINUX!  </span></pre></td></tr><tr><td class="code"><pre><span class="line">newline</span></pre></td></tr><tr><td class="code"><pre><span class="line">Linux is a free unix-type opterating system.  </span></pre></td></tr><tr><td class="code"><pre><span class="line">newline</span></pre></td></tr><tr><td class="code"><pre><span class="line">This is a linux testfile!  </span></pre></td></tr><tr><td class="code"><pre><span class="line">Linux <span class="built_in">test</span></span></pre></td></tr></table></figure>

<p>其他操作同理。不止可以用数字来限定范围，还可以用匹配来限定，只需要用<code>//</code>括起来：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜ sed <span class="string">'/LINUX/,/linux/i\test'</span> <span class="built_in">test</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">test</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">HELLO LINUX!  </span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">test</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Linux is a free unix-type opterating system.  </span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">test</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">This is a linux testfile!  </span></pre></td></tr><tr><td class="code"><pre><span class="line">Linux <span class="built_in">test</span></span></pre></td></tr></table></figure>

<p>这里的意思是，从匹配到<code>LINUX</code>的那一行，到匹配到<code>linux</code>的那一行，也就是 123 这三行</p>
<p>，都做插入操作。</p>
<h4 id="多个匹配"><a href="#多个匹配" class="headerlink" title="多个匹配"></a>多个匹配</h4><p>用<code>-e</code>命令可以执行多次匹配，相当于顺序依次执行两个<code>sed</code>命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜ sed -e <span class="string">'s/Linux/Windows/g'</span> -e <span class="string">'s/Windows/Mac OS/g'</span> <span class="built_in">test</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">HELLO LINUX!  </span></pre></td></tr><tr><td class="code"><pre><span class="line">Mac OS is a free unix-type opterating system.  </span></pre></td></tr><tr><td class="code"><pre><span class="line">This is a linux testfile!  </span></pre></td></tr><tr><td class="code"><pre><span class="line">Mac OS <span class="built_in">test</span></span></pre></td></tr></table></figure>

<p>这个命令其实就是先把<code>Linux</code>替换成<code>Windows</code>，再把<code>Windows</code>替换成<code>Mac OS</code>。</p>
<h4 id="写入文件"><a href="#写入文件" class="headerlink" title="写入文件"></a>写入文件</h4><p>上面介绍的所有文件操作都支持在缓存中处理然后打印到控制台，实际上没有对文件修改。想要保存到原文件的话可以用<code>&gt; file</code>或者<code>-i</code>来保存到文件</p>
<h2 id="awk"><a href="#awk" class="headerlink" title="awk"></a>awk</h2><p>awk是一个强大的文本分析工具，相对于grep的查找，sed的编辑，awk在其对数据分析并生成报告时，显得尤为强大。简单来说awk就是把文件逐行的读入，以空格为默认分隔符将每行切片，切开的部分再进行各种分析处理。</p>
<h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">awk [选项参数] <span class="string">'script'</span> var=value file(s)</span></pre></td></tr><tr><td class="code"><pre><span class="line">或</span></pre></td></tr><tr><td class="code"><pre><span class="line">awk [选项参数] -f scriptfile var=value file(s)</span></pre></td></tr></table></figure>

<p>参数说明：</p>
<ul>
<li>-F fs or –field-separator fs<br>指定输入文件折分隔符，fs是一个字符串或者是一个正则表达式，如-F:。</li>
<li>-v var=value or –asign var=value<br>赋值一个用户定义变量。</li>
<li>-f scripfile or –file scriptfile<br>从脚本文件中读取awk命令。</li>
</ul>
<h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h4><p>最基本的用法是<code>awk 动作 文件名</code>。我们先准备一个文件<code>test</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜ cat <span class="built_in">test</span> </span></pre></td></tr><tr><td class="code"><pre><span class="line">2 this is a <span class="built_in">test</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">3 Are you like awk</span></pre></td></tr><tr><td class="code"><pre><span class="line">This<span class="string">'s a test</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">10 There are orange,apple,mongo</span></span></pre></td></tr></table></figure>

<p>然后输入<code>awk &#39;{print $1,$4}&#39; test</code>就可以看到：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">2 a</span></pre></td></tr><tr><td class="code"><pre><span class="line">3 like</span></pre></td></tr><tr><td class="code"><pre><span class="line">This<span class="string">'s </span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">10 orange,apple,mongo</span></span></pre></td></tr></table></figure>

<p>对比可以很清楚的发现，这行语句的作用是打印每行的第一个和第四个单词。这里如果是<code>$0</code>的话就是把整行都输出出来。</p>
<p><code>awk -F</code>命令可以指定使用哪个分隔符，默认是空格或者 tab 键：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜ awk -F, <span class="string">'&#123;print $2&#125;'</span> <span class="built_in">test</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">apple</span></pre></td></tr></table></figure>

<p>可以看出只有最后一行有输出，因为用逗号做分割，之后最后一行被分成了<code>10 There are orange</code>、<code>apple</code>和<code>mongo</code>三项，然后我们要的是第二项。</p>
<p>还可以同时使用多个分隔符：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜ awk -F <span class="string">'[ ,]'</span>  <span class="string">'&#123;print $1,$2,$5&#125;'</span> <span class="built_in">test</span> </span></pre></td></tr><tr><td class="code"><pre><span class="line">2 this <span class="built_in">test</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">3 Are awk</span></pre></td></tr><tr><td class="code"><pre><span class="line">This<span class="string">'s a </span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">10 There apple</span></span></pre></td></tr></table></figure>

<p>这个例子便是使用空格和逗号两个分隔符。</p>
<p>匹配项中可以用正则表达式，比如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜ awk <span class="string">'/^This/'</span> <span class="built_in">test</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">This<span class="string">'s a test</span></span></pre></td></tr></table></figure>

<p>匹配的就是严格以<code>This</code>开头的内容。</p>
<p>还可以取反：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜ awk <span class="string">'$0 !~ /is/'</span> <span class="built_in">test</span> </span></pre></td></tr><tr><td class="code"><pre><span class="line">3 Are you like awk</span></pre></td></tr><tr><td class="code"><pre><span class="line">10 There are orange,apple,mongo</span></pre></td></tr></table></figure>

<p>这一个的结果就是去掉带有<code>is</code>的行，只显示其余部分。</p>
<p>从文件中读取：<code>awk -f {awk脚本} {文件名}</code>，这个很好理解，就不再做解释。</p>
<h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><p><code>awk</code>中有不少内置的变量，比如<code>$NF</code>代表的是分割后的字段数量，相当于取最后一个。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜ awk <span class="string">'&#123;print $NF&#125;'</span> <span class="built_in">test</span>            </span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">test</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">awk</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">test</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">orange,apple,mongo</span></pre></td></tr></table></figure>

<p>可以看出都是每行的最后一项。</p>
<p>其他的内置变量还有：</p>
<blockquote>
<ul>
<li><code>FILENAME</code>：当前文件名</li>
<li><code>FS</code>：字段分隔符，默认是空格和制表符。</li>
<li><code>RS</code>：行分隔符，用于分割每一行，默认是换行符。</li>
<li><code>OFS</code>：输出字段的分隔符，用于打印时分隔字段，默认为空格。</li>
<li><code>ORS</code>：输出记录的分隔符，用于打印时分隔记录，默认为换行符。</li>
<li><code>OFMT</code>：数字输出的格式，默认为<code>％.6g</code>。</li>
</ul>
</blockquote>
<h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><p><code>awk</code>还提供了一些内置函数，方便对原始数据的处理。主要如下：</p>
<blockquote>
<ul>
<li><code>toupper()</code>：字符转为大写。</li>
<li><code>tolower()</code>：字符转为小写。</li>
<li><code>length()</code>：返回字符串长度。</li>
<li><code>substr()</code>：返回子字符串。</li>
<li><code>sin()</code>：正弦。</li>
<li><code>cos()</code>：余弦。</li>
<li><code>sqrt()</code>：平方根。</li>
<li><code>rand()</code>：随机数。</li>
</ul>
</blockquote>
<h4 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h4><p><code>awk</code>允许指定输出条件，只输出符合条件的行。输出条件要写在动作的前面：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">awk <span class="string">'条件 动作'</span> 文件名</span></pre></td></tr></table></figure>

<p>还是刚才的例子，用逗号分隔之后有好几个空白行，我们加上限制条件，匹配后为空的不显示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜ awk -F, <span class="string">'$2!="" &#123;print $2&#125;'</span> <span class="built_in">test</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">apple</span></pre></td></tr></table></figure>

<p>可以看到就只剩下<code>apple</code>了。</p>
<h4 id="if-语句"><a href="#if-语句" class="headerlink" title="if 语句"></a>if 语句</h4><p><code>awk</code>提供了<code>if</code>结构，用于编写复杂的条件。比如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜ awk <span class="string">'&#123;if ($2 &gt; "t") print $1&#125;'</span> <span class="built_in">test</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">2</span></pre></td></tr></table></figure>

<p>这一句的完整含义应该是：把每一行按照空格分割之后，如果第二个单词大于<code>t</code>，就输出第一个单词。这里对字符的大小判断应该是基于字符长度和 unicode 编码。</p>
<p>以上这些只是三剑客的基础用法，包括正则表达式也有很多技巧，更多扩展内容网上也很多了，可以自行搜索，或者翻阅下面的参考文章。</p>
<p>参考文章</p>
<p><a href="https://coolshell.cn/articles/9104.html" target="_blank" rel="noopener">SED 简明教程</a></p>
<p><a href="https://www.runoob.com/linux/linux-comm-sed.html" target="_blank" rel="noopener">Linux sed 命令</a></p>
<p><a href="https://www.runoob.com/linux/linux-comm-awk.html" target="_blank" rel="noopener">Linux awk 命令</a></p>
<p><a href="http://www.ruanyifeng.com/blog/2018/11/awk.html" target="_blank" rel="noopener">awk 入门教程</a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>23种设计模式长文总结</title>
    <url>/2020/03/05/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E9%95%BF%E6%96%87%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>一次性将设计模式整理清楚，包括 23 种设计模式的优劣势、使用场景、示例以及 JDK 和常见框架中的使用方法。</p>
<a id="more"></a>

<h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p>按照惯例，先上维基百科的解释，什么是设计模式？</p>
<blockquote>
<p>在<a href="https://zh.wikipedia.org/wiki/軟體工程" target="_blank" rel="noopener">软件工程</a>中，<strong>设计模式</strong>（design pattern）是对<a href="https://zh.wikipedia.org/wiki/軟件設計" target="_blank" rel="noopener">软件设计</a>中普遍存在（反复出现）的各种问题，所提出的解决方案。这个术语是由<a href="https://zh.wikipedia.org/wiki/埃里希·伽瑪" target="_blank" rel="noopener">埃里希·伽玛</a>（Erich Gamma）等人在1990年代从<a href="https://zh.wikipedia.org/wiki/建筑设计" target="_blank" rel="noopener">建筑设计</a>领域引入到<a href="https://zh.wikipedia.org/wiki/計算機科學" target="_blank" rel="noopener">计算机科学</a>的。</p>
<p>设计模式并不直接用来完成<a href="https://zh.wikipedia.org/wiki/程式碼" target="_blank" rel="noopener">代码</a>的编写，而是描述在各种不同情况下，要怎么解决问题的一种方案。<a href="https://zh.wikipedia.org/wiki/面向对象程序设计" target="_blank" rel="noopener">面向对象</a>设计模式通常以<a href="https://zh.wikipedia.org/wiki/类_(计算机科学)" target="_blank" rel="noopener">类别</a>或<a href="https://zh.wikipedia.org/wiki/物件_(電腦科學)" target="_blank" rel="noopener">对象</a>来描述其中的关系和相互作用，但不涉及用来完成应用程序的特定类别或对象。设计模式能使不稳定依赖于相对稳定、具体依赖于相对抽象，避免会引起麻烦的紧耦合，以增强软件设计面对并适应变化的能力。</p>
</blockquote>
<p>说道设计模式，就不得不提到软件设计七大原则，可以说是设计模式的抽象和设计基础。</p>
<ol>
<li><strong>单一职责原则 (Single Responsibility Principle)</strong>：单一职责原则表示一个模块的组成元素之间的功能相关性。从软件变化的角度来看，就一个类而言，应该仅有一个让它变化的原因；通俗地说，即一个类只负责一项职责。</li>
<li><strong>开放-关闭原则 (Open-Closed Principle)</strong>：开放-关闭原则表示软件实体 (类、模块、函数等等) 应该是可以被扩展的，但是不可被修改。</li>
<li><strong>里氏替换原则 (Liskov Substitution Principle)</strong>：派生类（子类）对象应当可以在程序中代替其基类（超类）对象。或者说子类对象能够替换父类对象，而程序逻辑不变。</li>
<li><strong>依赖倒转原则 (Dependence Inversion Principle)</strong>：高层模块不应该依赖低层模块，二者都应该依赖于其抽象。进一步说，抽象不应该依赖于细节，细节应该依赖于抽象。</li>
<li><strong>接口隔离原则 (Interface Segregation Principle)</strong>：一个类不应该依赖他不需要的接口，使用多个专门的接口比使用单一的总接口总要好。</li>
<li><strong>迪米特法则（Law Of Demeter）</strong>：又叫最少知识原则（Least Knowledge Principle或简写为LKP），一个对象应当对其它对象有尽可能少的了解。通俗来说就是，只与直接的朋友通信。</li>
<li><strong>组合/聚合复用原则 (Composite/Aggregate Reuse Principle)</strong>：就是在一个新的对象里面使用一些已有的对象，使之成为新对象的一部分；新对象通过向这些对象的委派达到复用已有功能的目的。</li>
</ol>
<p>按照类型，设计模式应该可以分为 3 个大类，一共 23 种。</p>
<ol>
<li>创建型模式：单例模式、抽象工厂模式、原型模式、建造者模式、工厂模式。</li>
<li>结构型模式：适配器模式、桥接模式、装饰模式、组合模式、外观模式、享元模式、代理模式。</li>
<li>行为型模式：模板方法模式、命令模式、访问者模式、迭代器模式、观察者模式、中介者模式、备忘录模式、解释器模式、状态模式、策略模式、责任链模式。</li>
</ol>
<h2 id="23-种设计模式"><a href="#23-种设计模式" class="headerlink" title="23 种设计模式"></a>23 种设计模式</h2><h3 id="一、单例模式"><a href="#一、单例模式" class="headerlink" title="一、单例模式"></a>一、单例模式</h3><p>定义：采取方法，使整个软件系统中，对某个类只存在一个对象实例。并且该类只提供一个取得其对象实例的方法（静态方法）。</p>
<p>使用场景：频繁创建和销毁的对象、创建对象时消耗资源非常多的对象、工具类对象、频繁访问的数据库或文件对象。</p>
<p>单例模式有八种方法：</p>
<ol>
<li><p>恶汉式（静态常量）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton1</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton1</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton1 instance = <span class="keyword">new</span> Singleton1();</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> Singleton1 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> instance;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>优缺点：线程安全，在类装载的时候就实例化，有可能造成内存浪费。</p>
</li>
<li><p>恶汉式（静态代码块）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton2</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton2</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton2 instance;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">static</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        instance = <span class="keyword">new</span> Singleton2();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> Singleton2 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> instance;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>优缺点：跟上面一样。</p>
</li>
<li><p>懒汉式（线程不安全）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton3</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton3 instance;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton3</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton3 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            instance = <span class="keyword">new</span> Singleton3();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> instance;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>优缺点：懒加载，省内存。但是线程不安全。</p>
</li>
<li><p>懒汉式（同步方法，线程安全）</p>
<p>就是<code>getInstance()</code>方法上锁，解决线程安全问题。但是因为要等锁，效率太低。</p>
</li>
<li><p>懒汉式（同步代码块+双重检查，线程安全）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton4</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton4 instance;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton4</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton4 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">synchronized</span> (Singleton4<span class="class">.<span class="keyword">class</span>) </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    instance = <span class="keyword">new</span> Singleton4();</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> instance;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>只在初始化的代码块加锁，并且检查两次，相比第四种优化效率。</p>
</li>
<li><p>静态内部类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton5</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton5</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> Singleton5 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> Singleton.instance;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton5 instance = <span class="keyword">new</span> Singleton5();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>使用不能在外部直接改变内部类的特性，保证了线程安全和单例。并且由于内部类在调用的时候才会初始化，保证了懒加载，没有资源浪费。</p>
</li>
<li><p>枚举</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Singleton6 &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    INSTANCE;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>单例模式简洁高效，线程安全还能抗反射。但是不是懒加载，而且上面的形式不太容易理解。一般实际使用可能是下面这种，一个接口的单例实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SomeInterface</span> </span>&#123;<span class="comment">//一个接口</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Singleton7 implements SomeInterface &#123;<span class="comment">//一个枚举类来实现接口</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    INSTANCE;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.println(<span class="string">"做点啥"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestClass</span> </span>&#123;<span class="comment">//测试的时候这样就可以直接获取单例的实体类</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Singleton7.INSTANCE.doSomething();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>




</li>
</ol>
<h3 id="二、原型模式"><a href="#二、原型模式" class="headerlink" title="二、原型模式"></a>二、原型模式</h3><p>定义：用一个已经创建的实例作为原型，通过复制该原型对象来创建一个和原型相同或相似的新对象。</p>
<p>优点： 1、性能提高。 2、逃避构造函数的约束。</p>
<p>缺点： 1、配备克隆方法需要对类的功能进行通盘考虑，这对于全新的类不是很难，但对于已有的类不一定很容易，特别当一个类引用不支持串行化的间接对象，或者引用含有循环结构的时候。 2、必须实现 Cloneable 接口。</p>
<p>原型模式包含以下主要角色：</p>
<ol>
<li>抽象原型类：规定了具体原型对象必须实现的接口。</li>
<li>具体原型类：实现抽象原型类的 clone() 方法，它是可被复制的对象。</li>
<li>访问类：使用具体原型类中的 clone() 方法来复制新的对象。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//具体原型类</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Realizetype</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Realizetype()</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.println(<span class="string">"具体原型创建成功！"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">    </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.println(<span class="string">"具体原型复制成功！"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> (Realizetype)<span class="keyword">super</span>.clone();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//原型模式的测试类</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrototypeTest</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> CloneNotSupportedException</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">    </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Realizetype obj1=<span class="keyword">new</span> Realizetype();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Realizetype obj2=(Realizetype)obj1.clone();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.println(<span class="string">"obj1==obj2?"</span>+(obj1==obj2));</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>原型模式通常适用于以下场景。</p>
<ul>
<li>对象之间相同或相似，即只是个别的几个属性不同的时候。</li>
<li>对象的创建过程比较麻烦，但复制比较简单的时候。</li>
</ul>
<h3 id="三、简单工厂模式和工厂方法模式"><a href="#三、简单工厂模式和工厂方法模式" class="headerlink" title="三、简单工厂模式和工厂方法模式"></a>三、简单工厂模式和工厂方法模式</h3><p>简单工厂模式(Simple Factory Pattern)：又称为静态工厂方法(Static Factory Method)模式，它属于类创建型模式。在简单工厂模式中，可以根据参数的不同返回不同类的实例。简单工厂模式专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleFactory</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Product <span class="title">create</span><span class="params">(String type)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Product product;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">switch</span> (type) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">case</span> <span class="string">"a"</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">                System.out.println(<span class="string">"生产了产品A"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                product = <span class="keyword">new</span> ProductA();</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">break</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">case</span> <span class="string">"b"</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">                System.out.println(<span class="string">"生产了产品B"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                product = <span class="keyword">new</span> ProductB();</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">break</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">default</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">                System.out.println(<span class="string">"没有这种产品"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                product = <span class="keyword">null</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">break</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> product;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Product</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductA</span> <span class="keyword">implements</span> <span class="title">Product</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductB</span> <span class="keyword">implements</span> <span class="title">Product</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>使用的时候，只需要传入相应的参数就可以生产对应的产品：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SimpleFactory.create(<span class="string">"a"</span>);</span></pre></td></tr></table></figure>

<p>优点：</p>
<ul>
<li>将创建实例的工作与使用实例的工作分开，使用者不必关心类对象如何创建，实现了解耦；</li>
<li>把初始化实例时的工作放到工厂里进行，使代码更容易维护。 更符合面向对象的原则 &amp; 面向接口编程，而不是面向实现编程。</li>
</ul>
<p>缺点：</p>
<ul>
<li>工厂类集中了所有实例（产品）的创建逻辑，一旦这个工厂不能正常工作，整个系统都会受到影响；</li>
<li>违背“开放 - 关闭原则”，一旦添加新产品就不得不修改工厂类的逻辑，这样就会造成工厂逻辑过于复杂。</li>
<li>简单工厂模式由于使用了静态工厂方法，静态方法不能被继承和重写，会造成工厂角色无法形成基于继承的等级结构。</li>
</ul>
<p>使用场景：</p>
<ul>
<li>工厂类负责创建的对象比较少：由于创建的对象较少，不会造成工厂方法中的业务逻辑太过复杂。</li>
<li>客户端只知道传入工厂类的参数，对于如何创建对象不关心：客户端既不需要关心创建细节，甚至连类名都不需要记住，只需要知道类型所对应的参数。</li>
</ul>
<p>工厂方法是针对每一种产品提供一个工厂类，通过不同的工厂实例来创建不同的产品实例。主要解决了上面简单工厂模式违背了“开放 - 关闭原则”的问题。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Factory</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function">Product <span class="title">create</span><span class="params">()</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FactoryA</span> <span class="keyword">implements</span> <span class="title">Factory</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">create</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ProductA();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FactoryB</span> <span class="keyword">implements</span> <span class="title">Factory</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">create</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ProductB();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Product</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">use</span><span class="params">()</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductA</span> <span class="keyword">implements</span> <span class="title">Product</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">use</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.println(<span class="string">"使用产品A"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductB</span> <span class="keyword">implements</span> <span class="title">Product</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">use</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.println(<span class="string">"使用产品B"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>使用的时候，只要创建对应的工厂就可以生产对应产品并使用了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Factory factory = <span class="keyword">new</span> FactoryA();</span></pre></td></tr><tr><td class="code"><pre><span class="line">factory.create().use();</span></pre></td></tr></table></figure>

<p>优点：</p>
<ul>
<li>更符合开-闭原则，新增一种产品时，只需要增加相应的具体产品类和相应的工厂子类即可</li>
<li>符合单一职责原则，每个具体工厂类只负责创建对应的产品</li>
</ul>
<p>缺点</p>
<ul>
<li>添加新产品时，除了增加新产品类外，还要提供与之对应的具体工厂类，系统类的个数将成对增加，在一定程度上增加了系统的复杂度；同时，有更多的类需要编译和运行，会给系统带来一些额外的开销</li>
<li>由于考虑到系统的可扩展性，需要引入抽象层，在客户端代码中均使用抽象层进行定义，增加了系统的抽象性和理解难度，且在实现时可能需要用到DOM、反射等技术，增加了系统的实现难度</li>
<li>虽然保证了工厂方法内的对修改关闭，但对于使用工厂方法的类，如果要更换另外一种产品，仍然需要修改实例化的具体工厂类</li>
<li>一个具体工厂只能创建一种具体产品</li>
</ul>
<h3 id="四、抽象工厂模式"><a href="#四、抽象工厂模式" class="headerlink" title="四、抽象工厂模式"></a>四、抽象工厂模式</h3><p>为了解决上面工厂方法模式里“一个具体工厂只能创建一类产品”的问题，我们又使用了一种新的设计模式：抽象工厂模式。抽象工厂模式允许使用抽象的接口来创建一组相关产品，而不需要知道或关心实际生产出的具体产品是什么，这样就可以从具体产品中被解耦。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractFactory</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> AbstractProduct <span class="title">createProductA</span><span class="params">()</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> AbstractProduct <span class="title">createProductB</span><span class="params">()</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FactoryA</span> <span class="keyword">extends</span> <span class="title">AbstractFactory</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> AbstractProduct <span class="title">createProductA</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ProductA();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> AbstractProduct <span class="title">createProductB</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ProductB();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FactoryB</span> <span class="keyword">extends</span> <span class="title">AbstractFactory</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> AbstractProduct <span class="title">createProductA</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ProductA();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> AbstractProduct <span class="title">createProductB</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ProductB();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractProduct</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">use</span><span class="params">()</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractProductA</span> <span class="keyword">extends</span> <span class="title">AbstractProduct</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractProductB</span> <span class="keyword">extends</span> <span class="title">AbstractProduct</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductA</span> <span class="keyword">extends</span> <span class="title">AbstractProductA</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">use</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.println(<span class="string">"使用了产品A"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductB</span> <span class="keyword">extends</span> <span class="title">AbstractProductB</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">use</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.println(<span class="string">"使用了产品B"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>使用的时候，两个工厂就可以同时生产两款产品了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> FactoryA().createProductA().use();</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> FactoryA().createProductB().use();</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> FactoryB().createProductA().use();</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> FactoryB().createProductB().use();</span></pre></td></tr></table></figure>

<p>优点：</p>
<ul>
<li>降低耦合。抽象工厂模式将具体产品的创建延迟到具体工厂的子类中，这样将对象的创建封装起来，可以减少客户端与具体产品类之间的依赖，从而使系统耦合度低，这样更有利于后期的维护和扩展；</li>
<li>更符合开-闭原则。新增一种产品类时，只需要增加相应的具体产品类和相应的工厂子类即可</li>
</ul>
<p>缺点：</p>
<p>抽象工厂模式很难支持新种类产品的变化。这是因为抽象工厂接口中已经确定了可以被创建的产品集合，如果需要添加新产品，此时就必须去修改抽象工厂的接口，这样就涉及到抽象工厂类的以及所有子类的改变，这样也就违背了“开放-封闭”原则。</p>
<h3 id="五、建造者模式"><a href="#五、建造者模式" class="headerlink" title="五、建造者模式"></a>五、建造者模式</h3><p>定义：指将一个复杂对象的构造与它的表示分离，使同样的构建过程可以创建不同的表示，这样的设计模式被称为建造者模式。它是将一个复杂的对象分解为多个简单的对象，然后一步一步构建而成。它将变与不变相分离，即产品的组成部分是不变的，但每一部分是可以灵活选择的。</p>
<p>使用范围：</p>
<ol>
<li>当创建复杂对象的算法应该独立于该对象的组成部分以及它们的装配方式时。</li>
<li>当构造过程必须允许被构造的对象有不同表示时。</li>
</ol>
<p>在这样的设计模式中，有以下几个角色：</p>
<ol>
<li>Builder：为创建一个产品对象的各个部件指定抽象接口。</li>
<li>ConcreteBuilder：实现 Builder 的接口以构造和装配该产品的各个部件，定义并明确它所创建的表示，并提供一个检索产品的接口。</li>
<li>Director：构造一个使用 Builder 接口的对象，指导构建过程。</li>
<li>Product：表示被构造的复杂对象。ConcreteBuilder 创建该产品的内部表示并定义它的装配过程，包含定义组成部件的类，包括将这些部件装配成最终产品的接口。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PersonBuilder</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">buildHead</span><span class="params">()</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">buildBody</span><span class="params">()</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">buildFoot</span><span class="params">()</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">     <span class="function">Person <span class="title">buildPerson</span><span class="params">()</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ManBuilder</span> <span class="keyword">implements</span> <span class="title">PersonBuilder</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">     Person person;</span></pre></td></tr><tr><td class="code"><pre><span class="line">     <span class="function"><span class="keyword">public</span> <span class="title">ManBuilder</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">          person = <span class="keyword">new</span> Man();</span></pre></td></tr><tr><td class="code"><pre><span class="line">     &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildbody</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">          person.setBody(<span class="string">"建造男人的身体"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">     &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildFoot</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">          person.setFoot(<span class="string">"建造男人的脚"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">     &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildHead</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">          person.setHead(<span class="string">"建造男人的头"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">     &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">     <span class="function"><span class="keyword">public</span> Person <span class="title">buildPerson</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">          <span class="keyword">return</span> person;</span></pre></td></tr><tr><td class="code"><pre><span class="line">     &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonDirector</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">     <span class="function"><span class="keyword">public</span> Person <span class="title">constructPerson</span><span class="params">(PersonBuilder pb)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">          pb.buildHead();</span></pre></td></tr><tr><td class="code"><pre><span class="line">          pb.buildBody();</span></pre></td></tr><tr><td class="code"><pre><span class="line">          pb.buildFoot();</span></pre></td></tr><tr><td class="code"><pre><span class="line">          <span class="keyword">return</span> pb.buildPerson();</span></pre></td></tr><tr><td class="code"><pre><span class="line">     &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">     <span class="keyword">private</span> String head;</span></pre></td></tr><tr><td class="code"><pre><span class="line">     <span class="keyword">private</span> String body;</span></pre></td></tr><tr><td class="code"><pre><span class="line">     <span class="keyword">private</span> String foot;</span></pre></td></tr><tr><td class="code"><pre><span class="line"> </span></pre></td></tr><tr><td class="code"><pre><span class="line">     <span class="function"><span class="keyword">public</span> String <span class="title">getHead</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">          <span class="keyword">return</span> head;</span></pre></td></tr><tr><td class="code"><pre><span class="line">     &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHead</span><span class="params">(String head)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">          <span class="keyword">this</span>.head = head;</span></pre></td></tr><tr><td class="code"><pre><span class="line">     &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">     <span class="function"><span class="keyword">public</span> String <span class="title">getBody</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">          <span class="keyword">return</span> body;</span></pre></td></tr><tr><td class="code"><pre><span class="line">     &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBody</span><span class="params">(String body)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">          <span class="keyword">this</span>.body = body;</span></pre></td></tr><tr><td class="code"><pre><span class="line">     &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">     <span class="function"><span class="keyword">public</span> String <span class="title">getFoot</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">          <span class="keyword">return</span> foot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">     &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFoot</span><span class="params">(String foot)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">          <span class="keyword">this</span>.foot = foot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">     &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">PersonDirector pd = <span class="keyword">new</span> PersonDirector();</span></pre></td></tr><tr><td class="code"><pre><span class="line">Person manPerson = pd.constructPerson(<span class="keyword">new</span> ManBuilder());</span></pre></td></tr></table></figure>

<p>建造者（Builder）模式在应用过程中可以根据需要改变，如果创建的产品种类只有一种，只需要一个具体建造者，这时可以省略掉抽象建造者，甚至可以省略掉指挥者角色。</p>
<h3 id="六、享元模式"><a href="#六、享元模式" class="headerlink" title="六、享元模式"></a>六、享元模式</h3><p>定义：运用共享技术来有効地支持大量细粒度对象的复用。它通过共享已经存在的又橡来大幅度减少需要创建的对象数量、避免大量相似类的开销，从而提高系统资源的利用率。</p>
<p>优点：相同对象只要保存一份，这降低了系统中对象的数量，从而降低了系统中细粒度对象给内存带来的压力。</p>
<p>缺点：</p>
<ol>
<li>为了使对象可以共享，需要将一些不能共享的状态外部化，这将增加程序的复杂性。</li>
<li>读取享元模式的外部状态会使得运行时间稍微变长</li>
</ol>
<p>享元模式中存在以下两种状态：</p>
<ol>
<li>内部状态，即不会随着环境的改变而改变的可共享部分；</li>
<li>外部状态，指随环境改变而改变的不可以共享的部分。享元模式的实现要领就是区分应用中的这两种状态，并将外部状态外部化。下面来分析其基本结构和实现方法。</li>
</ol>
<p>享元模式的主要角色有如下。</p>
<ol>
<li>抽象享元角色（Flyweight）:是所有的具体享元类的基类，为具体享元规范需要实现的公共接口，非享元的外部状态以参数的形式通过方法传入。</li>
<li>具体享元（Concrete Flyweight）角色：实现抽象享元角色中所规定的接口。</li>
<li>非享元（Unsharable Flyweight)角色：是不可以共享的外部状态，它以参数的形式注入具体享元的相关方法中。</li>
<li>享元工厂（Flyweight Factory）角色：负责创建和管理享元角色。当客户对象请求一个享元对象时，享元工厂检査系统中是否存在符合要求的享元对象，如果存在则提供给客户；如果不存在的话，则创建一个新的享元对象。</li>
</ol>
<p>享元模式看起来跟单例模式有些相似，但是也有区别：单例模式是类级别的，一个类只能有一个对象实例；享元模式是对象级别的，可以有多个对象实例，多个变量引用同一个对象实例；享元模式可以再次创建对象 也可以取缓存对象，单例模式则是严格控制单个进程中只有一个实例对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">FlyWeight</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">use</span><span class="params">()</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteFlyweight</span> <span class="keyword">extends</span> <span class="title">FlyWeight</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> String string;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    ConcreteFlyweight(String str) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        string = str;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">use</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.println(<span class="string">"使用了享元模式"</span> + string);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FlyweightFactory</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> Hashtable&lt;String, FlyWeight&gt; flyweights = <span class="keyword">new</span> Hashtable&lt;&gt;();</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FlyweightFactory</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> FlyWeight <span class="title">getFlyWeight</span><span class="params">(String name)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        FlyWeight flyweight = flyweights.get(name);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (flyweight == <span class="keyword">null</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            flyweight = <span class="keyword">new</span> ConcreteFlyweight(name);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            flyweights.put(name, flyweight);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> flyweight;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>使用的时候：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> FlyweightFactory().getFlyWeight(<span class="string">"test"</span>).use();</span></pre></td></tr></table></figure>



<h3 id="七、代理模式"><a href="#七、代理模式" class="headerlink" title="七、代理模式"></a>七、代理模式</h3><p>定义：由于某些原因需要给某对象提供一个代理以控制对该对象的访问。这时，访问对象不适合或者不能直接引用目标对象，代理对象作为访问对象和目标对象之间的中介。</p>
<p>优点：</p>
<ul>
<li>代理模式在客户端与目标对象之间起到一个中介作用和保护目标对象的作用；</li>
<li>代理对象可以扩展目标对象的功能；</li>
<li>代理模式能将客户端与目标对象分离，在一定程度上降低了系统的耦合度；</li>
</ul>
<p>缺点是：</p>
<ul>
<li>在客户端和目标对象之间增加一个代理对象，会造成请求处理速度变慢；</li>
<li>增加了系统的复杂度；</li>
</ul>
<p>代理模式的主要角色如下：</p>
<ol>
<li>抽象主题（Subject）类：通过接口或抽象类声明真实主题和代理对象实现的业务方法。</li>
<li>真实主题（Real Subject）类：实现了抽象主题中的具体业务，是代理对象所代表的真实对象，是最终要引用的对象。</li>
<li>代理（Proxy）类：提供了与真实主题相同的接口，其内部含有对真实主题的引用，它可以访问、控制或扩展真实主题的功能。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> RealSubject realSubject;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span>(realSubject==<span class="keyword">null</span>)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            realSubject = <span class="keyword">new</span> RealSubject();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        realSubject.request();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Subject</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">request</span><span class="params">()</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RealSubject</span> <span class="keyword">implements</span> <span class="title">Subject</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.println(<span class="string">"真实的请求"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>应用场景：</p>
<ul>
<li>远程代理，这种方式通常是为了隐藏目标对象存在于不同地址空间的事实，方便客户端访问。例如，用户申请某些网盘空间时，会在用户的文件系统中建立一个虚拟的硬盘，用户访问虚拟硬盘时实际访问的是网盘空间。</li>
<li>虚拟代理，这种方式通常用于要创建的目标对象开销很大时。例如，下载一幅很大的图像需要很长时间，因某种计算比较复杂而短时间无法完成，这时可以先用小比例的虚拟代理替换真实的对象，消除用户对服务器慢的感觉。</li>
<li>安全代理，这种方式通常用于控制不同种类客户对真实对象的访问权限。</li>
<li>智能指引，主要用于调用目标对象时，代理附加一些额外的处理功能。例如，增加计算真实对象的引用次数的功能，这样当该对象没有被引用时，就可以自动释放它。</li>
<li>延迟加载，指为了提高系统的性能，延迟对目标的加载。例如，<a href="http://c.biancheng.net/hibernate/" target="_blank" rel="noopener">Hibernate</a> 中就存在属性的延迟加载和关联表的延时加载。</li>
</ul>
<p>代理模式中，代理类中包含了对真实主题的引用，这种方式存在两个缺点。</p>
<ol>
<li>真实主题与代理主题一一对应，增加真实主题也要增加代理。</li>
<li>设计代理以前真实主题必须事先存在，不太灵活。采用动态代理模式可以解决以上问题，如 <a href="http://c.biancheng.net/spring/" target="_blank" rel="noopener">Spring</a> AOP。</li>
</ol>
<h3 id="八、适配器模式"><a href="#八、适配器模式" class="headerlink" title="八、适配器模式"></a>八、适配器模式</h3><p>定义：将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。适配器模式分为类结构型模式和对象结构型模式两种，前者类之间的耦合度比后者高，且要求程序员了解现有组件库中的相关组件的内部结构，所以应用相对较少些。</p>
<p>优点：</p>
<ul>
<li>客户端通过适配器可以透明地调用目标接口。</li>
<li>复用了现存的类，程序员不需要修改原有代码而重用现有的适配者类。</li>
<li>将目标类和适配者类解耦，解决了目标类和适配者类接口不一致的问题。</li>
</ul>
<p>缺点是：对类适配器来说，更换适配器的实现过程比较复杂。</p>
<p>适配器模式（Adapter）包含以下主要角色：</p>
<ol>
<li>目标（Target）接口：当前系统业务所期待的接口，它可以是抽象类或接口。</li>
<li>适配者（Adaptee）类：它是被访问和适配的现存组件库中的组件接口。</li>
<li>适配器（Adapter）类：它是一个转换器，通过继承或引用适配者的对象，把适配者接口转换成目标接口，让客户按目标接口的格式访问适配者。</li>
</ol>
<p>类结构模式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Adapter</span> <span class="keyword">extends</span> <span class="title">Adaptee</span> <span class="keyword">implements</span> <span class="title">target</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        specificRequest();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Adaptee</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">specificRequest</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.println(<span class="string">"适配者中的业务代码被调用！"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">target</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">request</span><span class="params">()</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>对象结构模式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ObjectAdapter</span> <span class="keyword">implements</span> <span class="title">Target</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> Adaptee adaptee;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ObjectAdapter</span><span class="params">(Adaptee adaptee)</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">    </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">this</span>.adaptee=adaptee;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">    </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        adaptee.specificRequest();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>适配器模式（Adapter）通常适用于以下场景：</p>
<ul>
<li>以前开发的系统存在满足新系统功能需求的类，但其接口同新系统的接口不一致。</li>
<li>使用第三方提供的组件，但组件接口定义和自己要求的接口定义不同。</li>
</ul>
<p>扩展：适配器模式（Adapter）可扩展为双向适配器模式，双向适配器类既可以把适配者接口转换成目标接口，也可以把目标接口转换成适配者接口。</p>
<h3 id="九、桥接模式"><a href="#九、桥接模式" class="headerlink" title="九、桥接模式"></a>九、桥接模式</h3><p>定义：将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现，从而降低了抽象和实现这两个可变维度的耦合度。</p>
<p>优点是：</p>
<ul>
<li>由于抽象与实现分离，所以扩展能力强；</li>
<li>其实现细节对客户透明。</li>
</ul>
<p>缺点：由于聚合关系建立在抽象层，要求开发者针对抽象化进行设计与编程，这增加了系统的理解与设计难度。</p>
<p>桥接（Bridge）模式包含以下主要角色。</p>
<ol>
<li>抽象化（Abstraction）角色：定义抽象类，并包含一个对实现化对象的引用。</li>
<li>扩展抽象化（Refined  Abstraction）角色：是抽象化角色的子类，实现父类中的业务方法，并通过组合关系调用实现化角色中的业务方法。</li>
<li>实现化（Implementor）角色：定义实现化角色的接口，供扩展抽象化角色调用。</li>
<li>具体实现化（Concrete Implementor）角色：给出实现化角色接口的具体实现。</li>
</ol>
<p>光看这些概念上的东西确实很难理解，桥接模式也是比较复杂的设计模式了，主要是为了应对多个维度上的变化。举个栗子。假设我们需要一辆车，车按照用途可以分为小汽车、货车和大巴车，按照颜色可以分为黑色和白色和灰色。如果遵循单一职责原则，每一种车每一个颜色都要一个类，如果再有新的颜色，就要分别在三种车里面增加，就太麻烦了。于是可以用这种方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Vehicle</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> Color color;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Vehicle</span><span class="params">(Color color)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">this</span>.color = color;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">info</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">this</span>.color.getColor();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bus</span> <span class="keyword">extends</span> <span class="title">Vehicle</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Bus</span><span class="params">(Color color)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">super</span>(color);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span> <span class="keyword">extends</span> <span class="title">Vehicle</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Car</span><span class="params">(Color color)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">super</span>(color);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Truck</span> <span class="keyword">extends</span> <span class="title">Vehicle</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Truck</span><span class="params">(Color color)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">super</span>(color);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Color</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getColor</span><span class="params">()</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Black</span> <span class="keyword">implements</span> <span class="title">Color</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getColor</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.println(<span class="string">"这是黑色的车"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">White</span> <span class="keyword">implements</span> <span class="title">Color</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getColor</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.println(<span class="string">"这是白色的车"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Grey</span> <span class="keyword">implements</span> <span class="title">Color</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getColor</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.println(<span class="string">"这是灰色的车"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>只需要传入对应的颜色，就可以选择需要的车：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Vehicle vehicle = <span class="keyword">new</span> Bus(<span class="keyword">new</span> White());</span></pre></td></tr><tr><td class="code"><pre><span class="line">vehicle.info();</span></pre></td></tr></table></figure>

<p>如果这时候需要新的属性怎么办？比如新增一个分类，按照能源类型分类，将车分为电动车和汽油车，只需要新增一个接口，扩展<code>Vehicle</code>的构造器就可以了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Energy</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getEnergy</span><span class="params">()</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Electric</span> <span class="keyword">implements</span> <span class="title">Energy</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getEnergy</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.println(<span class="string">"这时电能的车"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Vehicle</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> Color color;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> Energy energy;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Vehicle</span><span class="params">(Color color)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">this</span>.color = color;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Vehicle</span><span class="params">(Color color, Energy energy)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">this</span>.color = color;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">this</span>.energy = energy;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">info</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">this</span>.color.getColor();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">this</span>.energy.getEnergy();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>桥接模式通常适用于以下场景：</p>
<ol>
<li>当一个类存在多个独立变化的维度，且这多个维度都需要进行扩展时。</li>
<li>当一个系统不希望使用继承或因为多层次继承导致系统类的个数急剧增加时。</li>
<li>当一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性时。</li>
</ol>
<h3 id="十、装饰模式"><a href="#十、装饰模式" class="headerlink" title="十、装饰模式"></a>十、装饰模式</h3><p>定义：指在不改变现有对象结构的情况下，动态地给该对象增加一些职责（即增加其额外功能）的模式，它属于对象结构型模式。</p>
<p>优点：装饰类和被装饰类可以独立发展，不会相互耦合，装饰模式是继承的一个替代模式，装饰模式可以动态扩展一个实现类的功能。</p>
<p>缺点：多层装饰比较复杂。</p>
<p>这个直接上代码比较好理解。假如我们实现了画圆的功能：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Shape</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">implements</span> <span class="title">Shape</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.println(<span class="string">"画圆"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>这时候画圆很简单，只需要<code>new Circle().draw();</code>就可以了。但是我们想扩展新的功能，因为开闭原则又不能直接修改<code>draw()</code>这个方法，那应该怎么办？答案是加个装饰器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ShapeDecorator</span> <span class="keyword">implements</span> <span class="title">Shape</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Shape decoratedShape;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ShapeDecorator</span><span class="params">(Shape shape)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">this</span>.decoratedShape = shape;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        decoratedShape.draw();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RedBorderDecorator</span> <span class="keyword">extends</span> <span class="title">ShapeDecorator</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RedBorderDecorator</span><span class="params">(Shape shape)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">super</span>(shape);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">super</span>.draw();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        setRedBorder();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setRedBorder</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.println(<span class="string">"加上了红色边框"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>只需要<code>new RedBorderDecorator(new Circle()).draw();</code>就可以画带着红边框的圆形啦。</p>
<p>使用场景： 1、扩展一个类的功能。 2、动态增加功能，动态撤销。</p>
<h3 id="十一、外观模式"><a href="#十一、外观模式" class="headerlink" title="十一、外观模式"></a>十一、外观模式</h3><p>定义：是一种通过为多个复杂的子系统提供一个一致的接口，而使这些子系统更加容易被访问的模式。该模式对外有一个统一接口，外部应用程序不用关心内部子系统的具体的细节，这样会大大降低应用程序的复杂度，提高了程序的可维护性。</p>
<p>外观（Facade）模式是“迪米特法则”的典型应用，它有以下主要优点。</p>
<ol>
<li>降低了子系统与客户端之间的耦合度，使得子系统的变化不会影响调用它的客户类。</li>
<li>对客户屏蔽了子系统组件，减少了客户处理的对象数目，并使得子系统使用起来更加容易。</li>
<li>降低了大型软件系统中的编译依赖性，简化了系统在不同平台之间的移植过程，因为编译一个子系统不会影响其他的子系统，也不会影响外观对象。</li>
</ol>
<p>缺点如:</p>
<ol>
<li>不能很好地限制客户使用子系统类。</li>
<li>增加新的子系统可能需要修改外观类或客户端的源代码，违背了“开闭原则”。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Facade</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> SubSystem01 obj1 = <span class="keyword">new</span> SubSystem01();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> SubSystem02 obj2 = <span class="keyword">new</span> SubSystem02();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> SubSystem03 obj3 = <span class="keyword">new</span> SubSystem03();</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        obj1.method1();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        obj2.method2();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        obj3.method3();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubSystem01</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.println(<span class="string">"子系统01的method1()被调用！"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubSystem02</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.println(<span class="string">"子系统02的method2()被调用！"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubSystem03</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.println(<span class="string">"子系统03的method3()被调用！"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>执行方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Facade().method();</span></pre></td></tr></table></figure>

<p>可以看出子系统的实现细节被屏蔽，外部程序不需要关系具体实现细节。</p>
<h3 id="十二、组合模式"><a href="#十二、组合模式" class="headerlink" title="十二、组合模式"></a>十二、组合模式</h3><p>定义：有时又叫作部分-整体模式，它是一种将对象组合成树状的层次结构的模式，用来表示“部分-整体”的关系，使用户对单个对象和组合对象具有一致的访问性。</p>
<p>优点：</p>
<ol>
<li>组合模式使得客户端代码可以一致地处理单个对象和组合对象，无须关心自己处理的是单个对象，还是组合对象，这简化了客户端代码；</li>
<li>更容易在组合体内加入新的对象，客户端不会因为加入了新的对象而更改源代码，满足“开闭原则”；</li>
</ol>
<p>缺点：</p>
<ol>
<li>设计较复杂，客户端需要花更多时间理清类之间的层次关系；</li>
<li>不容易限制容器中的构件；</li>
<li>不容易用继承的方法来增加构件的新功能；</li>
</ol>
<p>组合模式包含以下主要角色。</p>
<ol>
<li>抽象构件（Component）角色：它的主要作用是为树叶构件和树枝构件声明公共接口，并实现它们的默认行为。在透明式的组合模式中抽象构件还声明访问和管理子类的接口；在安全式的组合模式中不声明访问和管理子类的接口，管理工作由树枝构件完成。</li>
<li>树叶构件（Leaf）角色：是组合中的叶节点对象，它没有子节点，用于实现抽象构件角色中声明的公共接口。</li>
<li>树枝构件（Composite）角色：是组合中的分支节点对象，它有子节点。它实现了抽象构件角色中声明的接口，它的主要作用是存储和管理子部件，通常包含 <code>Add()</code>、<code>Remove()</code>、<code>GetChild()</code> 等方法。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Component</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Component c)</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Component c)</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> Component <span class="title">getChild</span><span class="params">(<span class="keyword">int</span> i)</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//树叶构件</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Leaf</span> <span class="keyword">implements</span> <span class="title">Component</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> String name;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Leaf</span><span class="params">(String name)</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">    </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">this</span>.name=name;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Component c)</span></span>&#123; &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Component c)</span></span>&#123; &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> Component <span class="title">getChild</span><span class="params">(<span class="keyword">int</span> i)</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">    </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">    </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.println(<span class="string">"树叶"</span>+name+<span class="string">"：被访问！"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//树枝构件</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Composite</span> <span class="keyword">implements</span> <span class="title">Component</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> ArrayList&lt;Component&gt; children=<span class="keyword">new</span> ArrayList&lt;Component&gt;();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Component c)</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">    </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        children.add(c);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Component c)</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">    </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        children.remove(c);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> Component <span class="title">getChild</span><span class="params">(<span class="keyword">int</span> i)</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">    </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> children.get(i);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">    </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span>(Object obj:children)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            ((Component)obj).operation();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>可以看出，组合模式就是将多个对象用容器组合一个树形结构的对象。</p>
<p>使用场景：</p>
<ol>
<li>在需要表示一个对象整体与部分的层次结构的场合。</li>
<li>要求对用户隐藏组合对象与单个对象的不同，用户可以用统一的接口使用组合结构中的所有对象的场合</li>
</ol>
<h3 id="十三、策略模式"><a href="#十三、策略模式" class="headerlink" title="十三、策略模式"></a>十三、策略模式</h3><p>定义：该模式定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的变化不会影响使用算法的客户。策略模式属于对象行为模式，它通过对算法进行封装，把使用算法的责任和算法的实现分割开来，并委派给不同的对象对这些算法进行管理。</p>
<p>优点：</p>
<ol>
<li>多重条件语句不易维护，而使用策略模式可以避免使用多重条件语句。</li>
<li>策略模式提供了一系列的可供重用的算法族，恰当使用继承可以把算法族的公共代码转移到父类里面，从而避免重复的代码。</li>
<li>策略模式可以提供相同行为的不同实现，客户可以根据不同时间或空间要求选择不同的。</li>
<li>策略模式提供了对开闭原则的完美支持，可以在不修改原代码的情况下，灵活增加新算法。</li>
<li>策略模式把算法的使用放到环境类中，而算法的实现移到具体策略类中，实现了二者的分离。</li>
</ol>
<p>缺点：</p>
<ol>
<li>客户端必须理解所有策略算法的区别，以便适时选择恰当的算法类。</li>
<li>策略模式造成很多的策略类。</li>
</ol>
<p>举个栗子，假如我们想提供一个算法，但是内部实现有可能更改或者增加。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Strategy</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">doOperation</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OperationAdd</span> <span class="keyword">implements</span> <span class="title">Strategy</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">doOperation</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> num1 + num2;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OperationMultiply</span> <span class="keyword">implements</span> <span class="title">Strategy</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">doOperation</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> num1 * num2;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Context</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> Strategy strategy;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Context</span><span class="params">(Strategy strategy)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">this</span>.strategy = strategy;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">executeStrategy</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> strategy.doOperation(num1, num2);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>这样的话，就可以调用的时候选择不同的算法实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Context context = <span class="keyword">new</span> Context(<span class="keyword">new</span> OperationAdd());</span></pre></td></tr><tr><td class="code"><pre><span class="line">System.out.println(<span class="string">"10 + 5 = "</span> + context.executeStrategy(<span class="number">10</span>, <span class="number">5</span>));</span></pre></td></tr><tr><td class="code"><pre><span class="line">context = <span class="keyword">new</span> Context(<span class="keyword">new</span> OperationMultiply());</span></pre></td></tr><tr><td class="code"><pre><span class="line">System.out.println(<span class="string">"10 * 5 = "</span> + context.executeStrategy(<span class="number">10</span>, <span class="number">5</span>));</span></pre></td></tr></table></figure>

<p>扩展：在一个使用策略模式的系统中，当存在的策略很多时，客户端管理所有策略算法将变得很复杂，如果在环境类中使用策略工厂模式来管理这些策略类将大大减少客户端的工作复杂度。</p>
<h3 id="十四、责任链模式"><a href="#十四、责任链模式" class="headerlink" title="十四、责任链模式"></a>十四、责任链模式</h3><p>定义：为了避免请求发送者与多个请求处理者耦合在一起，将所有请求的处理者通过前一对象记住其下一个对象的引用而连成一条链；当有请求发生时，可将请求沿着这条链传递，直到有对象处理它为止。</p>
<p>优点：</p>
<ol>
<li>降低了对象之间的耦合度。该模式使得一个对象无须知道到底是哪一个对象处理其请求以及链的结构，发送者和接收者也无须拥有对方的明确信息。</li>
<li>增强了系统的可扩展性。可以根据需要增加新的请求处理类，满足开闭原则。</li>
<li>增强了给对象指派职责的灵活性。当工作流程发生变化，可以动态地改变链内的成员或者调动它们的次序，也可动态地新增或者删除责任。</li>
<li>责任链简化了对象之间的连接。每个对象只需保持一个指向其后继者的引用，不需保持其他所有处理者的引用，这避免了使用众多的 if 或者 if···else 语句。</li>
<li>责任分担。每个类只需要处理自己该处理的工作，不该处理的传递给下一个对象完成，明确各类的责任范围，符合类的单一职责原则。</li>
</ol>
<p>缺点：</p>
<ol>
<li>不能保证每个请求一定被处理。由于一个请求没有明确的接收者，所以不能保证它一定会被处理，该请求可能一直传到链的末端都得不到处理。</li>
<li>对比较长的职责链，请求的处理可能涉及多个处理对象，系统性能将受到一定影响。</li>
<li>职责链建立的合理性要靠客户端来保证，增加了客户端的复杂性，可能会由于职责链的错误设置而导致系统出错，如可能会造成循环调用。</li>
</ol>
<p>职责链模式主要包含以下角色：</p>
<ol>
<li>抽象处理者（Handler）角色：定义一个处理请求的接口，包含抽象处理方法和一个后继连接。</li>
<li>具体处理者（Concrete Handler）角色：实现抽象处理者的处理方法，判断能否处理本次请求，如果可以处理请求则处理，否则将该请求转给它的后继者。</li>
<li>客户类（Client）角色：创建处理链，并向链头的具体处理者对象提交请求，它不关心处理细节和请求的传递过程。</li>
</ol>
<p>现在假设我们要设计一个日志系统，日志等级从低到高分为debug、info、error：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractLogger</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> DEBUG = <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> INFO = <span class="number">2</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> ERROR = <span class="number">3</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> level;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//责任链中的下一个元素</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">protected</span> AbstractLogger nextLogger;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNextLogger</span><span class="params">(AbstractLogger nextLogger)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">this</span>.nextLogger = nextLogger;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">logMessage</span><span class="params">(<span class="keyword">int</span> level, String message)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.level &lt;= level) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            write(message);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (nextLogger != <span class="keyword">null</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            nextLogger.logMessage(level, message);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(String message)</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConsoleLogger</span> <span class="keyword">extends</span> <span class="title">AbstractLogger</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConsoleLogger</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">this</span>.level = DEBUG;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        setNextLogger(<span class="keyword">new</span> FileLogger());</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(String message)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.println(<span class="string">"Standard Console::Logger: "</span> + message);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileLogger</span> <span class="keyword">extends</span> <span class="title">AbstractLogger</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FileLogger</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">this</span>.level = INFO;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        setNextLogger(<span class="keyword">new</span> ErrorLogger());</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(String message)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.println(<span class="string">"File::Logger: "</span> + message);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ErrorLogger</span> <span class="keyword">extends</span> <span class="title">AbstractLogger</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ErrorLogger</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">this</span>.level = ERROR;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(String message)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.println(<span class="string">"Error Console::Logger: "</span> + message);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>使用的时候，会顺着责任链传下去，判断使用对应日志等级方法的进行处理：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AbstractLogger loggerChain = <span class="keyword">new</span> ConsoleLogger();</span></pre></td></tr><tr><td class="code"><pre><span class="line">loggerChain.logMessage(AbstractLogger.ERROR, <span class="string">"This is an information."</span>);</span></pre></td></tr></table></figure>

<p>应用场景：</p>
<ol>
<li>有多个对象可以处理一个请求，哪个对象处理该请求由运行时刻自动确定。</li>
<li>可动态指定一组对象处理请求，或添加新的处理者。</li>
<li>在不明确指定请求处理者的情况下，向多个处理者中的一个提交请求。</li>
</ol>
<p>扩展，责任链可以分为两种情况：</p>
<ol>
<li>纯的责任链模式：一个请求必须被某一个处理者对象所接收，且一个具体处理者对某个请求的处理只能采用以下两种行为之一：自己处理（承担责任）；把责任推给下家处理。</li>
<li>不纯的责任链模式：允许出现某一个具体处理者对象在承担了请求的一部分责任后又将剩余的责任传给下家的情况，且一个请求可以最终不被任何接收端对象所接收。</li>
</ol>
<h3 id="十五、模板方法模式"><a href="#十五、模板方法模式" class="headerlink" title="十五、模板方法模式"></a>十五、模板方法模式</h3><p>定义：定义一个操作中的算法骨架，而将算法的一些步骤延迟到子类中，使得子类可以不改变该算法结构的情况下重定义该算法的某些特定步骤。它是一种类行为型模式。</p>
<p>优点：</p>
<ol>
<li>它封装了不变部分，扩展可变部分。它把认为是不变部分的算法封装到父类中实现，而把可变部分算法由子类继承实现，便于子类继续扩展。</li>
<li>它在父类中提取了公共的部分代码，便于代码复用。</li>
<li>部分方法是由子类实现的，因此子类可以通过扩展方式增加相应的功能，符合开闭原则。</li>
</ol>
<p>缺点：</p>
<ol>
<li>对每个不同的实现都需要定义一个子类，这会导致类的个数增加，系统更加庞大，设计也更加抽象。</li>
<li>父类中的抽象方法由子类实现，子类执行的结果会影响父类的结果，这导致一种反向的控制结构，它提高了代码阅读的难度。</li>
</ol>
<p>模板方法模式包含以下主要角色。</p>
<ul>
<li><p>抽象类（Abstract Class）：负责给出一个算法的轮廓和骨架。它由一个模板方法和若干个基本方法构成。这些方法的定义如下：</p>
<ol>
<li>模板方法：定义了算法的骨架，按某种顺序调用其包含的基本方法。</li>
<li>基本方法：是整个算法中的一个步骤，包含以下几种类型：<ul>
<li>抽象方法：在抽象类中申明，由具体子类实现。</li>
<li>具体方法：在抽象类中已经实现，在具体子类中可以继承或重写它。</li>
<li>钩子方法：在抽象类中已经实现，包括用于判断的逻辑方法和需要子类重写的空方法两种。</li>
</ul>
</li>
</ol>
</li>
<li><p>具体子类（Concrete Class）：实现抽象类中所定义的抽象方法和钩子方法，它们是一个顶级逻辑的一个组成步骤</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractClass</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TemplateMethod</span><span class="params">()</span> <span class="comment">//模板方法</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">    </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        SpecificMethod();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        abstractMethod1();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        abstractMethod2();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SpecificMethod</span><span class="params">()</span> <span class="comment">//具体方法</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">    </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.println(<span class="string">"抽象类中的具体方法被调用..."</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">abstractMethod1</span><span class="params">()</span></span>; <span class="comment">//抽象方法1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">abstractMethod2</span><span class="params">()</span></span>; <span class="comment">//抽象方法2</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//具体子类</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteClass</span> <span class="keyword">extends</span> <span class="title">AbstractClass</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">abstractMethod1</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.println(<span class="string">"抽象方法1的实现被调用..."</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">abstractMethod2</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.println(<span class="string">"抽象方法2的实现被调用..."</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>模板方法模式通常适用于以下场景：</p>
<ol>
<li>算法的整体步骤很固定，但其中个别部分易变时，这时候可以使用模板方法模式，将容易变的部分抽象出来，供子类实现。</li>
<li>当多个子类存在公共的行为时，可以将其提取出来并集中到一个公共父类中以避免代码重复。首先，要识别现有代码中的不同之处，并且将不同之处分离为新的操作。最后，用一个调用这些新的操作的模板方法来替换这些不同的代码。</li>
<li>当需要控制子类的扩展时，模板方法只在特定点调用钩子操作，这样就只允许在这些点进行扩展。</li>
</ol>
<h3 id="十六、命令模式"><a href="#十六、命令模式" class="headerlink" title="十六、命令模式"></a>十六、命令模式</h3><p>定义：将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。这样两者之间通过命令对象进行沟通，这样方便将命令对象进行储存、传递、调用、增加与管理。</p>
<p>优点：</p>
<ol>
<li>降低系统的耦合度。命令模式能将调用操作的对象与实现该操作的对象解耦。</li>
<li>增加或删除命令非常方便。采用命令模式增加与删除命令不会影响其他类，它满足“开闭原则”，对扩展比较灵活。</li>
<li>可以实现宏命令。命令模式可以与组合模式结合，将多个命令装配成一个组合命令，即宏命令。</li>
<li>方便实现 Undo 和 Redo 操作。命令模式可以与备忘录模式结合，实现命令的撤销与恢复。</li>
</ol>
<p>缺点是：可能产生大量具体命令类。因为计对每一个具体操作都需要设计一个具体命令类，这将增加系统的复杂性。</p>
<p>命令模式包含以下主要角色：</p>
<ol>
<li>抽象命令类（Command）角色：声明执行命令的接口，拥有执行命令的抽象方法 execute()。</li>
<li>具体命令角色（Concrete  Command）角色：是抽象命令类的具体实现类，它拥有接收者对象，并通过调用接收者的功能来完成命令要执行的操作。</li>
<li>实现者/接收者（Receiver）角色：执行命令功能的相关操作，是具体命令对象业务的真正实现者。</li>
<li>调用者/请求者（Invoker）角色：是请求的发送者，它通常拥有很多的命令对象，并通过访问命令对象来执行相关请求，它不直接访问接收者。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//调用者</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Invoker</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> Command command;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Invoker</span><span class="params">(Command command)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">this</span>.command = command;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCommand</span><span class="params">(Command command)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">this</span>.command = command;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.println(<span class="string">"调用者执行命令command..."</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        command.execute();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//抽象命令</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Command</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//具体命令</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteCommand</span> <span class="keyword">implements</span> <span class="title">Command</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> Receiver receiver;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    ConcreteCommand() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        receiver = <span class="keyword">new</span> Receiver();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        receiver.action();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//接收者</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Receiver</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">action</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.println(<span class="string">"接收者的action()方法被调用..."</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>使用的时候：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Command cmd = <span class="keyword">new</span> ConcreteCommand();</span></pre></td></tr><tr><td class="code"><pre><span class="line">Invoker ir = <span class="keyword">new</span> Invoker(cmd);</span></pre></td></tr><tr><td class="code"><pre><span class="line">System.out.println(<span class="string">"客户访问调用者的call()方法..."</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">ir.call();</span></pre></td></tr></table></figure>

<p>命令模式通常适用于以下场景：</p>
<ol>
<li>当系统需要将请求调用者与请求接收者解耦时，命令模式使得调用者和接收者不直接交互。</li>
<li>当系统需要随机请求命令或经常增加或删除命令时，命令模式比较方便实现这些功能。</li>
<li>当系统需要执行一组操作时，命令模式可以定义宏命令来实现该功能。</li>
<li>当系统需要支持命令的撤销（Undo）操作和恢复（Redo）操作时，可以将命令对象存储起来，采用备忘录模式来实现。</li>
</ol>
<h3 id="十七、访问者模式"><a href="#十七、访问者模式" class="headerlink" title="十七、访问者模式"></a>十七、访问者模式</h3><p>定义：将作用于某种数据结构中的各元素的操作分离出来封装成独立的类，使其在不改变数据结构的前提下可以添加作用于这些元素的新的操作，为数据结构中的每个元素提供多种访问方式。它将对数据的操作与数据结构进行分离，是行为类模式中最复杂的一种模式。</p>
<p>优点：</p>
<ol>
<li>扩展性好。能够在不修改对象结构中的元素的情况下，为对象结构中的元素添加新的功能。</li>
<li>复用性好。可以通过访问者来定义整个对象结构通用的功能，从而提高系统的复用程度。</li>
<li>灵活性好。访问者模式将数据结构与作用于结构上的操作解耦，使得操作集合可相对自由地演化而不影响系统的数据结构。</li>
<li>符合单一职责原则。访问者模式把相关的行为封装在一起，构成一个访问者，使每一个访问者的功能都比较单一。</li>
</ol>
<p>缺点：</p>
<ol>
<li>增加新的元素类很困难。在访问者模式中，每增加一个新的元素类，都要在每一个具体访问者类中增加相应的具体操作，这违背了“开闭原则”。</li>
<li>破坏封装。访问者模式中具体元素对访问者公布细节，这破坏了对象的封装性。</li>
<li>违反了依赖倒置原则。访问者模式依赖了具体类，而没有依赖抽象类。</li>
</ol>
<p>主要角色：</p>
<ol>
<li>抽象访问者（Visitor）角色：定义一个访问具体元素的接口，为每个具体元素类对应一个访问操作 visit() ，该操作中的参数类型标识了被访问的具体元素。</li>
<li>具体访问者（ConcreteVisitor）角色：实现抽象访问者角色中声明的各个访问操作，确定访问者访问一个元素时该做什么。</li>
<li>抽象元素（Element）角色：声明一个包含接受操作 <code>accept()</code> 的接口，被接受的访问者对象作为 <code>accept()</code> 方法的参数。</li>
<li>具体元素（ConcreteElement）角色：实现抽象元素角色提供的 <code>accept()</code> 操作，其方法体通常都是 <code>visitor.visit(this)</code> ，另外具体元素中可能还包含本身业务逻辑的相关操作。</li>
<li>对象结构（Object Structure）角色：是一个包含元素角色的容器，提供让访问者对象遍历容器中的所有元素的方法，通常由 List、Set、Map 等聚合类实现。</li>
</ol>
<p>假设这样一种场景，有多种角色要使用多种物品，其中角色和物品都有可能变动，每个角色使用方式不一样，每种物品提供的功能也不一样，要怎么做设计？我们以电脑为例，假设有笔记本和台式机，使用者分为游戏玩家和程序猿：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Visitor</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">visit</span><span class="params">(Laptop element)</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">visit</span><span class="params">(Desktop element)</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//具体访问者游戏玩家</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Gamer</span> <span class="keyword">implements</span> <span class="title">Visitor</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(Laptop element)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.println(<span class="string">"游戏玩家使用笔记本--&gt;"</span> + element.use());</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(Desktop element)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.println(<span class="string">"游戏玩家使用台式机--&gt;"</span> + element.use());</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//具体访问者程序猿</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Programmer</span> <span class="keyword">implements</span> <span class="title">Visitor</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(Laptop element)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.println(<span class="string">"程序猿使用笔记本--&gt;"</span> + element.use());</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(Desktop element)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.println(<span class="string">"程序猿使用台式机--&gt;"</span> + element.use());</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//抽象元素类</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Computer</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">accept</span><span class="params">(Visitor visitor)</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//具体元素笔记本类</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Laptop</span> <span class="keyword">implements</span> <span class="title">Computer</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Visitor visitor)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        visitor.visit(<span class="keyword">this</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">use</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="string">"使用笔记本的操作"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//具体元素台式机类</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Desktop</span> <span class="keyword">implements</span> <span class="title">Computer</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Visitor visitor)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        visitor.visit(<span class="keyword">this</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">use</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="string">"使用台式机的操作"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//对象结构角色</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ObjectStructure</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> List&lt;Computer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Visitor visitor)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Iterator&lt;Computer&gt; i = list.iterator();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">while</span> (i.hasNext()) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            i.next().accept(visitor);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Computer element)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        list.add(element);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Computer element)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        list.remove(element);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>可以看到，无论使用者和物品怎么增加，只需要增加<code>Visitor</code>和<code>Computer</code>两个接口的对应实现类就可以了。</p>
<p>使用方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ObjectStructure os = <span class="keyword">new</span> ObjectStructure();</span></pre></td></tr><tr><td class="code"><pre><span class="line">os.add(<span class="keyword">new</span> Desktop());</span></pre></td></tr><tr><td class="code"><pre><span class="line">os.add(<span class="keyword">new</span> Laptop());</span></pre></td></tr><tr><td class="code"><pre><span class="line">Visitor visitor = <span class="keyword">new</span> Programmer();</span></pre></td></tr><tr><td class="code"><pre><span class="line">os.accept(visitor);</span></pre></td></tr><tr><td class="code"><pre><span class="line">System.out.println(<span class="string">"------------------------"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">visitor = <span class="keyword">new</span> Gamer();</span></pre></td></tr><tr><td class="code"><pre><span class="line">os.accept(visitor);</span></pre></td></tr></table></figure>

<p>通常在以下情况可以考虑使用访问者（Visitor）模式：</p>
<ol>
<li>对象结构相对稳定，但其操作算法经常变化的程序。</li>
<li>对象结构中的对象需要提供多种不同且不相关的操作，而且要避免让这些操作的变化影响对象的结构。</li>
<li>对象结构包含很多类型的对象，希望对这些对象实施一些依赖于其具体类型的操作。</li>
</ol>
<p>扩展：</p>
<p>访问者（Visitor）模式是使用频率较高的一种设计模式，它常常同以下两种设计模式联用。</p>
<p>(1)与“迭代器模式”联用。因为访问者模式中的“对象结构”是一个包含元素角色的容器，当访问者遍历容器中的所有元素时，常常要用迭代器。</p>
<p>(2)访问者（Visitor）模式同“组合模式”联用。因为访问者（Visitor）模式中的“元素对象”可能是叶子对象或者是容器对象，如果元素对象包含容器对象，就必须用到组合模式)。</p>
<h3 id="十八、迭代器模式"><a href="#十八、迭代器模式" class="headerlink" title="十八、迭代器模式"></a>十八、迭代器模式</h3><p>定义：提供一个对象来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示。</p>
<p>优点：</p>
<ol>
<li>访问一个聚合对象的内容而无须暴露它的内部表示。</li>
<li>遍历任务交由迭代器完成，这简化了聚合类。</li>
<li>它支持以不同方式遍历一个聚合，甚至可以自定义迭代器的子类以支持新的遍历。</li>
<li>增加新的聚合类和迭代器类都很方便，无须修改原有代码。</li>
<li>封装性良好，为遍历不同的聚合结构提供一个统一的接口。</li>
</ol>
<p>缺点：增加了类的个数，这在一定程度上增加了系统的复杂性。、</p>
<p>迭代器模式主要包含以下角色。</p>
<ol>
<li>抽象聚合（Aggregate）角色：定义存储、添加、删除聚合对象以及创建迭代器对象的接口。</li>
<li>具体聚合（ConcreteAggregate）角色：实现抽象聚合类，返回一个具体迭代器的实例。</li>
<li>抽象迭代器（Iterator）角色：定义访问和遍历聚合元素的接口，通常包含 hasNext()、first()、next() 等方法。</li>
<li>具体迭代器（Concretelterator）角色：实现抽象迭代器接口中所定义的方法，完成对聚合对象的遍历，记录遍历的当前位置。</li>
</ol>
<p>迭代器的原理几乎不用解释了，各种<code>JDK</code>中的容器类里就常见。一个简单的实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Iterator</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">next</span><span class="params">()</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Container</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> Iterator <span class="title">getIterator</span><span class="params">()</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NameRepository</span> <span class="keyword">implements</span> <span class="title">Container</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> String names[] = &#123;<span class="string">"Robert"</span>, <span class="string">"John"</span>, <span class="string">"Julie"</span>, <span class="string">"Lora"</span>&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> Iterator <span class="title">getIterator</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> NameIterator();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">NameIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> index;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="meta">@Override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (index &lt; names.length) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="meta">@Override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">next</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.hasNext()) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">return</span> names[index++];</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>使用方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">NameRepository namesRepository = <span class="keyword">new</span> NameRepository();</span></pre></td></tr><tr><td class="code"><pre><span class="line"> </span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(Iterator iter = namesRepository.getIterator(); iter.hasNext();)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">   String name = (String)iter.next();</span></pre></td></tr><tr><td class="code"><pre><span class="line">   System.out.println(<span class="string">"Name : "</span> + name);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>应用场景：</p>
<ol>
<li>当需要为聚合对象提供多种遍历方式时。</li>
<li>当需要为遍历不同的聚合结构提供一个统一的接口时。</li>
<li>当访问一个聚合对象的内容而无须暴露其内部细节的表示时。</li>
</ol>
<h3 id="十九、观察者模式"><a href="#十九、观察者模式" class="headerlink" title="十九、观察者模式"></a>十九、观察者模式</h3><p>定义：指多个对象间存在一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。这种模式有时又称作发布-订阅模式、模型-视图模式，它是对象行为型模式。</p>
<p>优点：</p>
<ol>
<li>降低了目标与观察者之间的耦合关系，两者之间是抽象耦合关系。</li>
<li>目标与观察者之间建立了一套触发机制。</li>
</ol>
<p>缺点：</p>
<ol>
<li>目标与观察者之间的依赖关系并没有完全解除，而且有可能出现循环引用。</li>
<li>当观察者对象很多时，通知的发布会花费很多时间，影响程序的效率。</li>
</ol>
<p>观察者模式的主要角色：</p>
<ol>
<li>抽象主题（Subject）角色：也叫抽象目标类，它提供了一个用于保存观察者对象的聚集类和增加、删除观察者对象的方法，以及通知所有观察者的抽象方法。</li>
<li>具体主题（Concrete  Subject）角色：也叫具体目标类，它实现抽象目标中的通知方法，当具体主题的内部状态发生改变时，通知所有注册过的观察者对象。</li>
<li>抽象观察者（Observer）角色：它是一个抽象类或接口，它包含了一个更新自己的抽象方法，当接到具体主题的更改通知时被调用。</li>
<li>具体观察者（Concrete Observer）角色：实现抽象观察者中定义的抽象方法，以便在得到目标的更改通知时更新自身的状态。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Observer</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">response</span><span class="params">()</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//具体观察者1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteObserver1</span> <span class="keyword">implements</span> <span class="title">Observer</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">response</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.println(<span class="string">"具体观察者1作出反应！"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//具体观察者1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteObserver2</span> <span class="keyword">implements</span> <span class="title">Observer</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">response</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.println(<span class="string">"具体观察者2作出反应！"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;<span class="comment">//抽象目标</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Subject</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">protected</span> List&lt;Observer&gt; observers = <span class="keyword">new</span> ArrayList&lt;Observer&gt;();</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//增加观察者方法</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Observer observer)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        observers.add(observer);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//删除观察者方法</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Observer observer)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        observers.remove(observer);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">notifyObserver</span><span class="params">()</span></span>; <span class="comment">//通知观察者方法</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//具体目标</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteSubject</span> <span class="keyword">extends</span> <span class="title">Subject</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyObserver</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.println(<span class="string">"具体目标发生改变..."</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.println(<span class="string">"--------------"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> (Object obs : observers) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            ((Observer) obs).response();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>使用方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Subject subject = <span class="keyword">new</span> ConcreteSubject();</span></pre></td></tr><tr><td class="code"><pre><span class="line">Observer obs1 = <span class="keyword">new</span> ConcreteObserver1();</span></pre></td></tr><tr><td class="code"><pre><span class="line">Observer obs2 = <span class="keyword">new</span> ConcreteObserver2();</span></pre></td></tr><tr><td class="code"><pre><span class="line">subject.add(obs1);</span></pre></td></tr><tr><td class="code"><pre><span class="line">subject.add(obs2);</span></pre></td></tr><tr><td class="code"><pre><span class="line">subject.notifyObserver();</span></pre></td></tr></table></figure>

<p>也就是非常常见的生产-消费模式，适合以下几种情形：</p>
<ol>
<li>对象间存在一对多关系，一个对象的状态发生改变会影响其他对象。</li>
<li>当一个抽象模型有两个方面，其中一个方面依赖于另一方面时，可将这二者封装在独立的对象中以使它们可以各自独立地改变和复用</li>
</ol>
<h3 id="二十、中介者模式"><a href="#二十、中介者模式" class="headerlink" title="二十、中介者模式"></a>二十、中介者模式</h3><p>定义：定义一个中介对象来封装一系列对象之间的交互，使原有对象之间的耦合松散，且可以独立地改变它们之间的交互。中介者模式又叫调停模式，它是迪米特法则的典型应用。</p>
<p>优点：</p>
<ol>
<li>降低了对象之间的耦合性，使得对象易于独立地被复用。</li>
<li>将对象间的一对多关联转变为一对一的关联，提高系统的灵活性，使得系统易于维护和扩展。</li>
</ol>
<p>缺点：当同事类太多时，中介者的职责将很大，它会变得复杂而庞大，以至于系统难以维护。</p>
<p>中介者模式包含以下主要角色。</p>
<ol>
<li>抽象中介者（Mediator）角色：它是中介者的接口，提供了同事对象注册与转发同事对象信息的抽象方法。</li>
<li>具体中介者（ConcreteMediator）角色：实现中介者接口，定义一个 List 来管理同事对象，协调各个同事角色之间的交互关系，因此它依赖于同事角色。</li>
<li>抽象同事类（Colleague）角色：定义同事类的接口，保存中介者对象，提供同事对象交互的抽象方法，实现所有相互影响的同事类的公共功能。</li>
<li>具体同事类（Concrete Colleague）角色：是抽象同事类的实现者，当需要与其他同事对象交互时，由中介者对象负责后续的交互。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Mediator</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(Colleague colleague)</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">relay</span><span class="params">(Colleague cl)</span></span>; <span class="comment">//转发</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//具体中介者</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteMediator</span> <span class="keyword">extends</span> <span class="title">Mediator</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> List&lt;Colleague&gt; colleagues = <span class="keyword">new</span> ArrayList&lt;&gt;();</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(Colleague colleague)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (!colleagues.contains(colleague)) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            colleagues.add(colleague);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            colleague.setMedium(<span class="keyword">this</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">relay</span><span class="params">(Colleague cl)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> (Colleague ob : colleagues) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (!ob.equals(cl)) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                ob.receive();</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//抽象同事类</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Colleague</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">protected</span> Mediator mediator;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMedium</span><span class="params">(Mediator mediator)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">this</span>.mediator = mediator;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">()</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">()</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//具体同事类</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteColleague1</span> <span class="keyword">extends</span> <span class="title">Colleague</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.println(<span class="string">"具体同事类1收到请求。"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.println(<span class="string">"具体同事类1发出请求。"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        mediator.relay(<span class="keyword">this</span>); <span class="comment">//请中介者转发</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//具体同事类</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteColleague2</span> <span class="keyword">extends</span> <span class="title">Colleague</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.println(<span class="string">"具体同事类2收到请求。"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.println(<span class="string">"具体同事类2发出请求。"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        mediator.relay(<span class="keyword">this</span>); <span class="comment">//请中介者转发</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>使用的时候：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Mediator md = <span class="keyword">new</span> ConcreteMediator();</span></pre></td></tr><tr><td class="code"><pre><span class="line">Colleague c1, c2;</span></pre></td></tr><tr><td class="code"><pre><span class="line">c1 = <span class="keyword">new</span> ConcreteColleague1();</span></pre></td></tr><tr><td class="code"><pre><span class="line">c2 = <span class="keyword">new</span> ConcreteColleague2();</span></pre></td></tr><tr><td class="code"><pre><span class="line">md.register(c1);</span></pre></td></tr><tr><td class="code"><pre><span class="line">md.register(c2);</span></pre></td></tr><tr><td class="code"><pre><span class="line">c1.send();</span></pre></td></tr><tr><td class="code"><pre><span class="line">System.out.println(<span class="string">"-------------"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">c2.send();</span></pre></td></tr></table></figure>

<p>应用场景：</p>
<ul>
<li>当对象之间存在复杂的网状结构关系而导致依赖关系混乱且难以复用时。</li>
<li>当想创建一个运行于多个类之间的对象，又不想生成新的子类时。</li>
</ul>
<p>扩展，实际开发中，通常采用以下两种方法来简化中介者模式，使开发变得更简单：</p>
<ol>
<li>不定义中介者接口，把具体中介者对象实现成为单例。</li>
<li>同事对象不持有中介者，而是在需要的时f矣直接获取中介者对象并调用。</li>
</ol>
<h3 id="二十一、备忘录模式"><a href="#二十一、备忘录模式" class="headerlink" title="二十一、备忘录模式"></a>二十一、备忘录模式</h3><p>定义：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，以便以后当需要时能将该对象恢复到原先保存的状态。该模式又叫快照模式。</p>
<p>优点：</p>
<ul>
<li>提供了一种可以恢复状态的机制。当用户需要时能够比较方便地将数据恢复到某个历史的状态。</li>
<li>实现了内部状态的封装。除了创建它的发起人之外，其他对象都不能够访问这些状态信息。</li>
<li>简化了发起人类。发起人不需要管理和保存其内部状态的各个备份，所有状态信息都保存在备忘录中，并由管理者进行管理，这符合单一职责原则。</li>
</ul>
<p>缺点是：资源消耗大。如果要保存的内部状态信息过多或者特别频繁，将会占用比较大的内存资源。</p>
<p>主要角色如下：</p>
<ol>
<li>发起人（Originator）角色：记录当前时刻的内部状态信息，提供创建备忘录和恢复备忘录数据的功能，实现其他业务功能，它可以访问备忘录里的所有信息。</li>
<li>备忘录（Memento）角色：负责存储发起人的内部状态，在需要的时候提供这些内部状态给发起人。</li>
<li>管理者（Caretaker）角色：对备忘录进行管理，提供保存与获取备忘录的功能，但其不能对备忘录的内容进行访问与修改。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Memento</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> String state;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Memento</span><span class="params">(String state)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">this</span>.state = state;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(String state)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">this</span>.state = state;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getState</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> state;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//发起人</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Originator</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> String state;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(String state)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">this</span>.state = state;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getState</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> state;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> Memento <span class="title">createMemento</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Memento(state);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">restoreMemento</span><span class="params">(Memento m)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">this</span>.setState(m.getState());</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//管理者</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Caretaker</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> Memento memento;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMemento</span><span class="params">(Memento m)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        memento = m;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> Memento <span class="title">getMemento</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> memento;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>使用方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Originator or=<span class="keyword">new</span> Originator();</span></pre></td></tr><tr><td class="code"><pre><span class="line">Caretaker cr=<span class="keyword">new</span> Caretaker();</span></pre></td></tr><tr><td class="code"><pre><span class="line">or.setState(<span class="string">"S0"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">System.out.println(<span class="string">"初始状态:"</span>+or.getState());</span></pre></td></tr><tr><td class="code"><pre><span class="line">cr.setMemento(or.createMemento()); <span class="comment">//保存状态      </span></span></pre></td></tr><tr><td class="code"><pre><span class="line">or.setState(<span class="string">"S1"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">System.out.println(<span class="string">"新的状态:"</span>+or.getState());</span></pre></td></tr><tr><td class="code"><pre><span class="line">or.restoreMemento(cr.getMemento()); <span class="comment">//恢复状态</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">System.out.println(<span class="string">"恢复状态:"</span>+or.getState());</span></pre></td></tr></table></figure>

<p>应用场景：</p>
<ol>
<li>需要保存与恢复数据的场景，如玩游戏时的中间结果的存档功能。</li>
<li>需要提供一个可回滚操作的场景，如 Word、记事本、Photoshop，Eclipse 等软件在编辑时按 Ctrl+Z 组合键，还有数据库中事务操作。</li>
</ol>
<h3 id="二十二、解释器模式"><a href="#二十二、解释器模式" class="headerlink" title="二十二、解释器模式"></a>二十二、解释器模式</h3><p>定义：给分析对象定义一个语言，并定义该语言的文法表示，再设计一个解析器来解释语言中的句子。也就是说，用编译语言的方式来分析应用中的实例。这种模式实现了文法表达式处理的接口，该接口解释一个特定的上下文。</p>
<p>优点：</p>
<ol>
<li>扩展性好。由于在解释器模式中使用类来表示语言的文法规则，因此可以通过继承等机制来改变或扩展文法。</li>
<li>容易实现。在语法树中的每个表达式节点类都是相似的，所以实现其文法较为容易。</li>
</ol>
<p>缺点：</p>
<ol>
<li>执行效率较低。解释器模式中通常使用大量的循环和递归调用，当要解释的句子较复杂时，其运行速度很慢，且代码的调试过程也比较麻烦。</li>
<li>会引起类膨胀。解释器模式中的每条规则至少需要定义一个类，当包含的文法规则很多时，类的个数将急剧增加，导致系统难以管理与维护。</li>
<li>可应用的场景比较少。在软件开发中，需要定义语言文法的应用实例非常少，所以这种模式很少被使用到。</li>
</ol>
<p>解释器模式包含以下主要角色。</p>
<ol>
<li>抽象表达式（Abstract Expression）角色：定义解释器的接口，约定解释器的解释操作，主要包含解释方法 interpret()。</li>
<li>终结符表达式（Terminal  Expression）角色：是抽象表达式的子类，用来实现文法中与终结符相关的操作，文法中的每一个终结符都有一个具体终结表达式与之相对应。</li>
<li>非终结符表达式（Nonterminal Expression）角色：也是抽象表达式的子类，用来实现文法中与非终结符相关的操作，文法中的每条规则都对应于一个非终结符表达式。</li>
<li>环境（Context）角色：通常包含各个解释器需要的数据或是公共的功能，一般用来传递被所有解释器共享的数据，后面的解释器可以从这里获取这些值。</li>
<li>客户端（Client）：主要任务是将需要分析的句子或表达式转换成使用解释器对象描述的抽象语法树，然后调用解释器的解释方法，当然也可以通过环境角色间接访问解释器的解释方法。</li>
</ol>
<p>我们以创建一个组合表达式为例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Expression</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">interpret</span><span class="params">(String context)</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TerminalExpression</span> <span class="keyword">implements</span> <span class="title">Expression</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> String data;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TerminalExpression</span><span class="params">(String data)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">this</span>.data = data;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">interpret</span><span class="params">(String context)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (context.contains(data)) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OrExpression</span> <span class="keyword">implements</span> <span class="title">Expression</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> Expression expr1 = <span class="keyword">null</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> Expression expr2 = <span class="keyword">null</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OrExpression</span><span class="params">(Expression expr1, Expression expr2)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">this</span>.expr1 = expr1;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">this</span>.expr2 = expr2;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">interpret</span><span class="params">(String context)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> expr1.interpret(context) || expr2.interpret(context);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AndExpression</span> <span class="keyword">implements</span> <span class="title">Expression</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> Expression expr1 = <span class="keyword">null</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> Expression expr2 = <span class="keyword">null</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AndExpression</span><span class="params">(Expression expr1, Expression expr2)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">this</span>.expr1 = expr1;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">this</span>.expr2 = expr2;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">interpret</span><span class="params">(String context)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> expr1.interpret(context) &amp;&amp; expr2.interpret(context);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>使用方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//规则：Robert 和 John 是男性</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Expression <span class="title">getMaleExpression</span><span class="params">()</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">   Expression robert = <span class="keyword">new</span> TerminalExpression(<span class="string">"Robert"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">   Expression john = <span class="keyword">new</span> TerminalExpression(<span class="string">"John"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> OrExpression(robert, john);    </span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"> </span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//规则：Julie 是一个已婚的女性</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Expression <span class="title">getMarriedWomanExpression</span><span class="params">()</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">   Expression julie = <span class="keyword">new</span> TerminalExpression(<span class="string">"Julie"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">   Expression married = <span class="keyword">new</span> TerminalExpression(<span class="string">"Married"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> AndExpression(julie, married);    </span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"> </span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">   Expression isMale = getMaleExpression();</span></pre></td></tr><tr><td class="code"><pre><span class="line">   Expression isMarriedWoman = getMarriedWomanExpression();</span></pre></td></tr><tr><td class="code"><pre><span class="line"> </span></pre></td></tr><tr><td class="code"><pre><span class="line">   System.out.println(<span class="string">"John is male? "</span> + isMale.interpret(<span class="string">"John"</span>));</span></pre></td></tr><tr><td class="code"><pre><span class="line">   System.out.println(<span class="string">"Julie is a married women? "</span> </span></pre></td></tr><tr><td class="code"><pre><span class="line">   + isMarriedWoman.interpret(<span class="string">"Married Julie"</span>));</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>应用场景：</p>
<ol>
<li>当语言的文法较为简单，且执行效率不是关键问题时。</li>
<li>当问题重复出现，且可以用一种简单的语言来进行表达时。</li>
<li>当一个语言需要解释执行，并且语言中的句子可以表示为一个抽象语法树的时候，如 XML 文档解释。</li>
</ol>
<p>注意：解释器模式在实际的软件开发中使用比较少，因为它会引起效率、性能以及维护等问题。如果碰到对表达式的解释，在 Java 中可以用 Expression4J 或 Jep 等来设计。</p>
<h3 id="二十三、状态模式"><a href="#二十三、状态模式" class="headerlink" title="二十三、状态模式"></a>二十三、状态模式</h3><p>定义：对有状态的对象，把复杂的“判断逻辑”提取到不同的状态对象中，允许状态对象在其内部状态发生改变时改变其行为。</p>
<p>优点：</p>
<ol>
<li>状态模式将与特定状态相关的行为局部化到一个状态中，并且将不同状态的行为分割开来，满足“单一职责原则”。</li>
<li>减少对象间的相互依赖。将不同的状态引入独立的对象中会使得状态转换变得更加明确，且减少对象间的相互依赖。</li>
<li>有利于程序的扩展。通过定义新的子类很容易地增加新的状态和转换。</li>
</ol>
<p>缺点：</p>
<ol>
<li>状态模式的使用必然会增加系统的类与对象的个数。</li>
<li>状态模式的结构与实现都较为复杂，如果使用不当会导致程序结构和代码的混乱。</li>
</ol>
<p>状态模式包含以下主要角色：</p>
<ol>
<li>环境（Context）角色：也称为上下文，它定义了客户感兴趣的接口，维护一个当前状态，并将与状态相关的操作委托给当前状态对象来处理。</li>
<li>抽象状态（State）角色：定义一个接口，用以封装环境对象中的特定状态所对应的行为。</li>
<li>具体状态（Concrete  State）角色：实现抽象状态所对应的行为。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//抽象状态类</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">State</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">Handle</span><span class="params">(Context context)</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Context</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> State state;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//定义环境类的初始状态</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Context</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">this</span>.state = <span class="keyword">new</span> ConcreteStateA();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//设置新状态</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(State state)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">this</span>.state = state;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//读取状态</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> State <span class="title">getState</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> (state);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//对请求做处理</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Handle</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        state.Handle(<span class="keyword">this</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//具体状态A类</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteStateA</span> <span class="keyword">extends</span> <span class="title">State</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Handle</span><span class="params">(Context context)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.println(<span class="string">"当前状态是 A."</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        context.setState(<span class="keyword">new</span> ConcreteStateB());</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//具体状态B类</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteStateB</span> <span class="keyword">extends</span> <span class="title">State</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Handle</span><span class="params">(Context context)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.println(<span class="string">"当前状态是 B."</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        context.setState(<span class="keyword">new</span> ConcreteStateA());</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>使用方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ShareContext context=<span class="keyword">new</span> ShareContext(); <span class="comment">//创建环境       </span></span></pre></td></tr><tr><td class="code"><pre><span class="line">context.Handle(); <span class="comment">//处理请求</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">context.Handle();</span></pre></td></tr><tr><td class="code"><pre><span class="line">context.Handle();</span></pre></td></tr><tr><td class="code"><pre><span class="line">context.Handle();</span></pre></td></tr></table></figure>

<p>使用场景：</p>
<ul>
<li>当一个对象的行为取决于它的状态，并且它必须在运行时根据状态改变它的行为时，就可以考虑使用状态模式。</li>
<li>一个操作中含有庞大的分支结构，并且这些分支决定于对象的状态时。</li>
</ul>
<p>扩展：在有些情况下，可能有多个环境对象需要共享一组状态，这时需要引入享元模式，将这些具体状态对象放在集合中供程序共享</p>
<h2 id="JDK-出现了哪些设计模式"><a href="#JDK-出现了哪些设计模式" class="headerlink" title="JDK 出现了哪些设计模式"></a>JDK 出现了哪些设计模式</h2><p>这部分有些乱，没有顺序，基本是从网上找的或者自己想到的，想到哪写到哪里。</p>
<ol>
<li>Runtime 用到了单例模式。</li>
<li>用到了工厂模式的：<code>Integer.valueOf()</code>、<code>Class.forName()</code>、反射包里的<code>Array.newInstance()</code>等等。</li>
<li>虚拟工厂：<code>java.sql.DriverManager#getConnection()</code>、<code>java.sql.Statement#executeQuery()</code></li>
<li>建造者模式：<code>StringBuilder#append()</code>、<code>System.arraycopy</code></li>
<li>原型模式：<code>java.lang.Object</code>中返回一个浅拷贝对象，<code>java.lang.Cloneable</code></li>
<li>桥接模式：<code>AWT</code>、<code>JDBC</code></li>
<li>组合模式：各种容器类：<code>List</code>、<code>Map</code>、<code>Set</code></li>
<li>装饰器模式：<code>BufferedInputStream</code>、<code>java.util.Collections#checked[List|Map|Set|SortedSet|SortedMap]()</code></li>
<li>适配器模式：<code>Arrays.asList()</code>、<code>InputStreamReader</code></li>
<li>享元模式：<code>Integer.valueOf()</code></li>
<li>外观模式：<code>java.lang.Class</code>、<code>javax.faces.webapp.FacesServlet</code></li>
<li>代理模式：<code>java.lang.reflect.Proxy</code>、<code>RMI</code></li>
<li>责任链模式：<code>java.util.logging.Logger#log()</code>、<code>javax.servlet.Filter#doFilter()</code></li>
<li>命令模式：<code>Runnable</code></li>
<li>解释器模式：<code>java.util.Pattern</code>、<code>java.text.Format</code></li>
<li>迭代器器模式：<code>java.util.Iterator</code></li>
<li>中介者模式：<code>Timer</code>、<code>java.util.concurrent.Executor#execute()</code></li>
<li>备忘录模式：<code>java.util.Date</code>、<code>java.io.Serializable</code></li>
<li>访问者：<code>javax.lang.model.element.Element</code>和<code>javax.lang.model.element.ElementVisitor</code></li>
<li>模板模式：<code>java.util.Collections#sort()</code>、<code>java.util.AbstractList#indexOf()</code></li>
<li>策略模式：<code>java.util.Comparator#compare()</code>、<code>HttpServlet</code></li>
<li>状态模式：<code>javax.faces.lifecycle.LifeCycle#execute()</code>、<code>java.util.Iterator</code></li>
<li>观察者模式：<code>java.util.EventListener</code>、<code>javax.servlet.http.HttpSessionAttributeListener</code></li>
</ol>
<h2 id="常见框架和类库中怎么用的"><a href="#常见框架和类库中怎么用的" class="headerlink" title="常见框架和类库中怎么用的"></a>常见框架和类库中怎么用的</h2><p>先以 Spring 为例，后续慢慢补充，这里仅作为一个索引，具体详细怎么用的后续再开文章补充吧。</p>
<ol>
<li>工厂方法：<code>BeanFactory</code>、<code>ApplicationContext</code></li>
<li>单例模式：<code>singleton</code>作用域的 bean</li>
<li>代理模式：Spring AOP 就是基于动态代理的。如果要代理的对象，实现了某个接口，那么Spring AOP会使用<strong>JDK Proxy</strong>，去创建代理对象，而对于没有实现接口的对象，就无法使用 JDK Proxy 去进行代理了，这时候Spring AOP会使用<strong>Cglib</strong> 。</li>
<li>模板方法：<code>jdbcTemplate</code>、<code>hibernateTemplate</code>等等</li>
<li>观察者模式：<code>ApplicationEventPublisher</code>和<code>ApplicationListener</code></li>
<li>适配器模式：<code>AdvisorAdapter</code>、<code>HandlerAdapter</code></li>
<li>策略模式：<code>SimpleInstantiationStrategy</code></li>
</ol>
<p>参考文章：</p>
<p><a href="https://www.jianshu.com/p/7deb64f902db" target="_blank" rel="noopener">抽象工厂模式（Abstract Factory）- 最易懂的设计模式解析</a></p>
<p><a href="https://blog.csdn.net/jason0539/article/details/44992733" target="_blank" rel="noopener">java设计模式之建造者模式</a></p>
<p><a href="http://c.biancheng.net/view/1317.html" target="_blank" rel="noopener">设计模式概述</a></p>
<p><a href="https://www.runoob.com/design-pattern/design-pattern-tutorial.html" target="_blank" rel="noopener">设计模式</a></p>
<p><a href="https://coolshell.cn/articles/3320.html" target="_blank" rel="noopener">JDK里的设计模式</a></p>
<p><a href="https://juejin.im/post/5ce69379e51d455d877e0ca0" target="_blank" rel="noopener">面试官:“谈谈Spring中都用到了那些设计模式?”</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTPS为什么安全？</title>
    <url>/2020/03/01/HTTPS%E4%B8%BA%E4%BB%80%E4%B9%88%E5%AE%89%E5%85%A8%EF%BC%9F/</url>
    <content><![CDATA[<p>知道HTTPS，也用过HTTPS，但是一直不知道原理，这次探究一下。</p>
<a id="more"></a>

<p>惯例，上 Wiki，什么是 HTTPS?</p>
<blockquote>
<p><strong>超文本传输安全协议</strong>（英语：<strong>H</strong>yper<strong>T</strong>ext <strong>T</strong>ransfer <strong>P</strong>rotocol <strong>S</strong>ecure，缩写：<strong>HTTPS</strong>；常称为HTTP over TLS、HTTP over SSL或HTTP Secure）是一种通过<a href="https://zh.wikipedia.org/wiki/計算機網絡" target="_blank" rel="noopener">计算机网络</a>进行安全通信的<a href="https://zh.wikipedia.org/wiki/網路傳輸協定" target="_blank" rel="noopener">传输协议</a>。HTTPS经由<a href="https://zh.wikipedia.org/wiki/HTTP" target="_blank" rel="noopener">HTTP</a>进行通信，但利用<a href="https://zh.wikipedia.org/wiki/传输层安全" target="_blank" rel="noopener">SSL/TLS</a>来<a href="https://zh.wikipedia.org/wiki/加密" target="_blank" rel="noopener">加密</a>数据包。HTTPS开发的主要目的，是提供对<a href="https://zh.wikipedia.org/wiki/網站" target="_blank" rel="noopener">网站</a>服务器的<a href="https://zh.wikipedia.org/wiki/身份验证" target="_blank" rel="noopener">身份认证</a>，保护交换数据的隐私与<a href="https://zh.wikipedia.org/wiki/完整性" target="_blank" rel="noopener">完整性</a>。这个协议由<a href="https://zh.wikipedia.org/wiki/網景" target="_blank" rel="noopener">网景</a>公司（Netscape）在1994年首次提出，随后扩展到<a href="https://zh.wikipedia.org/wiki/網際網路" target="_blank" rel="noopener">互联网</a>上。</p>
</blockquote>
<p>可以看出，Https 之所以安全，是经过了加密，那么新的问题又来了，SSL 和 TLS 分别是什么？是怎么加密的？</p>
<h2 id="SSL-和-TLS"><a href="#SSL-和-TLS" class="headerlink" title="SSL 和 TLS"></a>SSL 和 TLS</h2><p>SSL：（Secure Socket Layer，安全套接字层），位于可靠的面向连接的<strong>网络层协议</strong>和<strong>应用层协议</strong>之间的一种协议层。SSL通过互相认证、使用数字签名确保完整性、使用加密确保私密性，以实现客户端和服务器之间的安全通讯。该协议由两层组成：SSL记录协议和SSL握手协议。</p>
<p>TLS：(Transport Layer Security，传输层安全协议)，用于两个应用程序之间提供保密性和数据完整性。该协议由两层组成：TLS 记录协议和 TLS 握手协议。</p>
<p>SSL 和 TLS 是一种能够在服务器，machines 和通过网络运行的应用程序（列如，客户端连接到 web 服务器）之间提供身份认证和数据加密的加密协议。SSL是TLS的前世。多年来，新版本的发布用来解决漏洞，提供更强大支持，更安全的密码套件和算法。</p>
<p>SSL最初是由 Netscape 开发的，早在1995年以SSL 2.0的方式发布（1.0从未对公众发布）。在一些漏洞被发现之后，版本2.0在1996年很快被3.0所取代。注意：版本2.0和3.0有时会写成 SSLv2 和 SSLv3。</p>
<p><a href="https://tools.ietf.org/html/rfc2246" target="_blank" rel="noopener">TLS</a>以SSL 3.0为基础于1999年作为SSL的新版本推出。</p>
<h3 id="应该选-SSL-还是-TLS？"><a href="#应该选-SSL-还是-TLS？" class="headerlink" title="应该选 SSL 还是 TLS？"></a>应该选 SSL 还是 TLS？</h3><p>SSL2.0和SSL3.0已经被IEFT组织废弃（分别在2011年，2015年）多年来，在被废弃的SSL协议中一直存在漏洞并被发现 (e.g. <a href="https://www.globalsign.com/en/blog/poodle-vulnerability-in-ssl-30/" target="_blank" rel="noopener">POODLE</a>, <a href="https://www.globalsign.com/en/blog/drown-attack-sslv2/" target="_blank" rel="noopener">DROWN</a>)。大多数现代浏览器遇到使用废弃协议的 web 服务时，会降低用户体验（红线穿过挂锁标志或者https表示警告）来表现。因为这些原因，你应该在服务端禁止使用 SSL 协议，仅仅保留 TLS 协议开启。</p>
<h2 id="为什么要用-TLS-SSL？"><a href="#为什么要用-TLS-SSL？" class="headerlink" title="为什么要用 TLS/SSL？"></a>为什么要用 TLS/SSL？</h2><p>要想规避风险，要先知道风险点在哪。我们要知道 HTTPS 想要解决哪些问题，具体通过什么手段解决的。 </p>
<p>常规的 HTTP 通信，有以下的问题。</p>
<ol>
<li><p><strong>窃听风险</strong>（eavesdropping）：第三方可以获知通信内容。</p>
</li>
<li><p><strong>篡改风险</strong>（tampering）：第三方可以修改通信内容。</p>
</li>
<li><p><strong>冒充风险</strong>（pretending）：第三方可以冒充他人身份参与通信。</p>
</li>
</ol>
<p>因此，SSL/TLS 协议就是为了解决这三大风险而设计的，希望达到：</p>
<ol>
<li>所有信息都是<strong>加密传播</strong>，第三方无法窃听。</li>
<li>具有<strong>校验机制</strong>，一旦被篡改，通信双方会立刻发现。</li>
<li>配备<strong>身份证书</strong>，防止身份被冒充。</li>
</ol>
<h2 id="运行过程"><a href="#运行过程" class="headerlink" title="运行过程"></a>运行过程</h2><p>SSL/TLS 协议的基本思路是采用<a href="http://en.wikipedia.org/wiki/Public-key_cryptography" target="_blank" rel="noopener">公钥加密法</a>，也就是说，客户端先向服务器端索要公钥，然后用公钥加密信息，服务器收到密文后，用自己的私钥解密。</p>
<blockquote>
<p><strong>公开密钥密码学</strong>（英语：<strong>Public-key cryptography</strong>）也称<strong>非对称式密码学</strong>（英语：<strong>Asymmetric cryptography</strong>）是<a href="https://zh.wikipedia.org/wiki/密碼學" target="_blank" rel="noopener">密码学</a>的一种<a href="https://zh.wikipedia.org/wiki/演算法" target="_blank" rel="noopener">算法</a>，它需要两个<a href="https://zh.wikipedia.org/wiki/密钥" target="_blank" rel="noopener">密钥</a>，一个是公开密钥，另一个是私有密钥；公钥用作加密，私钥则用作解密。使用其中一个密钥把<a href="https://zh.wikipedia.org/wiki/明文" target="_blank" rel="noopener">明文</a>加密后所得的<a href="https://zh.wikipedia.org/wiki/密文" target="_blank" rel="noopener">密文</a>，只能用相对应的另一个密钥才能解密得到原本的明文；连最初用来加密的密钥也不能用作解密。由于加密和解密需要两个不同的密钥，故被称为非对称加密；不同于加密和解密都使用同一个密钥的<a href="https://zh.wikipedia.org/wiki/对称加密" target="_blank" rel="noopener">对称加密</a>。其中一个密钥可以公开，称为公钥，可任意向外发布；不公开的密钥为私钥，必须由用户自行严格秘密保管，绝不透过任何途径向任何人提供，也不会透露给被信任的要通信的另一方。</p>
</blockquote>
<p>简单来说，非对称加密就是两个密码，公钥交给对方，私钥自己藏好，把想要传输的信息用私钥加密，然后交给对方，对方用公钥解密。这里仍然有两个问题：</p>
<h4 id="如何保证公钥不被篡改？"><a href="#如何保证公钥不被篡改？" class="headerlink" title="如何保证公钥不被篡改？"></a>如何保证公钥不被篡改？</h4><p>解决方法：将公钥放在<a href="http://en.wikipedia.org/wiki/Digital_certificate" target="_blank" rel="noopener">数字证书</a>中。只要证书是可信的，公钥就是可信的。</p>
<p>那么怎么验证数字证书可不可信呐？答案是 CA 来给你鉴定。</p>
<p>CA（Certificate Authority）是证书颁发机构，即颁发数字证书的机构，是负责发放和管理数字证书的权威机构。业界比较大的 CA 机构会被客户端软件广泛承认。比如一个浏览器承认某个 CA 的信用，就把这家机构的根证书（root certificate）内置在客户端当中，作为信任链的源头，后续的其他数字证书只要通过根证书的认证，就会认定为是可信的。根证书如何来判断是否信任某个数字证书？就得从数字证书的结构说起。</p>
<h4 id="数字证书的认证"><a href="#数字证书的认证" class="headerlink" title="数字证书的认证"></a>数字证书的认证</h4><p>有过部署 HTTPS 服务经历的同学都知道，将自己的网站改为 HTTPS 需要做的第一步就是申请一个数字证书放在 web 服务器下面。数字证书主要包括以下内容：</p>
<ul>
<li>证书颁发机构的名称</li>
<li>证书持有者公钥</li>
<li>证书签名用到的Hash算法</li>
<li>有效期等等其他信息</li>
</ul>
<p>这些内容都是明文，然后将明文通过摘要算法获取 hash，通过<strong>证书颁发机构</strong>的私钥进行非对称加密，得到签名信息，这个步骤叫做数字签名。明文+hash+数字签名共同组成了这个数字证书。</p>
<p>现在客户端拿到了这个数字证书，使用证书里说明的 hash 算法对明文进行摘要运算，得到的 hash 值应该和证书里是一样的。然后客户端会查询这个证书的颁发机构名称，从自己内置的信任列表里找该机构的证书，这里有两种情况：</p>
<ol>
<li>找到了，说明是自己信任的 CA 颁发的，从该机构的数字证书中可以找到证书的公钥，用这个公钥解密之前拿到的数字证书，如果能成功解密，证明证书可信。会添加到信任列表。</li>
<li>没找到，也不一定说明证书是假的，因为数字证书是一条信任链，A 信任 B，B 信任 C，就算内置了 A ，也不能直接用 A 验证 C。所幸 C 的证书内容里会包含 B 的名称和地址，浏览器会自动去找 B 的证书，然后再看看 B 是否可信，直到达到了根节点。或者到了根节点仍然不可信，整个信任链就没有建立，所有证书被浏览器判断为不可信。</li>
</ol>
<p>如此以来，数字证书的认证就完成了，有两个结果，浏览器信任证书和不信任证书。前者一般会有标示，比如 Chrome 浏览器会在地址栏有个小锁。后者就会提示连接有风险。</p>
<p><img src="http://nas.beritra.com:18081/uploads/big/2b9b90ea9f8dfdff2274335d198f04e5.png" alt="test"></p>
<p><img src="http://nas.beritra.com:18081/uploads/big/47374473deecb326870d3b993bc37707.png" alt=""></p>
<p>这一步完成之后，客户端只是拿到了一个准确、可信的服务端的公钥。而实际上的数据传输还没开始。</p>
<p>客户端拿到公钥之后（或之前，我也不确定），也会把自己的公钥发送过去，双方会运行 Diffie Hellman 算法，简称 DH 算法。DH 算法的作用是这样：通过二者的公钥推导出一个个一样的密码出来。通俗地说：双方会协商一个master-key，这个master-key 不会在网络上传输、交换，它们独立计算出来的，其值是相同的，只有它们自己双方知道。</p>
<p>然后以master-key 推导出 session-key，用于双方 SSL 数据流的加密/解密，采用对称加密，保证数据不被偷窥，加密算法一般用 AES。</p>
<p>同时以 master-key 推导出 hash-key，用于数据完整性检查（Integrity Check Verification）的加密密钥，HASH 算法一般有：MD5、SHA。</p>
<p>为什么要搞这么麻烦呐？因为非对称加密算法很消耗资源，所以只有前置的互相认证的步骤用非对称加密，后续的步骤都用更省资源的对称加密。</p>
<p>到这里，HTTPS 的大致流程就完成了，当然实际上的步骤会更加复杂，客户端和服务端的连接还会有随机数，为了减少资源消耗还会有一些缓存机制。</p>
<p>再回顾一下整个简化的流程：</p>
<ol>
<li>客户端请求服务端的数字证书。</li>
<li>客户端根据内置的根证书校验服务端发来的证书。</li>
<li>如果证书可信，客户端把自己的公钥发给服务端，然后用双方的公钥推导出一个会话密钥。</li>
<li>后续的请求内容都用会话密钥进行加密和解密。</li>
</ol>
<h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>截了个知乎的证书，可以看到是三级的信任链，知乎的证书签发机构是<code>GeoTrust RSA CA 2018</code>，而 GeoTrust 的签发机构是<code>DigiCert Global Root CA</code>，就到根证书了。</p>
<p><img src="http://nas.beritra.com:18081/uploads/medium/843931a17deddf3b0e03f276578dab56.png" alt=""></p>
<p><img src="http://nas.beritra.com:18081/uploads/medium/af5bb15f4644cff034f6c4627b0542b3.png" alt=""></p>
<p>另外注意风险：</p>
<ol>
<li>把公钥交给对方的时候要注意安全，公钥有可能被劫持。</li>
<li>数字证书的认证步骤也不是绝对安全，有“中间人攻击”。当然这个也需要一定条件，就不细说了。</li>
</ol>
<p>参考文章：</p>
<p><a href="https://juejin.im/post/5b213a0ae51d4506d47dff0d" target="_blank" rel="noopener">TLS与SSL之间关系</a></p>
<p><a href="https://www.ruanyifeng.com/blog/2014/02/ssl_tls.html" target="_blank" rel="noopener">SSL/TLS协议运行机制的概述</a></p>
<p><a href="[http://www.wxtlife.com/2016/03/27/%E8%AF%A6%E8%A7%A3https%E6%98%AF%E5%A6%82%E4%BD%95%E7%A1%AE%E4%BF%9D%E5%AE%89%E5%85%A8%E7%9A%84%EF%BC%9F/](http://www.wxtlife.com/2016/03/27/详解https是如何确保安全的？/)">详解https是如何确保安全的？</a></p>
<p><a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1304227905273889" target="_blank" rel="noopener">密钥交换算法</a></p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>https</tag>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>关于Redis应该知道的</title>
    <url>/2020/02/26/%E5%85%B3%E4%BA%8ERedis%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84/</url>
    <content><![CDATA[<p>NoSQL 几乎是必备的知识，其中 Redis 大概是适用范围最广的非关系型数据库，应该也是我个人接触比较早，了解比较多的，因此整理下 Redis 的相关知识点。先从比较基础的内容整理开始，后续更多复杂和深入的内容考虑慢慢补充或者再开专门的文章来整理。</p>
<a id="more"></a>

<h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p>直接抄来的一些关于Redisd的简介：</p>
<p>Redis 是一个高性能的key-value数据库。 </p>
<p>Redis 有以下优势：</p>
<ul>
<li>性能极高 – Redis能读的速度是110000次/s,写的速度是81000次/s 。</li>
<li>丰富的数据类型 – Redis支持二进制案例的 Strings, Lists, Hashes, Sets 及 Ordered Sets 数据类型操作。</li>
<li>原子 – Redis的所有操作都是原子性的，意思就是要么成功执行要么失败完全不执行。单个操作是原子性的。多个操作也支持事务，即原子性，通过MULTI和EXEC指令包起来。</li>
<li>丰富的特性 – Redis还支持 publish/subscribe, 通知, key 过期等等特性。</li>
</ul>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>Redis 能用来做什么？互联网公司一般怎么使用它？</p>
<p>除了常见的缓存（cache），Redis 能做的还有很多，比如：</p>
<ul>
<li>分布式锁:<a href="https://segmentfault.com/a/1190000012919740" target="_blank" rel="noopener">基于 Redis 的分布式锁实现</a></li>
<li>排序:<a href="http://doc.redisfans.com/key/sort.html" target="_blank" rel="noopener">sort 命令</a></li>
<li>去重:小数据量可以直接用 Redis 的 Set 来去重，数据量非常大而且不要是百分百的精准可以考虑用布隆过滤器。 </li>
<li>计数器:简单方式用<code>incr()</code> </li>
</ul>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>Redis 有 5 种常用的基础数据结构，分别为:string (字符串)、list (列表)、set (集合)、hash (哈 希) 和 zset (有序集合)。熟练掌握这 5 种基本数据结构的使用是 Redis 知识最基础也最重要的部分，它也是在 Redis 面试题中问到最多的内容。除此之外，Redis 官网上还提到了三种数据类型：Bit arrays 、HyperLogLogs和Streams。</p>
<h3 id="key"><a href="#key" class="headerlink" title="key"></a>key</h3><p>官网上这么介绍 Redis 的 key：</p>
<p>Redis密钥是二进制安全的，这意味着您可以使用任何二进制序列作为密钥，从“ foo”之类的字符串到JPEG文件的内容。空字符串也是有效的键。有关密钥的其他一些规则：</p>
<ul>
<li>太长的密钥不是一个好主意。例如，一个1024字节的密钥是一个坏主意，不仅是内存方面的问题，而且因为在数据集中查找密钥可能需要进行一些代价高昂的密钥比较。即使当手头的任务是匹配一个大值的存在时，对它进行散列（例如使用SHA1）也是一个更好的主意，尤其是从内存和带宽的角度来看。</li>
<li>非常短的键通常不是一个好主意。如果您可以改写“ user:1000:followers”，那么将“ u1000flw”作为密钥写的毫无意义。与键对象本身和值对象使用的空间相比，后者更具可读性，并且添加的空间较小。虽然短键显然会消耗更少的内存，但您的工作是找到合适的平衡。</li>
<li>尝试坚持使用架构。例如，“ object-type:id”是一个好主意，例如“ user:1000”。点或破折号通常用于多字字段，例如“ comment:123:reply.to”或“ comment:123:reply-to”中。</li>
<li>允许的最大密钥大小为512 MB。</li>
</ul>
<p>key 是所有数据类型通用的键，关于 key 的操作有如下几个：</p>
<ul>
<li>DEL key 删除给定的一个或多个 <code>key</code> 。不存在的 <code>key</code> 会被忽略。</li>
<li>DUMP key 序列化给定 <code>key</code> ，并返回被序列化的值，使用 <a href="http://doc.redisfans.com/key/restore.html" target="_blank" rel="noopener"><em>RESTORE</em></a> 命令可以将这个值反序列化为 Redis 键。</li>
<li>EXISTS key 检查键是否存在。若 key 存在，返回1，否则返回0。</li>
<li>EXPIRE key seconds 为给定 <code>key</code> 设置生存时间，当 <code>key</code> 过期时(生存时间为 <code>0</code> )，它会被自动删除。注意：<ul>
<li>可以对一个已经带有生存时间的 <code>key</code> 执行 <a href="http://doc.redisfans.com/key/expire.html#expire" target="_blank" rel="noopener"><em>EXPIRE</em></a> 命令，新指定的生存时间会取代旧的生存时间。</li>
<li>使用 <a href="http://doc.redisfans.com/key/persist.html" target="_blank" rel="noopener"><em>PERSIST</em></a> 命令可以在不删除 <code>key</code> 的情况下，移除 <code>key</code> 的生存时间，让 <code>key</code> 重新成为一个『持久的』(persistent) <code>key</code> 。</li>
<li>其他的操作不会影响<code>key</code>的生存时间。</li>
<li>在 Redis 2.4 版本中，过期时间的延迟在 1 秒钟之内 —— 也即是，就算 <code>key</code> 已经过期，但它还是可能在过期之后一秒钟之内被访问到，而在新的 Redis 2.6 版本中，延迟被降低到 1 毫秒之内。</li>
</ul>
</li>
<li>EXPIREAT key timestamp <a href="http://doc.redisfans.com/key/expireat.html#expireat" target="_blank" rel="noopener">EXPIREAT</a> 的作用和 <a href="http://doc.redisfans.com/key/expire.html" target="_blank" rel="noopener"><em>EXPIRE</em></a> 类似，都用于为 <code>key</code> 设置生存时间。不同在于 <a href="http://doc.redisfans.com/key/expireat.html#expireat" target="_blank" rel="noopener">EXPIREAT</a> 命令接受的时间参数是 UNIX 时间戳(unix timestamp)。</li>
<li>PEXPIRE key milliseconds 这个命令和 <a href="http://doc.redisfans.com/key/expire.html" target="_blank" rel="noopener"><em>EXPIRE</em></a> 命令的作用类似，但是它以毫秒为单位设置 <code>key</code> 的生存时间，而不像 <a href="http://doc.redisfans.com/key/expire.html" target="_blank" rel="noopener"><em>EXPIRE</em></a> 命令那样，以秒为单位。</li>
<li>PEXPIREAT key milliseconds-timestamp 这个命令和 <a href="http://doc.redisfans.com/key/expireat.html" target="_blank" rel="noopener"><em>EXPIREAT</em></a> 命令类似，但它以毫秒为单位设置 <code>key</code> 的过期 unix 时间戳，而不是像 <a href="http://doc.redisfans.com/key/expireat.html" target="_blank" rel="noopener"><em>EXPIREAT</em></a> 那样，以秒为单位。</li>
<li>TTL key 以秒为单位，返回给定 <code>key</code> 的剩余生存时间(TTL, time to live)。</li>
<li>PTTL key 这个命令类似于 <a href="http://doc.redisfans.com/key/ttl.html#ttl" target="_blank" rel="noopener"><em>TTL</em></a> 命令，但它以毫秒为单位返回 <code>key</code> 的剩余生存时间，而不是像 <a href="http://doc.redisfans.com/key/ttl.html#ttl" target="_blank" rel="noopener"><em>TTL</em></a> 命令那样，以秒为单位。</li>
<li>KEYS pattern 查找所有符合给定模式 <code>pattern</code> 的 <code>key</code> 。</li>
<li>MIGRATE host port key destination-db timeout [COPY] [REPLACE] 将 <code>key</code> 原子性地从当前实例传送到目标实例的指定数据库上，一旦传送成功， <code>key</code> 保证会出现在目标实例上，而当前实例上的 <code>key</code> 会被删除。这个命令是一个原子操作，它在执行的时候会阻塞进行迁移的两个实例，直到以下任意结果发生：迁移成功，迁移失败，等到超时。</li>
<li>MOVE key db 将当前数据库的 <code>key</code> 移动到给定的数据库 <code>db</code> 当中。如果当前数据库(源数据库)和给定数据库(目标数据库)有相同名字的给定 <code>key</code> ，或者 <code>key</code> 不存在于当前数据库，那么 <code>MOVE</code> 没有任何效果。</li>
<li>OBJECT subcommand [arguments [arguments] <a href="http://doc.redisfans.com/key/object.html#object" target="_blank" rel="noopener">OBJECT</a> 命令允许从内部察看给定 <code>key</code> 的 Redis 对象。</li>
<li>PERSIST key 移除给定 <code>key</code> 的生存时间，将这个 <code>key</code> 从『易失的』(带生存时间 <code>key</code> )转换成『持久的』(一个不带生存时间、永不过期的 <code>key</code> )。</li>
<li>RANDOMKEY 从当前数据库中随机返回(不删除)一个 <code>key</code> 。</li>
<li>RENAME key newkey 将 <code>key</code> 改名为 <code>newkey</code> 。当 <code>key</code> 和 <code>newkey</code> 相同，或者 <code>key</code> 不存在时，返回一个错误。当 <code>newkey</code> 已经存在时， <a href="http://doc.redisfans.com/key/rename.html#rename" target="_blank" rel="noopener">RENAME</a> 命令将覆盖旧值。</li>
<li>RENAMENX key newkey 当且仅当 <code>newkey</code> 不存在时，将 <code>key</code> 改名为 <code>newkey</code> 。当 <code>key</code> 不存在时，返回一个错误。</li>
<li>RESTORE key ttl serialized-value 反序列化给定的序列化值，并将它和给定的 <code>key</code> 关联。参数 <code>ttl</code> 以毫秒为单位为 <code>key</code> 设置生存时间；如果 <code>ttl</code> 为 <code>0</code> ，那么不设置生存时间。</li>
<li>SORT key [BY pattern] [LIMIT offset count] [GET pattern [GET pattern …]] [ASC | DESC] [ALPHA] [STORE destination] 返回或保存给定列表、集合、有序集合 <code>key</code> 中经过排序的元素。排序默认以数字作为对象，值被解释为双精度浮点数，然后进行比较。因为 <a href="http://doc.redisfans.com/key/sort.html#sort" target="_blank" rel="noopener">SORT</a> 命令默认排序对象为数字， 当需要对字符串进行排序时， 需要显式地在 <a href="http://doc.redisfans.com/key/sort.html#sort" target="_blank" rel="noopener">SORT</a> 命令之后添加 <code>ALPHA</code> 修饰符。</li>
<li>TYPE key 返回 <code>key</code> 所储存的值的类型。</li>
</ul>
<h3 id="string-字符串"><a href="#string-字符串" class="headerlink" title="string (字符串)"></a>string (字符串)</h3><p>字符串 string 是 Redis 最简单的数据结构。Redis 所有的数据结构都是以唯一的 key 字符串作为名称，然后通过这个唯一 key 值来获取相应的 value 数据。</p>
<p>字符串结构使用非常广泛，一个常见的用途就是缓存用户信息。我们将用户信息结构体 使用 JSON 序列化成字符串，然后将序列化后的字符串塞进 Redis 来缓存。</p>
<p>Redis 的字符串是动态字符串，是可以修改的字符串，内部结构实现上类似于 Java 的 ArrayList，采用预分配冗余空间的方式来减少内存的频繁分配，内部为当前字符串实际分配的空间 capacity 一般要高于实际字符串长度 len。当字符串长度小于 1M 时， 扩容都是加倍现有的空间，如果超过 1M，扩容时一次只会多扩 1M 的空间。需要注意的是，字符串最大长度为 512M。</p>
<p>Redis 中字符串对象的编码可以是 <code>int</code>，<code>raw</code> 或者 <code>embstr</code> 中的某一种，分别如下：</p>
<ul>
<li><strong>int 编码</strong>：保存long 型的64位有符号整数，系统会缓存包含了 1~1000 数字的对象，相同对象会指向同一个地址。</li>
<li><strong>embstr 编码</strong>：保存长度小于44字节的字符串，和字符串对象的其他元信息保存在一段连续的内存地址中。</li>
<li><strong>raw 编码</strong>：保存长度大于44字节的字符串，和字符串对象的其他元信息分开保存。</li>
</ul>
<h3 id="Hash（哈希）"><a href="#Hash（哈希）" class="headerlink" title="Hash（哈希）"></a>Hash（哈希）</h3><p><strong>Hash</strong> 是一个键值(key =&gt; value)对集合。Redis hash 是一个 string 类型的 field 和 value 的映射表，hash 特别适合用于存储对象。 常用命令：hget,hset,hgetall 等。</p>
<p>Hash 的底层数据结构有两种表示：ziplist 和 hashtable。当哈希对象可以同时满足以下两个条件时， 哈希对象使用 ziplist 编码：</p>
<ol>
<li>哈希对象保存的所有键值对的键和值的字符串长度都小于 64 字节；</li>
<li>哈希对象保存的键值对数量小于 512 个；</li>
</ol>
<p>hash 对象使用ziplist 保存时，程序会将保存了键的ziplist节点推入到列表的表尾，然后再将保存了值的ziplist节点推入列表的表尾。使用这种方式保存时，并不需要申请多余的内存空间，而且每个Key都要存储一些关联的系统信息（如过期时间、LRU等），因此和String类型的Key/Value相比，Hash类型极大的减少了Key的数量(大部分的Key都以Hash字段的形式表示并存储了)，从而进一步优化了存储空间的使用效率</p>
<p>hashtable 编码的哈希对象使用字典作为底层实现时， 哈希对象中的每个键值对都使用一个字典键值对来保存：</p>
<ul>
<li>字典的每个键都是一个字符串对象， 对象中保存了键值对的键；</li>
<li>字典的每个值都是一个字符串对象， 对象中保存了键值对的值。</li>
</ul>
<h3 id="List（列表）"><a href="#List（列表）" class="headerlink" title="List（列表）"></a>List（列表）</h3><p>List 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）。</p>
<p>实现方式：Redis中的列表对象在版本3.2之前，列表底层的编码是 ziplist 和 linkedlist 实现的，但是在版本 3.2 之后，重新引入了一个 quicklist 的数据结构，列表的底层都由 quicklist 实现。在早期的设计中， 当列表对象中元素的长度比较小或者数量比较少的时候，采用 ziplist 来存储，当列表对象中元素的长度比较大或者数量比较多的时候，则会转而使用双向列表 linkedlist 来存储。</p>
<h4 id="这两种存储方式的优缺点"><a href="#这两种存储方式的优缺点" class="headerlink" title="这两种存储方式的优缺点"></a>这两种存储方式的优缺点</h4><ul>
<li>双向链表 linkedlist 便于在表的两端进行 push 和 pop 操作，在插入节点上复杂度很低，但是它的内存开销比较大。首先，它在每个节点上除了要保存数据之外，还要额外保存两个指针；其次，双向链表的各个节点是单独的内存块，地址不连续，节点多了容易产生内存碎片。</li>
<li>ziplist 存储在一段连续的内存上，所以存储效率很高。但是，它不利于修改操作，插入和删除操作需要频繁的申请和释放内存。特别是当 ziplist 长度很长的时候，一次 realloc 可能会导致大批量的数据拷贝。</li>
</ul>
<h3 id="Set（集合）"><a href="#Set（集合）" class="headerlink" title="Set（集合）"></a>Set（集合）</h3><p>Redis 的 Set 是 String 类型的无序集合。集合成员是唯一的，这就意味着集合中不能出现重复的数据。</p>
<p>Redis 中集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是 O(1)。</p>
<h3 id="Sorted-Set（有序集合）"><a href="#Sorted-Set（有序集合）" class="headerlink" title="Sorted Set（有序集合）"></a>Sorted Set（有序集合）</h3><p>Redis 有序集合和集合一样也是string类型元素的集合,且不允许重复的成员。不同的是每个元素都会关联一个 double 类型的分数。Redis 正是通过分数来为集合中的成员进行从小到大的排序。有序集合的成员是唯一的,但分数(score)却可以重复。</p>
<p>集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是O(1)。 集合中最大的成员数为 2^32 - 1 (4294967295, 每个集合可存储40多亿个成员)。</p>
<h3 id="Bitmaps（位图）-and-HyperLogLogs（？这个怎么翻译）"><a href="#Bitmaps（位图）-and-HyperLogLogs（？这个怎么翻译）" class="headerlink" title="Bitmaps（位图） and HyperLogLogs（？这个怎么翻译）"></a>Bitmaps（位图） and HyperLogLogs（？这个怎么翻译）</h3><p>Redis还支持位图和 HyperLogLogs，它们实际上是基于String基本类型的数据类型，但是具有自己的语义。 可以参考官网中<a href="https://redis.io/topics/data-types-intro" target="_blank" rel="noopener">introduction to Redis data types</a>以获取有关这些类型的信息。</p>
<h2 id="其他功能"><a href="#其他功能" class="headerlink" title="其他功能"></a>其他功能</h2><h3 id="Transaction（事务）"><a href="#Transaction（事务）" class="headerlink" title="Transaction（事务）"></a>Transaction（事务）</h3><p><a href="http://redisdoc.com/transaction/multi.html#multi" target="_blank" rel="noopener">MULTI</a> 、 <a href="http://redisdoc.com/transaction/exec.html#exec" target="_blank" rel="noopener">EXEC</a> 、 <a href="http://redisdoc.com/transaction/discard.html#discard" target="_blank" rel="noopener">DISCARD</a> 和 <a href="http://redisdoc.com/transaction/watch.html#watch" target="_blank" rel="noopener">WATCH</a> 是 Redis 事务的基础。</p>
<p>事务可以一次执行多个命令， 并且带有以下两个重要的保证：</p>
<ul>
<li><p>事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。</p>
</li>
<li><p>事务是一个原子操作：事务中的命令要么全部被执行，要么全部都不执行。</p>
<p><a href="http://redisdoc.com/transaction/exec.html#exec" target="_blank" rel="noopener">EXEC</a> 命令负责触发并执行事务中的所有命令：</p>
<ul>
<li>如果客户端在使用 <a href="http://redisdoc.com/transaction/multi.html#multi" target="_blank" rel="noopener">MULTI</a> 开启了一个事务之后，却因为断线而没有成功执行 <a href="http://redisdoc.com/transaction/exec.html#exec" target="_blank" rel="noopener">EXEC</a> ，那么事务中的所有命令都不会被执行。</li>
<li>另一方面，如果客户端成功在开启事务之后执行 <a href="http://redisdoc.com/transaction/exec.html#exec" target="_blank" rel="noopener">EXEC</a> ，那么事务中的所有命令都会被执行。</li>
</ul>
<p>当使用 AOF 方式做持久化的时候， Redis 会使用单个 <code>write(2)</code> 命令将事务写入到磁盘中。</p>
<p>然而，如果 Redis 服务器因为某些原因被管理员杀死，或者遇上某种硬件故障，那么可能只有部分事务命令会被成功写入到磁盘中。</p>
<p>如果 Redis 在重新启动时发现 AOF 文件出了这样的问题，那么它会退出，并汇报一个错误。</p>
<p>使用 <code>redis-check-aof</code> 程序可以修复这一问题：它会移除 AOF 文件中不完整事务的信息，确保服务器可以顺利启动。</p>
</li>
</ul>
<p>从 2.2 版本开始，Redis 还可以通过乐观锁（optimistic lock）实现 CAS （check-and-set）操作。</p>
<h3 id="Replication（复制）"><a href="#Replication（复制）" class="headerlink" title="Replication（复制）"></a>Replication（复制）</h3><p>Redis 支持简单且易用的主从复制（master-slave replication）功能， 该功能可以让从服务器(slave server)成为主服务器(master server)的精确复制品。</p>
<p>以下是关于 Redis 复制功能的几个重要方面：</p>
<ul>
<li><p>Redis 使用异步复制。 从 Redis 2.8 开始， 从服务器会以每秒一次的频率向主服务器报告复制流（replication stream）的处理进度。</p>
</li>
<li><p>一个主服务器可以有多个从服务器。</p>
</li>
<li><p>不仅主服务器可以有从服务器， 从服务器也可以有自己的从服务器， 多个从服务器之间可以构成一个图状结构。</p>
</li>
<li><p>复制功能不会阻塞主服务器： 即使有一个或多个从服务器正在进行初次同步， 主服务器也可以继续处理命令请求。</p>
</li>
<li><p>复制功能也不会阻塞从服务器： 只要在 <code>redis.conf</code> 文件中进行了相应的设置， 即使从服务器正在进行初次同步， 服务器也可以使用旧版本的数据集来处理命令查询。</p>
<p>不过， 在从服务器删除旧版本数据集并载入新版本数据集的那段时间内， 连接请求会被阻塞。</p>
<p>你还可以配置从服务器， 让它在与主服务器之间的连接断开时， 向客户端发送一个错误。</p>
</li>
<li><p>复制功能可以单纯地用于数据冗余（data redundancy）， 也可以通过让多个从服务器处理只读命令请求来提升扩展性（scalability）： 比如说， 繁重的 [SORT key [BY pattern] [LIMIT offset count] [GET pattern [GET pattern …]] [ASC | DESC] [ALPHA] [STORE destination]](<a href="http://redisdoc.com/database/sort.html#sort" target="_blank" rel="noopener">http://redisdoc.com/database/sort.html#sort</a>) 命令可以交给附属节点去运行。</p>
</li>
<li><p>可以通过复制功能来让主服务器免于执行持久化操作： 只要关闭主服务器的持久化功能， 然后由从服务器去执行持久化操作即可。</p>
</li>
</ul>
<h3 id="pub-sub（发布与订阅）"><a href="#pub-sub（发布与订阅）" class="headerlink" title="pub/sub（发布与订阅）"></a>pub/sub（发布与订阅）</h3><p><code>SUBSCRIBE</code>、<code>UNSUBSCRIBE</code> 和 <code>PUBLISH</code>三个命令实现了<a href="http://en.wikipedia.org/wiki/Publish/subscribe" target="_blank" rel="noopener">发布与订阅信息泛型</a>（Publish/Subscribe messaging paradigm）， 在这个实现中， 发送者（发送信息的客户端）不是将信息直接发送给特定的接收者（接收信息的客户端）， 而是将信息发送给频道（channel）， 然后由频道将信息转发给所有对这个频道感兴趣的订阅者。</p>
<p>发送者无须知道任何关于订阅者的信息， 而订阅者也无须知道是那个客户端给它发送信息， 它只要关注自己感兴趣的频道即可。</p>
<p>对发布者和订阅者进行解构（decoupling）， 可以极大地提高系统的扩展性（scalability）， 并得到一个更动态的网络拓扑（network topology）。</p>
<p>比如说， 要订阅频道 <code>foo</code> 和 <code>bar</code> ， 客户端可以使用频道名字作为参数来调用 <code>SUBSCRIBE</code>命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">redis&gt; SUBSCRIBE foo bar</span></pre></td></tr></table></figure>

<p>当有客户端发送信息到这些频道时， Redis 会将传入的信息推送到所有订阅这些频道的客户端里面。</p>
<p>正在订阅频道的客户端不应该发送除 <code>SUBSCRIBE</code>、<code>UNSUBSCRIBE</code>之外的其他命令。 其中， <code>SUBSCRIBE</code> 可以用于订阅更多频道， 而 <code>UNSUBSCRIBE</code> 则可以用于退订已订阅的一个或多个频道。</p>
<p><code>SUBSCRIBE</code>的执行结果会以信息的形式返回， 客户端可以通过分析所接收信息的第一个元素， 从而判断所收到的内容是一条真正的信息， 还是 <code>SUBSCRIBE</code>或<code>UNSUBSCRIBE</code> 命令的操作结果。</p>
<p>信息的第一个元素标识了信息的类型：</p>
<ul>
<li><code>subscribe</code> ： 表示当前客户端成功地订阅了信息第二个元素所指示的频道。 而信息的第三个元素则记录了目前客户端已订阅频道的总数。</li>
<li><code>unsubscribe</code> ： 表示当前客户端成功地退订了信息第二个元素所指示的频道。 信息的第三个元素记录了客户端目前仍在订阅的频道数量。 当客户端订阅的频道数量降为 <code>0</code> 时， 客户端不再订阅任何频道， 它可以像往常一样， 执行任何 Redis 命令。</li>
<li><code>message</code> ： 表示这条信息是由某个客户端执行 <a href="http://redisdoc.com/pubsub/publish.html#publish" target="_blank" rel="noopener">PUBLISH channel message</a> 命令所发送的， 真正的信息。 信息的第二个元素是信息来源的频道， 而第三个元素则是信息的内容。</li>
</ul>
<h4 id="编程示例"><a href="#编程示例" class="headerlink" title="编程示例"></a>编程示例</h4><p>Pieter Noordhuis 提供了一个使用 EventMachine 和 Redis 编写的 <a href="https://gist.github.com/348262" target="_blank" rel="noopener">高性能多用户网页聊天软件</a> ， 这个软件很好地展示了发布与订阅功能的用法。</p>
<h3 id="Sentinel（哨兵）"><a href="#Sentinel（哨兵）" class="headerlink" title="Sentinel（哨兵）"></a>Sentinel（哨兵）</h3><p>Redis 的 Sentinel 系统用于管理多个 Redis 服务器（instance）， 该系统执行以下三个任务：</p>
<ul>
<li><strong>监控（Monitoring）</strong>： Sentinel 会不断地检查你的主服务器和从服务器是否运作正常。</li>
<li><strong>提醒（Notification）</strong>： 当被监控的某个 Redis 服务器出现问题时， Sentinel 可以通过 API 向管理员或者其他应用程序发送通知。</li>
<li><strong>自动故障迁移（Automatic failover）</strong>： 当一个主服务器不能正常工作时， Sentinel 会开始一次自动故障迁移操作， 它会将失效主服务器的其中一个从服务器升级为新的主服务器， 并让失效主服务器的其他从服务器改为复制新的主服务器； 当客户端试图连接失效的主服务器时， 集群也会向客户端返回新主服务器的地址， 使得集群可以使用新主服务器代替失效服务器。</li>
</ul>
<p>Redis Sentinel 是一个分布式系统， 你可以在一个架构中运行多个 Sentinel 进程（progress）， 这些进程使用流言协议（gossip protocols)来接收关于主服务器是否下线的信息， 并使用投票协议（agreement protocols）来决定是否执行自动故障迁移， 以及选择哪个从服务器作为新的主服务器。</p>
<p>虽然 Redis Sentinel 释出为一个单独的可执行文件 <code>redis-sentinel</code> ， 但实际上它只是一个运行在特殊模式下的 Redis 服务器， 你可以在启动一个普通 Redis 服务器时通过给定 <code>--sentinel</code> 选项来启动 Redis Sentinel 。</p>
<h2 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h2><p>Redis 提供了多种不同级别的持久化方式：</p>
<ul>
<li>RDB 持久化可以在指定的时间间隔内生成数据集的时间点快照（point-in-time snapshot）。</li>
<li>AOF 持久化记录服务器执行的所有写操作命令，并在服务器启动时，通过重新执行这些命令来还原数据集。 AOF 文件中的命令全部以 Redis 协议的格式来保存，新命令会被追加到文件的末尾。 Redis 还可以在后台对 AOF 文件进行重写（rewrite），使得 AOF 文件的体积不会超出保存数据集状态所需的实际大小。</li>
<li>Redis 还可以同时使用 AOF 持久化和 RDB 持久化。 在这种情况下， 当 Redis 重启时， 它会优先使用 AOF 文件来还原数据集， 因为 AOF 文件保存的数据集通常比 RDB 文件所保存的数据集更完整。</li>
<li>你甚至可以关闭持久化功能，让数据只在服务器运行时存在。</li>
</ul>
<p>了解 RDB 持久化和 AOF 持久化之间的异同是非常重要的， 以下几个小节将详细地介绍这这两种持久化功能， 并对它们的相同和不同之处进行说明。</p>
<h3 id="RDB-的优点"><a href="#RDB-的优点" class="headerlink" title="RDB 的优点"></a>RDB 的优点</h3><ul>
<li>RDB 是一个非常紧凑（compact）的文件，它保存了 Redis 在某个时间点上的数据集。 这种文件非常适合用于进行备份： 比如说，你可以在最近的 24 小时内，每小时备份一次 RDB 文件，并且在每个月的每一天，也备份一个 RDB 文件。 这样的话，即使遇上问题，也可以随时将数据集还原到不同的版本。</li>
<li>RDB 非常适用于灾难恢复（disaster recovery）：它只有一个文件，并且内容都非常紧凑，可以（在加密后）将它传送到别的数据中心，或者亚马逊 S3 中。</li>
<li>RDB 可以最大化 Redis 的性能：父进程在保存 RDB 文件时唯一要做的就是 <code>fork</code> 出一个子进程，然后这个子进程就会处理接下来的所有保存工作，父进程无须执行任何磁盘 I/O 操作。</li>
<li>RDB 在恢复大数据集时的速度比 AOF 的恢复速度要快。</li>
</ul>
<h3 id="RDB-的缺点"><a href="#RDB-的缺点" class="headerlink" title="RDB 的缺点"></a>RDB 的缺点</h3><ul>
<li>如果你需要尽量避免在服务器故障时丢失数据，那么 RDB 不适合你。 虽然 Redis 允许你设置不同的保存点（save point）来控制保存 RDB 文件的频率， 但是， 因为RDB 文件需要保存整个数据集的状态， 所以它并不是一个轻松的操作。 因此你可能会至少 5 分钟才保存一次 RDB 文件。 在这种情况下， 一旦发生故障停机， 你就可能会丢失好几分钟的数据。</li>
<li>每次保存 RDB 的时候，Redis 都要 <code>fork()</code> 出一个子进程，并由子进程来进行实际的持久化工作。 在数据集比较庞大时， <code>fork()</code> 可能会非常耗时，造成服务器在某某毫秒内停止处理客户端； 如果数据集非常巨大，并且 CPU 时间非常紧张的话，那么这种停止时间甚至可能会长达整整一秒。 虽然 AOF 重写也需要进行 <code>fork()</code> ，但无论 AOF 重写的执行间隔有多长，数据的耐久性都不会有任何损失。</li>
</ul>
<h3 id="AOF-的优点"><a href="#AOF-的优点" class="headerlink" title="AOF 的优点"></a>AOF 的优点</h3><ul>
<li>使用 AOF 持久化会让 Redis 变得非常耐久（much more durable）：你可以设置不同的 <code>fsync</code> 策略，比如无 <code>fsync</code> ，每秒钟一次 <code>fsync</code> ，或者每次执行写入命令时 <code>fsync</code> 。 AOF 的默认策略为每秒钟 <code>fsync</code> 一次，在这种配置下，Redis 仍然可以保持良好的性能，并且就算发生故障停机，也最多只会丢失一秒钟的数据（ <code>fsync</code> 会在后台线程执行，所以主线程可以继续努力地处理命令请求）。</li>
<li>AOF 文件是一个只进行追加操作的日志文件（append only log）， 因此对 AOF 文件的写入不需要进行 <code>seek</code> ， 即使日志因为某些原因而包含了未写入完整的命令（比如写入时磁盘已满，写入中途停机，等等）， <code>redis-check-aof</code> 工具也可以轻易地修复这种问题。</li>
<li>Redis 可以在 AOF 文件体积变得过大时，自动地在后台对 AOF 进行重写： 重写后的新 AOF 文件包含了恢复当前数据集所需的最小命令集合。 整个重写操作是绝对安全的，因为 Redis 在创建新 AOF 文件的过程中，会继续将命令追加到现有的 AOF 文件里面，即使重写过程中发生停机，现有的 AOF 文件也不会丢失。 而一旦新 AOF 文件创建完毕，Redis 就会从旧 AOF 文件切换到新 AOF 文件，并开始对新 AOF 文件进行追加操作。</li>
<li>AOF 文件有序地保存了对数据库执行的所有写入操作， 这些写入操作以 Redis 协议的格式保存， 因此 AOF 文件的内容非常容易被人读懂， 对文件进行分析（parse）也很轻松。 导出（export） AOF 文件也非常简单： 举个例子， 如果你不小心执行了 <a href="http://redisdoc.com/database/flushall.html#flushall" target="_blank" rel="noopener">FLUSHALL</a> 命令， 但只要 AOF 文件未被重写， 那么只要停止服务器， 移除 AOF 文件末尾的 <a href="http://redisdoc.com/database/flushall.html#flushall" target="_blank" rel="noopener">FLUSHALL</a> 命令， 并重启 Redis ， 就可以将数据集恢复到 <a href="http://redisdoc.com/database/flushall.html#flushall" target="_blank" rel="noopener">FLUSHALL</a> 执行之前的状态。</li>
</ul>
<h3 id="AOF-的缺点"><a href="#AOF-的缺点" class="headerlink" title="AOF 的缺点"></a>AOF 的缺点</h3><ul>
<li>对于相同的数据集来说，AOF 文件的体积通常要大于 RDB 文件的体积。</li>
<li>根据所使用的 <code>fsync</code> 策略，AOF 的速度可能会慢于 RDB 。 在一般情况下， 每秒 <code>fsync</code> 的性能依然非常高， 而关闭 <code>fsync</code> 可以让 AOF 的速度和 RDB 一样快， 即使在高负荷之下也是如此。 不过在处理巨大的写入载入时，RDB 可以提供更有保证的最大延迟时间（latency）。</li>
<li>AOF 在过去曾经发生过这样的 bug ： 因为个别命令的原因，导致 AOF 文件在重新载入时，无法将数据集恢复成保存时的原样。 （举个例子，阻塞命令 <a href="http://redisdoc.com/list/brpoplpush.html#brpoplpush" target="_blank" rel="noopener">BRPOPLPUSH source destination timeout</a> 就曾经引起过这样的 bug 。） 测试套件里为这种情况添加了测试： 它们会自动生成随机的、复杂的数据集， 并通过重新载入这些数据来确保一切正常。 虽然这种 bug 在 AOF 文件中并不常见， 但是对比来说， RDB 几乎是不可能出现这种 bug 的。</li>
</ul>
<h3 id="RDB-和-AOF-，应该用哪一个？"><a href="#RDB-和-AOF-，应该用哪一个？" class="headerlink" title="RDB 和 AOF ，应该用哪一个？"></a>RDB 和 AOF ，应该用哪一个？</h3><p>一般来说， 如果想达到足以媲美 PostgreSQL 的数据安全性， 你应该同时使用两种持久化功能。</p>
<p>如果你非常关心你的数据， 但仍然可以承受数分钟以内的数据丢失， 那么你可以只使用 RDB 持久化。</p>
<p>有很多用户都只使用 AOF 持久化， 但我们并不推荐这种方式： 因为定时生成 RDB 快照（snapshot）非常便于进行数据库备份， 并且 RDB 恢复数据集的速度也要比 AOF 恢复的速度要快， 除此之外， 使用 RDB 还可以避免之前提到的 AOF 程序的 bug 。</p>
<h2 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h2><p>集群部分的内容官方文档介绍的比较详细了，这里直接大段抄自官方文档的中文翻译，<a href="http://redisdoc.com/topic/cluster-spec.html" target="_blank" rel="noopener">Redis集群规范</a>和<a href="http://redisdoc.com/topic/cluster-tutorial.html" target="_blank" rel="noopener">Redis集群教程</a>章节。</p>
<h3 id="什么是-Redis-集群？"><a href="#什么是-Redis-集群？" class="headerlink" title="什么是 Redis 集群？"></a>什么是 Redis 集群？</h3><p>Redis 集群是一个分布式（distributed）、容错（fault-tolerant）的 Redis 实现， 集群可以使用的功能是普通单机 Redis 所能使用的功能的一个子集（subset）。</p>
<p>Redis 集群中不存在中心（central）节点或者代理（proxy）节点， 集群的其中一个主要设计目标是达到线性可扩展性（linear scalability）。</p>
<p>Redis 集群为了保证一致性（consistency）而牺牲了一部分容错性： 系统会在保证对网络断线（net split）和节点失效（node failure）具有有限（limited）抵抗力的前提下， 尽可能地保持数据的一致性。</p>
<p>Redis 集群是一个可以<strong>在多个 Redis 节点之间进行数据共享</strong>的设施（installation）。</p>
<p>Redis 集群不支持那些需要同时处理多个键的 Redis 命令， 因为执行这些命令需要在多个 Redis 节点之间移动数据， 并且在高负载的情况下， 这些命令将降低 Redis 集群的性能， 并导致不可预测的行为。</p>
<p>Redis 集群<strong>通过分区（partition）来提供一定程度的可用性</strong>（availability）： 即使集群中有一部分节点失效或者无法进行通讯， 集群也可以继续处理命令请求。</p>
<p>Redis 集群提供了以下两个好处：</p>
<ul>
<li>将数据自动切分（split）到多个节点的能力。</li>
<li>当集群中的一部分节点失效或者无法进行通讯时， 仍然可以继续处理命令请求的能力。</li>
</ul>
<h3 id="Redis-集群数据共享"><a href="#Redis-集群数据共享" class="headerlink" title="Redis 集群数据共享"></a>Redis 集群数据共享</h3><p>Redis 集群使用数据分片（sharding）而非一致性哈希（consistency hashing）来实现： 一个 Redis 集群包含 <code>16384</code> 个哈希槽（hash slot）， 数据库中的每个键都属于这 <code>16384</code> 个哈希槽的其中一个， 集群使用公式 <code>CRC16(key) % 16384</code> 来计算键 <code>key</code> 属于哪个槽， 其中 <code>CRC16(key)</code> 语句用于计算键 <code>key</code> 的 <a href="http://zh.wikipedia.org/wiki/循環冗餘校驗" target="_blank" rel="noopener">CRC16 校验和</a> 。</p>
<p>集群中的每个节点负责处理一部分哈希槽。 举个例子， 一个集群可以有三个哈希槽， 其中：</p>
<ul>
<li>节点 A 负责处理 <code>0</code> 号至 <code>5500</code> 号哈希槽。</li>
<li>节点 B 负责处理 <code>5501</code> 号至 <code>11000</code> 号哈希槽。</li>
<li>节点 C 负责处理 <code>11001</code> 号至 <code>16384</code> 号哈希槽。</li>
</ul>
<p>这种将哈希槽分布到不同节点的做法使得用户可以很容易地向集群中添加或者删除节点。 比如说：</p>
<ul>
<li>如果用户将新节点 D 添加到集群中， 那么集群只需要将节点 A 、B 、 C 中的某些槽移动到节点 D 就可以了。</li>
<li>与此类似， 如果用户要从集群中移除节点 A ， 那么集群只需要将节点 A 中的所有哈希槽移动到节点 B 和节点 C ， 然后再移除空白（不包含任何哈希槽）的节点 A 就可以了。</li>
</ul>
<p>因为将一个哈希槽从一个节点移动到另一个节点不会造成节点阻塞， 所以无论是添加新节点还是移除已存在节点， 又或者改变某个节点包含的哈希槽数量， 都不会造成集群下线。</p>
<h3 id="Redis-集群中的主从复制"><a href="#Redis-集群中的主从复制" class="headerlink" title="Redis 集群中的主从复制"></a>Redis 集群中的主从复制</h3><p>为了使得集群在一部分节点下线或者无法与集群的大多数（majority）节点进行通讯的情况下， 仍然可以正常运作， Redis 集群对节点使用了主从复制功能： 集群中的每个节点都有 <code>1</code> 个至 <code>N</code> 个复制品（replica）， 其中一个复制品为主节点（master）， 而其余的 <code>N-1</code> 个复制品为从节点（slave）。</p>
<p>在之前列举的节点 A 、B 、C 的例子中， 如果节点 B 下线了， 那么集群将无法正常运行， 因为集群找不到节点来处理 <code>5501</code> 号至 <code>11000</code> 号的哈希槽。</p>
<p>另一方面， 假如在创建集群的时候（或者至少在节点 B 下线之前）， 我们为主节点 B 添加了从节点 B1 ， 那么当主节点 B 下线的时候， 集群就会将 B1 设置为新的主节点， 并让它代替下线的主节点 B ， 继续处理 <code>5501</code> 号至 <code>11000</code> 号的哈希槽， 这样集群就不会因为主节点 B 的下线而无法正常运作了。</p>
<p>不过如果节点 B 和 B1 都下线的话， Redis 集群还是会停止运作。</p>
<h3 id="Redis-集群的一致性保证（guarantee）"><a href="#Redis-集群的一致性保证（guarantee）" class="headerlink" title="Redis 集群的一致性保证（guarantee）"></a>Redis 集群的一致性保证（guarantee）</h3><p>Redis 集群<strong>不保证数据的强一致性</strong>（strong consistency）： 在特定条件下， Redis 集群可能会丢失已经被执行过的写命令。</p>
<p>使用异步复制（asynchronous replication）是 Redis 集群可能会丢失写命令的其中一个原因。 考虑以下这个写命令的例子：</p>
<ul>
<li>客户端向主节点 B 发送一条写命令。</li>
<li>主节点 B 执行写命令，并向客户端返回命令回复。</li>
<li>主节点 B 将刚刚执行的写命令复制给它的从节点 B1 、 B2 和 B3 。</li>
</ul>
<p>如你所见， 主节点对命令的复制工作发生在返回命令回复之后， 因为如果每次处理命令请求都需要等待复制操作完成的话， 那么主节点处理命令请求的速度将极大地降低 —— 我们必须在性能和一致性之间做出权衡。</p>
<p>Note</p>
<p>如果真的有必要的话， Redis 集群可能会在将来提供同步地（synchronou）执行写命令的方法。</p>
<p>Redis 集群另外一种可能会丢失命令的情况是， 集群出现网络分裂（<a href="http://en.wikipedia.org/wiki/Network_partition" target="_blank" rel="noopener">network partition</a>）， 并且一个客户端与至少包括一个主节点在内的少数（minority）实例被孤立。</p>
<p>举个例子， 假设集群包含 A 、 B 、 C 、 A1 、 B1 、 C1 六个节点， 其中 A 、B 、C 为主节点， 而 A1 、B1 、C1 分别为三个主节点的从节点， 另外还有一个客户端 Z1 。</p>
<p>假设集群中发生网络分裂， 那么集群可能会分裂为两方， 大多数（majority）的一方包含节点 A 、C 、A1 、B1 和 C1 ， 而少数（minority）的一方则包含节点 B 和客户端 Z1 。</p>
<p>在网络分裂期间， 主节点 B 仍然会接受 Z1 发送的写命令：</p>
<ul>
<li>如果网络分裂出现的时间很短， 那么集群会继续正常运行；</li>
<li>但是， 如果网络分裂出现的时间足够长， 使得大多数一方将从节点 B1 设置为新的主节点， 并使用 B1 来代替原来的主节点 B ， 那么 Z1 发送给主节点 B 的写命令将丢失。</li>
</ul>
<p>注意， 在网络分裂出现期间， 客户端 Z1 可以向主节点 B 发送写命令的最大时间是有限制的， 这一时间限制称为<strong>节点超时时间</strong>（node timeout）， 是 Redis 集群的一个重要的配置选项：</p>
<ul>
<li>对于大多数一方来说， 如果一个主节点未能在节点超时时间所设定的时限内重新联系上集群， 那么集群会将这个主节点视为下线， 并使用从节点来代替这个主节点继续工作。</li>
<li>对于少数一方， 如果一个主节点未能在节点超时时间所设定的时限内重新联系上集群， 那么它将停止处理写命令， 并向客户端报告错误。</li>
</ul>
<h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h3 id="1、为什么-Redis-这么快？"><a href="#1、为什么-Redis-这么快？" class="headerlink" title="1、为什么 Redis 这么快？"></a>1、为什么 Redis 这么快？</h3><ul>
<li>数据存于内存</li>
<li>用了多路复用I/O</li>
<li>单线程</li>
</ul>
<h3 id="2、key-过期清除（超时剔除）策略"><a href="#2、key-过期清除（超时剔除）策略" class="headerlink" title="2、key 过期清除（超时剔除）策略"></a>2、key 过期清除（超时剔除）策略</h3><ol>
<li>惰性过期（类比懒加载，这是懒过期）：只有当访问一个key时，才会判断该key是否已过期，过期则清除。该策略可以最大化地节省CPU资源，却对内存非常不友好。极端情况可能出现大量的过期key没有再次被访问，从而不会被清除，占用大量内存。</li>
<li>定期过期：每隔一定的时间，会扫描一定数量的数据库的expires字典中一定数量的key，并清除其中已过期的key。该策略是前两者的一个折中方案。通过调整定时扫描的时间间隔和每次扫描的限定耗时，可以在不同情况下使得CPU和内存资源达到最优的平衡效果</li>
</ol>
<h3 id="3、-Redis的内存淘汰策略"><a href="#3、-Redis的内存淘汰策略" class="headerlink" title="3、 Redis的内存淘汰策略"></a>3、 Redis的内存淘汰策略</h3><p>Redis的内存淘汰策略是指在Redis的用于缓存的内存不足时，怎么处理需要新写入且需要申请额外空间的数据。</p>
<ul>
<li>noeviction：当内存不足以容纳新写入数据时，新写入操作会报错。</li>
<li>allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key。</li>
<li>allkeys-random：当内存不足以容纳新写入数据时，在键空间中，随机移除某个key。</li>
<li>volatile-lru：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的key。</li>
<li>volatile-random：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个key。</li>
<li>volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的key优先移除。</li>
</ul>
<h3 id="4、如何防止缓存穿透？"><a href="#4、如何防止缓存穿透？" class="headerlink" title="4、如何防止缓存穿透？"></a>4、如何防止缓存穿透？</h3><ol>
<li>数据命中不高，变化实时性比较高的情况下，可以缓存空对象。</li>
<li>数据命中不高，相对固定实时性低的时候，用 BloomFilter 布隆过滤器。</li>
</ol>
<h3 id="5、为什么-Redis-不支持回滚（roll-back）"><a href="#5、为什么-Redis-不支持回滚（roll-back）" class="headerlink" title="5、为什么 Redis 不支持回滚（roll back）"></a>5、为什么 Redis 不支持回滚（roll back）</h3><p>如果你有使用关系式数据库的经验， 那么 “Redis 在事务失败时不进行回滚，而是继续执行余下的命令”这种做法可能会让你觉得有点奇怪。</p>
<p>以下是这种做法的优点：</p>
<ul>
<li>Redis 命令只会因为错误的语法而失败（并且这些问题不能在入队时发现），或是命令用在了错误类型的键上面：这也就是说，从实用性的角度来说，失败的命令是由编程错误造成的，而这些错误应该在开发的过程中被发现，而不应该出现在生产环境中。</li>
<li>因为不需要对回滚进行支持，所以 Redis 的内部可以保持简单且快速。</li>
</ul>
<p>有种观点认为 Redis 处理事务的做法会产生 bug ， 然而需要注意的是， 在通常情况下， 回滚并不能解决编程错误带来的问题。 举个例子， 如果你本来想通过 <a href="http://redisdoc.com/string/incr.html#incr" target="_blank" rel="noopener">INCR key</a> 命令将键的值加上 <code>1</code> ， 却不小心加上了 <code>2</code> ， 又或者对错误类型的键执行了 <a href="http://redisdoc.com/string/incr.html#incr" target="_blank" rel="noopener">INCR key</a> ， 回滚是没有办法处理这些情况的。</p>
<p>鉴于没有任何机制能避免程序员自己造成的错误， 并且这类错误通常不会在生产环境中出现， 所以 Redis 选择了更简单、更快速的无回滚方式来处理事务。</p>
<h2 id="结合Java"><a href="#结合Java" class="headerlink" title="结合Java"></a>结合Java</h2><p>参考文章</p>
<p><a href="https://youyou-tech.com/2019/11/05/redis相关原理及面试官由浅到深必问的/" target="_blank" rel="noopener">redis相关原理及面试官由浅到深必问的</a></p>
<p><a href="https://juejin.im/post/5d0da0ef6fb9a07ebd48dee0" target="_blank" rel="noopener">Redis 选择hash还是string 存储数据？</a></p>
<p><a href="https://segmentfault.com/a/1190000002906345" target="_blank" rel="noopener">Redis 持久化</a></p>
<p><a href="http://redisdoc.com/topic/persistence.html" target="_blank" rel="noopener">持久化（persistence）</a></p>
<p><a href="https://www.cnblogs.com/rjzheng/p/10360619.html" target="_blank" rel="noopener">【原创】那些年用过的Redis集群架构（含面试解析）</a></p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>redis</tag>
        <tag>NoSQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Java多线程</title>
    <url>/2020/02/01/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<p>Java 多线程相关的基础知识。</p>
<a id="more"></a>

<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h3 id="线程和进程"><a href="#线程和进程" class="headerlink" title="线程和进程"></a>线程和进程</h3><blockquote>
<p><strong>何为线程？</strong></p>
</blockquote>
<p>线程与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程<strong>共享同一块内存空间和一组系统资源</strong>，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。</p>
<blockquote>
<p><strong>何为进程？</strong></p>
</blockquote>
<p>进程是程序的一次执行过程，是<strong>系统运行程序的基本单位</strong>，因此进程是动态的。系统运行一个程序即是一个进程从创建，运行到消亡的过程。简单来说，一个进程就是一个执行中的程序，它在计算机中一个指令接着一个指令地执行着，同时，<strong>每个进程还占有某些系统资源如CPU时间，内存空间，文件，文件，输入输出设备的使用权等等</strong>。换句话说，当程序在执行时，将会被操作系统载入内存中。</p>
<blockquote>
<p><strong>线程和进程有何不同？</strong></p>
</blockquote>
<p>线程是进程划分成的更小的运行单位。线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。从另一角度来说，进程属于操作系统的范畴，主要是同一段时间内，可以同时执行一个以上的程序，而线程则是在同一程序内几乎同时执行一个以上的程序段。</p>
<h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><p><img src="http://nas.beritra.com:18081/uploads/big/40a85729402b570ed355e8a8ba0791dd.png" alt=""></p>
<p>一个线程有五个基本状态</p>
<ul>
<li>新建状态：当线程对象创建后，即进入新建状态，如：<code>Thread t = new MyThread();</code></li>
<li>就绪状态：当调用线程对象的<code>start()</code>方法时，线程即进入就绪状态。处于就绪状态的线程只是说明此线程已经做好准备，随时等待 CPU 调度执行，并不是说执行了<code>start()</code>方法就立即执行。</li>
<li>运行状态：当 CPU 开始调度处于就绪状态的线程时，此时线程才得以真正执行，即进入到运行状态。</li>
<li>阻塞状态：处于运行状态中的线程由于某种原因，暂时放弃对CPU的使用权，停止执行，此时进入阻塞状态，直到其进入到就绪状态，才有机会再次被CPU调用以进入到运行状态。阻塞状态分为三种：<ul>
<li>等待阻塞</li>
<li>同步阻塞</li>
<li>其他阻塞</li>
</ul>
</li>
<li>死亡状态：线程执行完毕或者异常退出，该线程结束生命周期。</li>
</ul>
<h2 id="重要概念"><a href="#重要概念" class="headerlink" title="重要概念"></a>重要概念</h2><h3 id="synchronized-关键字"><a href="#synchronized-关键字" class="headerlink" title="synchronized 关键字"></a>synchronized 关键字</h3><p><code>synchronized</code>是 Java 中的关键字，是利用锁的机制来实现同步的。</p>
<p>锁机制有如下两种特性：</p>
<ul>
<li>互斥性：即在同一时间只允许一个线程持有某个对象锁，通过这种特性来实现多线程中的协调机制，这样在同一时间只有一个线程对需同步的代码块(复合操作)进行访问。互斥性我们也往往称为操作的原子性。</li>
<li>可见性：必须确保在锁被释放之前，对共享变量所做的修改，对于随后获得该锁的另一个线程是可见的（即在获得锁时应获得最新共享变量的值），否则另一个线程可能是在本地缓存的某个副本上继续操作从而引起不一致。</li>
</ul>
<p><code>synchronized</code>的作用域包括以下几个部分：</p>
<h4 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h4><p>一个线程访问一个对象中的<code>synchronized(this)</code>同步代码块时，其他试图访问该对象的线程将被阻塞。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            System.out.println(Thread.currentThread().getId() + <span class="string">" running"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            Thread.sleep(<span class="number">2000</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            System.out.println(Thread.currentThread().getId() + <span class="string">" complete"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            e.printStackTrace();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>同一时刻只有一个线程可以执行<code>run()</code>方法</p>
<p>或者锁一个对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Integer count=<span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">synchronized</span> (count)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            System.out.println(Thread.currentThread().getId() + <span class="string">" running"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            Thread.sleep(<span class="number">2000</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            count++;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            System.out.println(Thread.currentThread().getId() + <span class="string">" complete"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            e.printStackTrace();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>起到同样的作用，<code>count</code>这个对象同一时间只能一个线程访问。</p>
<h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.println(Thread.currentThread().getId() + <span class="string">" running"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Thread.sleep(<span class="number">2000</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.println(Thread.currentThread().getId() + <span class="string">" complete"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        e.printStackTrace();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>



<h4 id="代码块（类）"><a href="#代码块（类）" class="headerlink" title="代码块（类）"></a>代码块（类）</h4><p><code>synchronized</code>关键字同样可以同步代码块，但是只有代码块内部的代码被锁，同一个方法里的其他代码仍然可以并行执行。另外需要注意，<code>synchronized</code>其实作用的是对象，所以如果这里锁中是<code>this</code>，并不能保证代码被顺序执行，只能保证同一个对象内的代码。因此要改成锁住类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">synchronizedCodeBlock</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    System.out.println(Thread.currentThread().getId() + <span class="string">":同一个方法里没有被锁的部分可以同步执行"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>.getClass()) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            Thread.sleep(<span class="number">100</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            e.printStackTrace();</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.println(Thread.currentThread().getId() + <span class="string">":被锁住的代码部分必须顺序执行"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>



<h4 id="静态变量、方法、代码块"><a href="#静态变量、方法、代码块" class="headerlink" title="静态变量、方法、代码块"></a>静态变量、方法、代码块</h4><p>synchronize关键字如果修饰的是一个静态变量、静态方法或者静态代码块的时候，同步的是这个类的所有实例。</p>
<p>锁静态方法、变量的话，会作用于该类的所有实例。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">synchronizedStaticFunction</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Thread.sleep(<span class="number">200</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        e.printStackTrace();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    System.out.println(Thread.currentThread().getId() + <span class="string">":静态方法"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h3 id="Lock-接口"><a href="#Lock-接口" class="headerlink" title="Lock 接口"></a>Lock 接口</h3><p><code>Lock</code>不是一个关键字，而是一个接口，使用方式跟<code>synchronized</code>类似</p>
<p>总结来说，<code>Lock</code>和<code>synchronized</code>有以下几点不同：</p>
<ul>
<li><code>Lock</code>是一个接口，而<code>synchronized</code>是Java中的关键字，<code>synchronized</code>是内置的语言实现；</li>
<li><code>synchronized</code>在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生；而<code>Lock</code>在发生异常时，如果没有主动通过<code>unLock()</code>去释放锁，则很可能造成死锁现象，因此使用<code>Lock</code>时需要在<code>finally</code>块中释放锁；</li>
<li><code>Lock</code>可以让等待锁的线程响应中断，而<code>synchronized</code>却不行，使用<code>synchronized</code>时，等待的线程会一直等待下去，不能够响应中断；</li>
<li>通过<code>Lock</code>可以知道有没有成功获取锁，而<code>synchronized</code>却无法办到。</li>
<li><code>Lock</code>可以提高多个线程进行读操作的效率。</li>
</ul>
<p>在性能上来说，如果竞争资源不激烈，两者的性能是差不多的，而当竞争资源非常激烈时（即有大量线程同时竞争），此时<code>Lock</code>的性能要远远优于<code>synchronized</code>。所以说，在具体使用时要根据适当情况选择。</p>
<h3 id="volatile-关键字"><a href="#volatile-关键字" class="headerlink" title="volatile 关键字"></a>volatile 关键字</h3><p>被<code>volatile</code>修饰的共享变量，就具有了以下两点特性：</p>
<ol>
<li><p>保证了不同线程对该变量操作的内存可见性;</p>
</li>
<li><p>禁止指令重排序</p>
</li>
</ol>
<p>JMM主要就是围绕着如何在并发过程中如何处理原子性、可见性和有序性这3个特征来建立的，通过解决这三个问题，可以解除缓存不一致的问题。而<code>volatile</code>跟可见性和有序性都有关。<code>volatile</code>不保证原子性。</p>
<p>一个简单的测试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyVolatileClass</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        a = a+<span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>开启多个线程执行一万次<code>add()</code>方法之后，可以看到a的结果并不是一万，而是要少于一万。无论<code>int a</code>前面加不加<code>volatile</code>结果都一样。所以<code>volatile</code>不能保证操作的原子性。那么<code>volatile</code>的作用是什么？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> stop = <span class="keyword">false</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">while</span>(!stop) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.println(<span class="string">"停止了"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;).start();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Thread.sleep(<span class="number">1000</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        e.printStackTrace();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    stop = <span class="keyword">true</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    System.out.println(<span class="string">"赶快停止吧 "</span> + stop);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>如果不带<code>volatile</code>关键字，那么循环很可能不会终止。</p>
<h3 id="锁的种类"><a href="#锁的种类" class="headerlink" title="锁的种类"></a>锁的种类</h3><h4 id="可中断锁"><a href="#可中断锁" class="headerlink" title="可中断锁"></a>可中断锁</h4><p><code>Lock</code>是可中断锁，而<code>synchronized</code>不是可中断锁</p>
<p>线程 A 和 B 都要获取对象 O 的锁定，假设 A 获取了对象 O 锁，B 将等待 A 释放对 O 的锁定，如果使用<code>synchronized</code>，如果 A 不释放，B 将一直等下去，不能被中断。</p>
<p>如果使用<code>ReentrantLock</code>，即使 A 不释放，也可以使 B 在等待了足够长的时间以后，中断等待，而干别的事情。</p>
<h4 id="公平锁-非公平锁"><a href="#公平锁-非公平锁" class="headerlink" title="公平锁/非公平锁"></a>公平锁/非公平锁</h4><p>公平锁是指多个线程按照申请锁的顺序来获取锁。非公平锁是指多个线程获取锁的顺序并不是按照申请锁的顺序，有可能后申请的线程比先申请的线程优先获取锁。有可能，会造成优先级反转或者饥饿现象。对于<code>Java ReentrantLock</code>而言，通过构造函数指定该锁是否是公平锁，默认是非公平锁。非公平锁的优点在于吞吐量比公平锁大。对于<code>synchronized</code>而言，也是一种非公平锁。由于其并不像<code>ReentrantLock</code>是通过 AQS 来实现线程调度，所以并没有任何办法使其变成公平锁。</p>
<h4 id="乐观锁-悲观锁"><a href="#乐观锁-悲观锁" class="headerlink" title="乐观锁/悲观锁"></a>乐观锁/悲观锁</h4><p>乐观锁与悲观锁不是指具体的什么类型的锁，而是指看待并发同步的角度。悲观锁认为对于同一个数据的并发操作，一定是会发生修改的，哪怕没有修改，也会认为修改。因此对于同一个数据的并发操作，悲观锁采取加锁的形式。悲观的认为，不加锁的并发操作一定会出问题。乐观锁则认为对于同一个数据的并发操作，是不会发生修改的。在更新数据的时候，会采用尝试更新，不断重新的方式更新数据。乐观的认为，不加锁的并发操作是没有事情的。从上面的描述我们可以看出，悲观锁适合写操作非常多的场景，乐观锁适合读操作非常多的场景，不加锁会带来大量的性能提升。悲观锁在 Java 中的使用，就是利用各种锁。乐观锁在 Java 中的使用，是无锁编程，常常采用的是 CAS 算法，典型的例子就是原子类，通过 CAS 自旋实现原子操作的更新。</p>
<h4 id="独享锁-共享锁"><a href="#独享锁-共享锁" class="headerlink" title="独享锁/共享锁"></a>独享锁/共享锁</h4><p>独享锁是指该锁一次只能被一个线程所持有。共享锁是指该锁可被多个线程所持有。对于<code>Java ReentrantLock</code>而言，其是独享锁。但是对于<code>Lock</code>的另一个实现类<code>ReentrantReadWriteLock</code>，其读锁是共享锁，其写锁是独享锁。读锁的共享锁可保证并发读是非常高效的，读写，写读 ，写写的过程是互斥的。独享锁与共享锁也是通过AQS来实现的，通过实现不同的方法，来实现独享或者共享。对于<code>synchronized</code> 而言，当然是独享锁。</p>
<h4 id="可重入锁-不可重入锁"><a href="#可重入锁-不可重入锁" class="headerlink" title="可重入锁/不可重入锁"></a>可重入锁/不可重入锁</h4><p>可重入锁又名递归锁，是指在同一个线程在外层方法获取锁的时候，在进入内层方法会自动获取锁。</p>
<h4 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h4><p><code>ReentrantLock</code> 属于排他锁，这些锁在同一时刻只允许一个线程进行访问，而读写锁在同一时刻可以允许多个线程访问，但是在写线程访问时，所有的读和其他写线程都被阻塞。读写锁维护了一对锁，一个读锁和一个写锁，通过分离读锁和写锁，使得并发性相比一般的排他锁有了很大提升。</p>
<h4 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h4><p>阻塞或唤醒一个 Java 线程需要操作系统切换 CPU 状态来完成，这种状态转换需要耗费处理器时间。如果同步代码块中的内容过于简单，状态转换消耗的时间有可能比用户代码执行的时间还要长。</p>
<p>在许多场景中，同步资源的锁定时间很短，为了这一小段时间去切换线程，线程挂起和恢复现场的花费可能会让系统得不偿失。如果物理机器有多个处理器，能够让两个或以上的线程同时并行执行，我们就可以让后面那个请求锁的线程不放弃 CPU 的执行时间，看看持有锁的线程是否很快就会释放锁。</p>
<p>而为了让当前线程“稍等一下”，我们需让当前线程进行自旋，如果在自旋完成后前面锁定同步资源的线程已经释放了锁，那么当前线程就可以不必阻塞而是直接获取同步资源，从而避免切换线程的开销。这就是自旋锁。</p>
<p>借一张网图来总结：</p>
<p><img src="http://nas.beritra.com:18081/uploads/medium/3d05b309bcf6993ae4a457f77af3e732.png" alt=""></p>
<h2 id="基本使用方式"><a href="#基本使用方式" class="headerlink" title="基本使用方式"></a>基本使用方式</h2><h3 id="继承-Thread-类"><a href="#继承-Thread-类" class="headerlink" title="继承 Thread 类"></a>继承 Thread 类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.println(<span class="string">"MyThread is running"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h3 id="实现-Runnable-接口"><a href="#实现-Runnable-接口" class="headerlink" title="实现 Runnable 接口"></a>实现 Runnable 接口</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.println(<span class="string">"MyRunnable is running"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h3 id="实现-Callable-接口"><a href="#实现-Callable-接口" class="headerlink" title="实现 Callable 接口"></a>实现 Callable 接口</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCallable</span> <span class="keyword">implements</span> <span class="title">Callable</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">call</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.println(<span class="string">"MyCallable is running"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h3 id="三者区别"><a href="#三者区别" class="headerlink" title="三者区别"></a>三者区别</h3><ul>
<li>继承<code>Thread</code>不方便共享变量，由于 Java 的单继承机制，继承了<code>Thread</code>类之后不能再继承别的类。</li>
<li><code>Runnable</code>和<code>Callable</code>功能比较相似，主要区别有：<ul>
<li><code>Runnable</code>是自从 Java 1.1就有了，而<code>Callable</code>是1.5之后才加上去的</li>
<li><code>Callable</code>规定的方法是<code>call()</code>，<code>Runnable</code>规定的方法是<code>run()</code></li>
<li><code>Callable</code>的任务执行后可返回值，而<code>Runnable</code>的任务没有返回值(是void)</li>
<li><code>call()</code>方法可以抛出异常，<code>run()</code>方法不可以</li>
<li>运行Callable任务可以拿到一个Future对象，表示异步计算的结果。它提供了检查计算是否完成的方法，以等待计算的完成，并检索计算的结果。通过Future对象可以了解任务执行情况，可取消任务的执行，还可获取执行结果。</li>
<li>加入线程池运行，Runnable使用ExecutorService的execute方法，Callable使用submit方法</li>
</ul>
</li>
</ul>
<h3 id="执行run方法和start方法的区别"><a href="#执行run方法和start方法的区别" class="headerlink" title="执行run方法和start方法的区别"></a>执行<code>run</code>方法和<code>start</code>方法的区别</h3><p><code>start()</code>的作用是启动一个新的线程。</p>
<p>通过<code>start()</code>方法来启动的新线程，处于就绪（可运行）状态，并没有运行，一旦得到cpu时间片，就开始执行相应线程的<code>run()</code>方法，这里方法<code>run()</code>称为线程体，它包含了要执行的这个线程的内容，<code>run</code>方法运行结束，此线程随即终止。<code>start()</code>不能被重复调用。用<code>start</code>方法来启动线程，真正实现了多线程运行，即无需等待某个线程的<code>run</code>方法体代码执行完毕就直接继续执行下面的代码。这里无需等待<code>run</code>方法执行完毕，即可继续执行下面的代码，即进行了线程切换。</p>
<p><code>run()</code>就和普通的成员方法一样，可以被重复调用。</p>
<p>如果直接调用<code>run</code>方法，并不会启动新线程！程序中依然只有主线程这一个线程，其程序执行路径还是只有一条，还是要顺序执行，还是要等待<code>run</code>方法体执行完毕后才可继续执行下面的代码，这样就没有达到多线程的目的。</p>
<p>总结：调用<code>start</code>方法方可启动线程，而<code>run</code>方法只是<code>Thread</code>的一个普通方法调用，还是在主线程里执行。</p>
<h3 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h3><p><code>Future</code>就是对于具体的<code>Runnable</code>或者<code>Callable</code>任务的执行结果进行取消、查询是否完成、获取结果。必要时可以通过<code>get</code>方法获取执行结果，该方法会阻塞直到任务返回结果。</p>
<p>在<code>Future</code>接口中声明了5个方法，下面依次解释每个方法的作用：</p>
<ul>
<li><code>cancel(boolean mayInterruptIfRunning)</code>方法用来取消任务，如果取消任务成功则返回<code>true</code>，如果取消任务失败则返回<code>false</code>。参数<code>mayInterruptIfRunning</code>表示是否允许取消正在执行却没有执行完毕的任务，如果设置<code>true</code>，则表示可以取消正在执行过程中的任务。如果任务已经完成，则无论<code>mayInterruptIfRunning</code>为<code>true</code>还是<code>false</code>，此方法肯定返回<code>false</code>，即如果取消已经完成的任务会返回<code>false</code>；如果任务正在执行，若<code>mayInterruptIfRunning</code>设置为<code>true</code>，则返回<code>true</code>，若<code>mayInterruptIfRunning</code>设置为<code>false</code>，则返回<code>false</code>；如果任务还没有执行，则无论<code>mayInterruptIfRunning</code>为<code>true</code>还是<code>false</code>，肯定返回<code>true</code>。</li>
<li><code>isCancelled()</code>方法表示任务是否被取消成功，如果在任务正常完成前被取消成功，则返回 <code>true</code>。</li>
<li><code>isDone()</code>方法表示任务是否已经完成，若任务完成，则返回<code>true</code>；</li>
<li><code>get()</code>方法用来获取执行结果，这个方法会产生阻塞，会一直等到任务执行完毕才返回；</li>
<li><code>get(long timeout, TimeUnit unit)</code>用来获取执行结果，如果在指定时间内，还没获取到结果，就直接返回<code>null</code>。</li>
</ul>
<p>也就是说<code>Future</code>提供了三种功能：</p>
<ul>
<li>判断任务是否完成；</li>
<li>能够中断任务；</li>
<li>能够获取任务执行结果。</li>
</ul>
<h3 id="FutureTask"><a href="#FutureTask" class="headerlink" title="FutureTask"></a>FutureTask</h3><p><img src="http://nas.beritra.com:18081/uploads/big/c8b49e841c60320023da03cf16b912c8.png" alt=""></p>
<p>FutureTask类实现了<code>RunnableFuture</code>接口，我们看一下<code>RunnableFuture</code>接口的实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RunnableFuture</span> <span class="keyword">extends</span> <span class="title">Runnable</span>, <span class="title">Future</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>可以看出<code>RunnableFuture</code>继承了<code>Runnable</code>接口和<code>Future</code>接口，而<code>FutureTask</code>实现了<code>RunnableFuture</code>接口。所以它既可以作为<code>Runnable</code>被线程执行，又可以作为<code>Future</code>得到<code>Callable</code>的返回值。</p>
<p><code>FutureTask</code>提供了2个构造器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FutureTask</span><span class="params">(Callable callable)</span> </span>&#123;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FutureTask</span><span class="params">(Runnable runnable, V result)</span> </span>&#123;&#125;</span></pre></td></tr></table></figure>

<p>事实上，<code>FutureTask</code>是<code>Future</code>接口的一个唯一实现类。</p>
<h2 id="线程通信和控制"><a href="#线程通信和控制" class="headerlink" title="线程通信和控制"></a>线程通信和控制</h2><p>在调用<code>wait()</code>, <code>notify()</code>或<code>notifyAll()</code>的时候，必须先获得锁，且状态变量须由该锁保护，而固有锁对象与固有条件队列对象又是同一个对象。也就是说，要在某个对象上执行<code>wait</code>，<code>notify</code>，先必须锁定该对象，而对应的状态变量也是由该对象锁保护的。</p>
<p>调用一个<code>Object</code>的<code>wait</code>与<code>notify/notifyAll</code>的时候，必须保证调用代码对该<code>Object</code>是同步的，也就是说必须在作用等同于<code>synchronized(obj){......}</code>的内部才能够去调用<code>obj</code>的<code>wait</code>与<code>notify/notifyAll</code>三个方法，否则就会报错：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java.lang.IllegalMonitorStateException:current thread not owner</span></pre></td></tr></table></figure>



<h3 id="wait-notify-notifyAll"><a href="#wait-notify-notifyAll" class="headerlink" title="wait/notify/notifyAll"></a>wait/notify/notifyAll</h3><p>一个简单的等待、唤醒示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WaitAndNotify</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Object lock = <span class="keyword">new</span> Object();</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">prevFunc</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            Thread.sleep(<span class="number">2000</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">synchronized</span> (lock) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                lock.notifyAll();</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            e.printStackTrace();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nextFunc</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">synchronized</span> (lock) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                System.out.println(Thread.currentThread().getId() + <span class="string">"等待任务执行,线程wait"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                lock.wait();</span></pre></td></tr><tr><td class="code"><pre><span class="line">                System.out.println(Thread.currentThread().getId() + <span class="string">"任务执行完毕,线程notify"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            e.printStackTrace();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        WaitAndNotify waitAndNotify = <span class="keyword">new</span> WaitAndNotify();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">new</span> Thread(waitAndNotify::nextFunc).start();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">new</span> Thread(waitAndNotify::nextFunc).start();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">new</span> Thread(waitAndNotify::nextFunc).start();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">new</span> Thread(waitAndNotify::prevFunc).start();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p><code>notify</code>和<code>notifyAll</code>的区别是前者只随机唤醒一个线程，后者唤醒所有。</p>
<h3 id="join"><a href="#join" class="headerlink" title="join"></a>join</h3><p><code>join</code>的作用很简单：让一个线程等待另一个线结束之后才能继续运行。</p>
<p>举个栗子，主线程创造一个子线程执行耗时操作，等子线程执行完之后回到主线程继续处理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadJoin</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">funcA</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            System.out.println(Thread.currentThread().getId() + <span class="string">"开始耗时操作"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            Thread.sleep(<span class="number">2000</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            System.out.println(Thread.currentThread().getId() + <span class="string">"耗时操作完成"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            e.printStackTrace();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ThreadJoin threadJoin = <span class="keyword">new</span> ThreadJoin();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Thread thread = <span class="keyword">new</span> Thread(threadJoin::funcA);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        thread.start();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            System.out.println(<span class="string">"主线程等待结果"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            thread.join();</span></pre></td></tr><tr><td class="code"><pre><span class="line">            System.out.println(<span class="string">"主线程结束"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            e.printStackTrace();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>



<h3 id="yield"><a href="#yield" class="headerlink" title="yield"></a>yield</h3><p><code>yield</code>的作用也很简单，就是让出当前时间片，让其他线程使用 CPU，自身从运行状态重新变成就绪状态，然后重新竞争 CPU 的使用权。</p>
<p>平时几乎没用过<code>yield</code>，看到一篇博客上这么说明的：</p>
<blockquote>
<p>yield 方法可以很好的控制多线程，如执行某项复杂的任务时，如果担心占用资源过多，可以在完成某个重要的工作后使用 yield 方法让掉当前 CPU 的调度权，等下次获取到再继续执行，这样不但能完成自己的重要工作，也能给其他线程一些运行的机会，避免一个线程长时间占有 CPU 资源。</p>
</blockquote>
<h3 id="Interrupt"><a href="#Interrupt" class="headerlink" title="Interrupt"></a>Interrupt</h3><p>线程的<code>interrupt()</code>方法是中断线程，将会设置该线程的中断状态位，即设置为<code>true</code>，中断的结果线程是死亡、还是等待新的任务或是继续运行至下一步，就取决于这个程序本身。线程会不时地检测这个中断标示位，以判断线程是否应该被中断（中断标示值是否为<code>true</code>）。它并不像<code>stop</code>方法那样会中断一个正在运行的线程。</p>
<p>一个最简单的用法，在线程内判断是否被中断，线程外进行中断操作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (!Thread.interrupted()) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    System.out.println(<span class="string">"running"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>



<h2 id="底层实现方式"><a href="#底层实现方式" class="headerlink" title="底层实现方式"></a>底层实现方式</h2><h3 id="synchronized-的实现方式"><a href="#synchronized-的实现方式" class="headerlink" title="synchronized 的实现方式"></a>synchronized 的实现方式</h3><p>由于对 c++ 的源码不熟悉，仅从现有的博客中总结<code>synchronized</code>关键字实现方式。</p>
<p>每个对象都拥有自己的监视器，当这个对象由同步块或者这个对象的同步方法调用时，执行方法的线程必须先获取该对象的监视器才能进入同步块和同步方法，如果没有获取到监视器的线程将会被阻塞在同步块和同步方法的入口处，进入到 BLOCKED 状态。</p>
<p>对于同步方法：方法级同步没有通过字节码指令来控制，它实现在方法调用和返回操作之中。当方法调用时，调用指令会检查方法<code>ACC_SYNCHRONIZED</code>访问标志是否被设置，若设置了则执行线程需要持有监视器(Monitor)才能运行方法，当方法完成(无论是否出现异常)时释放监视器。</p>
<p>对于同步代码块：<code>synchronized</code>关键字经过编译后，会在同步块的前后分别形成<code>monitorenter</code>和<code>monitorexit</code>两个字节码指令，每条<code>monitorenter</code>指令都必须执行其对应的<code>monitorexit</code>指令，为了保证方法异常完成时这两条指令依然能正确执行，编译器还会自动产生一个异常处理器，其目的就是用来执行<code>monitorexit</code>指令。</p>
<p><img src="http://nas.beritra.com:18081/uploads/big/2c499be0e7ef958becb573bbfa23c145.png" alt=""></p>
<p>Monitor是线程私有的数据结构，每个线程都有一个可用monitor record列表，同时 还有一个全局的可用列表。每一个被锁住的对象都会和一个monitor关联(对象头的MarkWord中的LockWord指向monitor的起始地址)，同时monitor中有一个owner字段存放拥有该锁的线程的唯一标识，表示该锁被这个线程占用。其结构如下:</p>
<p><img src="http://nas.beritra.com:18081/uploads/big/94cfdf0ab387033027a6c53fb302d9cc.png" alt=""></p>
<p><strong>Owner</strong>：初始时为 NULL 表示当前没有任何线程拥有该<code>monitor record</code>，当线程成功拥有该锁后保存线程唯一标识，当锁被释放时又设置为 NULL<br> <strong>EntryQ</strong>：关联一个系统互斥锁（semaphore），阻塞所有试图锁住<code>monitor record</code>失败的线程<br> <strong>RcThis</strong>：表示<code>blocked</code>或<code>waiting</code>在该<code>monitor record</code>上的所有线程的个数<br> <strong>Nest</strong>：用来实现重入锁的计数<br> <strong>HashCode</strong>：保存从对象头拷贝过来的<code>HashCode</code>值（可能还包含GC age）<br> <strong>Candidate</strong>：用来避免不必要的阻塞或等待线程唤醒，因为每一次只有一个线程能够成功拥有锁，如果每次前一个释放锁的线程唤醒所有正在阻塞或等待的线程，会引起不必要的上下文切换（从阻塞到就绪然后因为竞争锁失败又被阻塞）从而导致性能严重下降。Candidate只有两种可能的值 0 表示没有需要唤醒的线程 1 表示要唤醒一个继任线程来竞争锁。</p>
<h3 id="Lock-实现原理"><a href="#Lock-实现原理" class="headerlink" title="Lock 实现原理"></a>Lock 实现原理</h3><h4 id="加锁过程"><a href="#加锁过程" class="headerlink" title="加锁过程"></a>加锁过程</h4><p>以<code>ReentrantLock</code>为例，我们看看他都做了些什么：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    sync = <span class="keyword">new</span> NonfairSync();</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>在构造方法中，就是初始化了一个静态内部类，叫做非公平同步，继续点进去，可以看到类似这个<code>NonfairSync</code>，还有个<code>FairSync</code>，都是继承于<code>Sync</code>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="title">static</span> <span class="title">final</span> <span class="title">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span></span></span></pre></td></tr></table></figure>

<p>而<code>Sync</code>由继承自<code>AbstractQueuedSynchronizer</code>，这么长一坨是个什么东西？从名字里可以看出是个抽象的队列同步器。而他由继承自<code>AbstractOwnableSynchronizer(AOS)</code>，整个继承关系如下：</p>
<p><img src="http://nas.beritra.com:18081/uploads/big/32373d5fa230fd7c9bb7dd9fff530c9c.png" alt=""></p>
<p><code>FairSync</code>与<code>NonfairSync</code>的区别在于，是不是保证获取锁的公平性，因为默认是<code>NonfairSync</code>，我们就先看这个。</p>
<p>点进<code>AbstractQueuedSynchronizer</code>代码里面，可以看到内部维护了一个双向链表，锁的存储结构归根结底就是两个东西：双向链表+<code>int</code>类型的状态。</p>
<p><img src="http://nas.beritra.com:18081/uploads/big/13e2a62fe8578a0cd53d2cfeca9748fc.png" alt=""></p>
<p>可以看到，都是用<code>volatile</code>关键字修饰的，链表的头尾还有<code>transient</code>关键字。</p>
<p>获取锁的时候，又做了什么？我们查看<code>ReentrantLock</code>的<code>lock()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    sync.acquire(<span class="number">1</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>继续追踪，借着注释的帮助：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * Acquires in exclusive mode, ignoring interrupts.  Implemented</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * by invoking at least once &#123;<span class="doctag">@link</span> #tryAcquire&#125;,</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * returning on success.  Otherwise the thread is queued, possibly</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * repeatedly blocking and unblocking, invoking &#123;<span class="doctag">@link</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * #tryAcquire&#125; until success.  This method can be used</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * to implement method &#123;<span class="doctag">@link</span> Lock#lock&#125;.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> *</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * <span class="doctag">@param</span> arg the acquire argument.  This value is conveyed to</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> *        &#123;<span class="doctag">@link</span> #tryAcquire&#125; but is otherwise uninterpreted and</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> *        can represent anything you like.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span></pre></td></tr><tr><td class="code"><pre><span class="line">        selfInterrupt();</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>可以看到这里实际上做了三个动作：</p>
<ol>
<li><p>尝试设置<code>state</code>，也就是获取锁，这里的<code>tryAcquire</code>实际上对应了<code>Fair</code>和<code>Nonefair</code>两种情况，我们继续以默认的非公平来看。（公平的情况其实类似，只不过在加锁之前判断了一下当前线程是不是在等待队列的队首，以保证公平性。）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> c = getState();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            setExclusiveOwnerThread(current);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        setState(nextc);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>很好理解，如果<code>state==0</code>，就是说锁没有被占用，就把<code>state</code>原子操作地设置为 1，也就是占用锁，然后记录当前线程。如果请求占用锁的是当前持有锁的线程，就把<code>state</code>加一。其他情况获取不到锁，返回失败。</p>
<p>这一步如果获取锁成功，就没有后续步骤了，如果失败，就进行第二步。</p>
</li>
<li><p><code>addWaiter</code>：将当前线程加入上面锁的双向链表（等待队列）中。这里用的是<code>CAS</code>的方式，这一步比较简单就不放源码了。</p>
</li>
<li><p><code>acquireQueued()</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * Acquires in exclusive uninterruptible mode for thread already in</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * queue. Used by condition wait methods as well as acquire.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> *</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * <span class="doctag">@param</span> node the node</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * <span class="doctag">@param</span> arg the acquire argument</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if interrupted while waiting</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> */</span>    </span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> (;;) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                setHead(node);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">return</span> interrupted;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node))</span></pre></td></tr><tr><td class="code"><pre><span class="line">                interrupted |= parkAndCheckInterrupt();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        cancelAcquire(node);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (interrupted)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            selfInterrupt();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">throw</span> t;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>前面我们已经把当前线程加到队列的队尾了，<code>acquireQueued()</code>的作用就是逐步的去执行等待队列的线程，如果当前线程获取到了锁，则返回；否则，当前线程进行休眠，直到唤醒并重新获取锁了才返回。</p>
<p><code>shouldParkAfterFailedAcquire()</code>方法的作用是判断当前线程是否需要被阻塞，具体的判断规则如下：</p>
<ul>
<li>规则1：如果前继节点状态为<code>SIGNAL</code>，表明当前节点需要被<code>unpark</code>(唤醒)，此时则返回<code>true</code>。parkAndCheckInterrupt()的作用是阻塞当前线程，并且返回“线程被唤醒之后”的中断状态。</li>
<li>规则2：如果前继节点状态为<code>CANCELLED</code>(ws&gt;0)，说明前继节点已经被取消，则通过先前回溯找到一个有效(非<code>CANCELLED</code>状态)的节点，并返回<code>false</code>。</li>
<li>规则3：如果前继节点状态为非<code>SIGNA</code>L、非<code>CANCELLED</code>，则设置前继的状态为<code>SIGNAL</code>，并返回<code>false</code>。</li>
</ul>
<p>看代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> ws = pred.waitStatus;<span class="comment">// 前继节点的状态</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (ws == Node.SIGNAL)<span class="comment">// 如果前继节点是SIGNAL状态，则意味这当前线程需要被unpark唤醒。此时，返回true。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">/*</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">         * This node has already set status asking a release</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">         * to signal it, so it can safely park.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">         */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;<span class="comment">// 如果前继节点是“取消”状态，则设置 “当前节点”的 “当前前继节点”  为  “‘原前继节点’的前继节点”。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">/*</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">         * Predecessor was cancelled. Skip over predecessors and</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">         * indicate retry.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">         */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">do</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            node.prev = pred = pred.prev;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        pred.next = node;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125; <span class="keyword">else</span> &#123;  <span class="comment">// 如果前继节点为“0”或者“共享锁”状态，则设置前继节点为SIGNAL状态。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">/*</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">         * waitStatus must be 0 or PROPAGATE.  Indicate that we</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">         * need a signal, but don't park yet.  Caller will need to</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">         * retry to make sure it cannot acquire before parking.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">         */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        pred.compareAndSetWaitStatus(ws, Node.SIGNAL);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>如果“规则1”发生，即“前继节点是<code>SIGNAL</code>”状态，则意味着“当前线程”需要被阻塞。接下来会调用<code>parkAndCheckInterrupt()</code>阻塞当前线程，直到当前先被唤醒才从<code>parkAndCheckInterrupt()</code>中返回。<code>parkAndCheckInterrupt()</code>的作用是阻塞当前线程，并且返回“线程被唤醒之后”的中断状态。</p>
</li>
</ol>
<p>三个步骤都完成之后，<code>if()</code>中的判断终于结束了，进入到方法<code>selfInterrupt()</code>。这个就很简单了，当前线程自己执行一个中断。</p>
<p>再回顾整个过程：</p>
<ol>
<li>先是通过<code>tryAcquire()</code>尝试获取锁。获取成功的话，直接返回；尝试失败的话，再通过<code>acquireQueued()</code>获取锁。</li>
<li>尝试失败的情况下，会先通过<code>addWaiter()</code>来将当前线程加入到<code>CLH</code>队列末尾；然后调用<code>acquireQueued()</code>，在<code>CLH</code>队列中排序等待获取锁，在此过程中，线程处于休眠状态。直到获取锁了才返回。 如果在休眠等待过程中被中断过，则调用<code>selfInterrupt()</code>来自己产生一个中断。</li>
</ol>
<h4 id="释放锁过程"><a href="#释放锁过程" class="headerlink" title="释放锁过程"></a>释放锁过程</h4><p>释放锁过程相对简单：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    sync.release(<span class="number">1</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>继续追踪：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Node h = head;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            unparkSuccessor(h);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>可以看到，先尝试释放锁，这里就是判断下锁的<code>state</code>的数字是不是 0，当前线程是不是锁的持有者。释放成功之后，唤醒等待队列的后续节点，因为已经让出锁了，可以让后续的节点进行操作。</p>
<h2 id="可能遇到的问题和解决办法"><a href="#可能遇到的问题和解决办法" class="headerlink" title="可能遇到的问题和解决办法"></a>可能遇到的问题和解决办法</h2><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>有可能产生死锁的情况：</p>
<p>系统资源的竞争</p>
<p>通常系统中拥有的不可剥夺资源，其数量不足以满足多个线程运行的需要，使得线程在 运行过程中，会因争夺资源而陷入僵局，如磁带机、打印机等。只有对不可剥夺资源的竞争 才可能产生死锁，对可剥夺资源的竞争是不会引起死锁的。</p>
<p>线程推进顺序非法</p>
<p>线程在运行过程中，请求和释放资源的顺序不当，也同样会导致死锁。例如，并发线程 P1、P2 分别保持了资源 R1、R2，而线程 P1 申请资源 R2，线程 P2 申请资源 R1 时，两者都 会因为所需资源被占用而阻塞。</p>
<p>信号量使用不当也会造成死锁。线程间彼此相互等待对方发来的消息，结果也会使得这 些线程间无法继续向前推进。例如，线程A等待线程B发的消息，线程B又在等待线程A 发的消息，可以看出线程A和B不是因为竞争同一资源，而是在等待对方的资源导致死锁。</p>
<p>死锁是由四个必要条件导致的，所以一般来说，只要破坏这四个必要条件中的一个条件，死锁情况就应该不会发生。</p>
<ol>
<li>如果想要打破互斥条件，我们需要允许进程同时访问某些资源，这种方法受制于实际场景，不太容易实现条件；</li>
<li>打破不可抢占条件，这样需要允许进程强行从占有者那里夺取某些资源，或者简单一点理解，占有资源的进程不能再申请占有其他资源，必须释放手上的资源之后才能发起申请，这个其实也很难找到适用场景；</li>
<li>进程在运行前申请得到所有的资源，否则该进程不能进入准备执行状态。这个方法看似有点用处，但是它的缺点是可能导致资源利用率和进程并发性降低；</li>
<li>避免出现资源申请环路，即对资源事先分类编号，按号分配。这种方式可以有效提高资源的利用率和系统吞吐量，但是增加了系统开销，增大了进程对资源的占用时间。</li>
</ol>
<h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><h3 id="多个线程交替顺序打印"><a href="#多个线程交替顺序打印" class="headerlink" title="多个线程交替顺序打印"></a>多个线程交替顺序打印</h3><p>比如两个线程，从零开始，一个打印偶数一个打印奇数。</p>
<p>方法一，轮流休眠唤醒：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> times = <span class="number">100</span> * <span class="number">10000</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">Thread thread1;</span></pre></td></tr><tr><td class="code"><pre><span class="line">Thread thread2;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">thread1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; times; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> index1 = <span class="number">2</span> * i;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            print(<span class="string">"偶数打印："</span> + index1);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (i == times - <span class="number">1</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">break</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">this</span>.notify();</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">this</span>.wait();</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                e.printStackTrace();</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">thread2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; times; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> index2 = <span class="number">2</span> * i + <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            print(<span class="string">"奇数打印："</span> + index2);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (i == times - <span class="number">1</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">break</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">this</span>.notify();</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">this</span>.wait(<span class="number">100</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                e.printStackTrace();</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">thread1.start();</span></pre></td></tr><tr><td class="code"><pre><span class="line">thread2.start();</span></pre></td></tr><tr><td class="code"><pre><span class="line">thread2.join();</span></pre></td></tr></table></figure>

<p>多次测试平均耗时大概 7.7 秒左右。</p>
<p>方法二，利用<code>volitale</code>关键字实现 CAS：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> times = <span class="number">100</span> * <span class="number">10000</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ExecutorService service = Executors.newFixedThreadPool(<span class="number">2</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    service.execute(() -&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">while</span> (i &lt; times) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (flag) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                print(<span class="string">"偶数打印："</span> + <span class="number">2</span> * i++);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                flag = <span class="keyword">false</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    service.execute(() -&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">while</span> (i &lt; times) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (!flag) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                print(<span class="string">"奇数打印："</span> + (<span class="number">1</span> + <span class="number">2</span> * i++));</span></pre></td></tr><tr><td class="code"><pre><span class="line">                flag = <span class="keyword">true</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    service.shutdown();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        service.awaitTermination(Integer.MAX_VALUE, TimeUnit.HOURS);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        e.printStackTrace();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>多次测试平均时间消耗大概在 3.6 秒，可以看出不用锁会快很多。</p>
<p>方法三，类似方法一，用<code>Lock</code>和<code>Condition</code>轮流休眠和唤醒，效率略高：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> times = <span class="number">100</span> * <span class="number">10000</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">Lock lock = <span class="keyword">new</span> ReentrantLock();</span></pre></td></tr><tr><td class="code"><pre><span class="line">Condition condition = lock.newCondition();</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">Thread thread1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">while</span> (i &lt; times) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        lock.lock();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        print(<span class="string">"偶数打印:"</span> + <span class="number">2</span> * i++);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            condition.signal();</span></pre></td></tr><tr><td class="code"><pre><span class="line">            condition.await();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            e.printStackTrace();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        lock.unlock();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">Thread thread2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">while</span> (i &lt; times) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        lock.lock();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        print(<span class="string">"奇数打印:"</span> + (<span class="number">1</span> + <span class="number">2</span> * i++));</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (i == times)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            condition.signal();</span></pre></td></tr><tr><td class="code"><pre><span class="line">            condition.await();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            e.printStackTrace();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        lock.unlock();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">thread1.start();</span></pre></td></tr><tr><td class="code"><pre><span class="line">thread2.start();</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    thread2.join();</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    e.printStackTrace();</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>多次测试执行时间在 6.4 毫秒左右。</p>
<h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><p>Java通过Executors提供四种线程池，分别为：</p>
<ul>
<li><code>newCachedThreadPool</code>创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。</li>
<li><code>newFixedThreadPool</code> 创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。</li>
<li><code>newScheduledThreadPool</code>创建一个定长线程池，支持定时及周期性任务执行。</li>
<li><code>newSingleThreadExecutor</code> 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。</li>
</ul>
<p>在阿里巴巴Java开发手册中也明确指出，是『不允许』使用<code>Executors</code>创建线程池。</p>
<p><img src="http://nas.beritra.com:18081/uploads/medium/e9544748c3bd8f51bca9eaa2de977fa1.jpg" alt=""></p>
<p>避免使用Executors创建线程池，主要是避免使用其中的默认实现，那么我们可以自己直接调用<code>ThreadPoolExecutor</code>的构造函数来自己创建线程池。在创建的同时，给<code>BlockQueue</code>指定容量就可以了。</p>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><h3 id="java-util-concurrent包"><a href="#java-util-concurrent包" class="headerlink" title="java.util.concurrent包"></a>java.util.concurrent包</h3><ul>
<li>数据结构：ConcurrentHashMap, BlockingQueue 系列</li>
<li>线程池：Executor, ExecutorService, ThreadPoolExecutor, ScheduledThreadPoolExecutor, Executors（工厂类）, Callable, Runnable, Future</li>
<li>锁：ReentrantLock, ReentrantReadWriteLock, Condition</li>
<li>线程同步：CountDownLatch, CyclicBarrier</li>
</ul>
<p>本来想一篇都写写，发现内容实在太多了，这部分后续再单开博客详细论述吧…这篇够长了。</p>
<p>参考链接</p>
<p><a href="https://juejin.im/post/5ab116875188255561411b8a" target="_blank" rel="noopener">Java多线程学习（一）Java多线程入门</a></p>
<p><a href="https://www.jianshu.com/p/9baa7baf233d" target="_blank" rel="noopener">java-线程中start和run的区别</a></p>
<p><a href="https://blog.csdn.net/Evankaka/article/details/44153709" target="_blank" rel="noopener">Java多线程学习（吐血超详细总结）</a></p>
<p><a href="https://www.cnblogs.com/dolphin0520/p/3949310.html" target="_blank" rel="noopener">Java并发编程：Callable、Future和FutureTask</a></p>
<p><a href="https://juejin.im/post/594a24defe88c2006aa01f1c" target="_blank" rel="noopener">Java 之 synchronized 详解</a></p>
<p><a href="https://www.cnblogs.com/dolphin0520/p/3923167.html" target="_blank" rel="noopener">Java并发编程：Lock</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/52563959" target="_blank" rel="noopener">java中几种锁，分别是什么？</a></p>
<p><a href="https://www.cnblogs.com/onlywujun/p/3565082.html" target="_blank" rel="noopener">Thread的中断机制(interrupt)</a></p>
<p><a href="https://juejin.im/post/5b42c2546fb9a04f8751eabc" target="_blank" rel="noopener">Java并发——关键字synchronized解析</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL中的锁</title>
    <url>/2019/12/30/MySQL%E4%B8%AD%E7%9A%84%E9%94%81/</url>
    <content><![CDATA[<p>本文主要摘抄自 MySQL 的官方文档和《MySQL技术内幕（InnoDB存储引擎）第二版》，少部分来自网络博客和自己补充。注意，该书内容是基于MySQL 5.6 及更早的版本，具体的实现方式有可能发生了改变，有些内容我做了注释和补充，但是不保证百分百的完整和正确。</p>
<a id="more"></a>

<p>开发多用户、数据库驱动的应用时，最大的一个难点是：一方面要最大程度地利用数据库的并发访问，另一方面还要确保每个用户能以一致的方式读取和修改数据。为此就有了锁（locking）的机制，同时这也是数据库系统区别于文件系统的一个关键特性。</p>
<h2 id="什么是锁"><a href="#什么是锁" class="headerlink" title="什么是锁"></a>什么是锁</h2><p>锁机制用于管理对共享资源的并发访问。InnoDB 存储引擎会在行级别上对表数据上锁，这固然不错。不过InnoDB 存储引擎也会在数据库内部其他多个地方使用锁，从而允许对多种不同资源提供并发访问。例如，操作缓冲池 LRU 列表，删除、添加、移动 LRU 列表中的元素，为了保证一致性，必须有锁的介入。</p>
<h2 id="lock-与-latch"><a href="#lock-与-latch" class="headerlink" title="lock 与 latch"></a>lock 与 latch</h2><p>在数据库中，lock 与 latch 都可以被称为“锁”，但是两者有着截然不同的含义，本文主要关注的是lock。</p>
<p>latch 一般称为闩锁（轻量级的锁），因为其要求锁定的时间必须非常短。若持续的时间长，则应用的性能会非常差。在 InnoDB 存储引擎中，latch 又可以分为 mutex（互斥锁）和 rwlock（读写锁）。其目的是用来保证并发线程操作临界资源的正确性，并且通常没有死锁检测的机制。</p>
<p>lock 的对象是事务，用来锁定的是数据库中的对象，如表、页、行。并且一般 lock 的对象仅在事务 commit 或 rollback 后进行释放（不同事务隔离级别释放的时间可能不同）。此外，lock，正如在大多数数据库中一样，是有死锁机制的。下图显示了 lock 与 latch 的不同：</p>
<p><img src="http://nas.beritra.com:18081/uploads/big/bd688943194e21785253085c31ab3068.png" alt=""></p>
<p>对于 InnoDB 存储引擎中的 latch，可以通过命令<code>SHOW ENGINE INNODB MUTEX</code>来进行查看。具体的数据结果说明如下：</p>
<p><img src="http://nas.beritra.com:18081/uploads/big/60c089a6fc20004f8dfe2448bf718b79.png" alt=""></p>
<p>上述信息是比较底层的，一般仅供开发人员参好。但是用户还是可以通过这些参数调优。</p>
<p>相对于 latch 的查看，lock 的信息就显得直观多了。用户可以通过命令<code>SHOW ENGING INNODB STATUS</code>及<code>infomation_schema</code>架构下的表<code>INNODB_TRX</code>、<code>INNODB_LOCKS</code>、<code>INNODB_LOCK_WAITS</code>来观察锁的信息。</p>
<h2 id="InnoDB-存储引擎中的锁"><a href="#InnoDB-存储引擎中的锁" class="headerlink" title="InnoDB 存储引擎中的锁"></a>InnoDB 存储引擎中的锁</h2><h3 id="锁的类型"><a href="#锁的类型" class="headerlink" title="锁的类型"></a>锁的类型</h3><p>InnoDB 存储引擎实现了如下两种标准的行级锁：</p>
<ul>
<li>共享锁（Shared Lock，S Lock），允许事务读一行数据。</li>
<li>排它锁（Exclusive Lock，X Lock），允许事务删除或更新一行数据。</li>
</ul>
<p>如果一个事务 T1 已经获得了行 r 的共享锁，那么另外的事务 T2 可以立即获得行 r 的共享锁，因为读取并没有改变行 r 的数据，称这种情况为锁兼容（Lock Compatible）。但若有其他事务 T3 想获得行 r 的排它锁，则其必须等待事务 T1、T2 释放行 r 上的共享锁——这种情况称为锁不兼容。下表显示了共享锁和排他锁的兼容性。</p>
<p><img src="http://nas.beritra.com:18081/uploads/big/2dee43dca39b6166f58fa2502037c082.png" alt=""></p>
<p>可以看出，X 锁与任何所都不兼容，而 S 锁仅和 S 锁兼容。需要特别注意的是，S 和 X 锁都是行锁，兼容是指对同一记录（row）锁的兼容性情况。</p>
<p>此外，InnoDB 存储引擎支持多粒度（granular）锁定，这种锁定允许事务在行级上的锁和表级上的锁同时存在。为了支持在不同粒度上进行加锁操作，InnoDB 存储引擎支持一种额外的锁方式，称之为意向锁（Intention Lock）。意向锁是将锁定的对象分为多个层次，意向锁意味着事务希望在更细粒度（fine granularity）上进行加锁。</p>
<p>怼细粒度的对象上锁，那么首先需要对粗粒度的对象上锁。如图所示，如果要对页上的对象 r 上 X 锁，那么分别需要对数据库A、表、页上 IX 锁，最后对记录 r 上 X 锁。若其中任何一部分导致等待，那么操作都需要等粗粒度锁的完成。 </p>
<p><img src="http://nas.beritra.com:18081/uploads/big/d4f39c4487a879b52e864613bfae6a13.png" alt=""></p>
<p>InnoDB 引擎支持意向锁设计的比较简练，其意向锁即为表级别的锁。设计目的主要是为了在一个事务中揭示下一行将被请求的锁类型。其支持两种意向锁：</p>
<ol>
<li>意向共享锁（IS Lock），事务想要获得一张表中某几行的共享锁。</li>
<li>意向排他锁（IX Lock），事务想要获得一张表中某几行的排它锁。</li>
</ol>
<p>由于 InnoDB 存储引擎支持的是行级别的锁，因此意向锁不会阻塞除全表扫描以外的任何请求。表级意向锁和行级锁的兼容性如图所示：</p>
<p><img src="http://nas.beritra.com:18081/uploads/big/459473d464483abf7120afe478c03ade.png" alt=""></p>
<p>用户可以通过命令<code>SHOW ENGINE INNODB STATUS</code>命令查看当前锁请求的信息</p>
<p>从 InnoDB 1.0 开始，在<code>INFORMATION_SCHEMA</code>架构下添加了表<code>INNODB_TRX</code>、<code>INNODB_LOCKS</code>、<code>INNODB_LOCKS_WAITS</code>。通过这三张表，用户可以更简单地监控当前事务并分析可能存在的锁问题。<code>INNODB</code>的定义如下图所示，一共8个字段（我在MySQL 8.0 版本进行测试，发现已经扩充到了24个字段）：</p>
<p><img src="http://nas.beritra.com:18081/uploads/big/4cd48d8a91196d45f528b0ef2ee6c1f9.png" alt=""></p>
<p>这个表可以显示当前运行的 InnoDB 事务，并不能判断锁的一些情况。如果需要查看锁，则还需要访问表<code>INNODB_LOCKS</code>，该表的字段如下所示：</p>
<p><img src="http://nas.beritra.com:18081/uploads/big/582c68591c786071eccc2fcf1878b367.png" alt=""></p>
<p>再通过表<code>INNODB_LOCKS</code>查看了每张表上锁的情况后，用户就可以判断由此引发的等待状况了。当事务较小时，用户就可以人为地、直观地进行判断了。但是当事务量非常大，其中锁和等待也时常发生，这个时候就不那么容易判断。但是通过表<code>INNODB_LOCK_WAIT</code>，可以很直观地反应当前事务的等待。表<code>INNODB_LOCK_WAITS</code>由四个字段组成，如下图所示。</p>
<p><img src="http://nas.beritra.com:18081/uploads/big/9941f4666dee54782b182f5eacdcf3a8.png" alt=""></p>
<blockquote>
<p>注意：在 MySQL 8.0 版本中，INFORMATION_SCHEMA 下的 INNODB_LOCKS 和 INNODB_LOCK_WAITS 表已被删除。 用Performance Schema data_locks和 data_lock_waits 表替代。</p>
</blockquote>
<h3 id="一致性非锁定读"><a href="#一致性非锁定读" class="headerlink" title="一致性非锁定读"></a>一致性非锁定读</h3><p>一致性的非锁定读（consistent nonlocking read）是指 InnoDB 存储引擎通过行多版本控制（multi versioning）的方式来读取当前执行时间数据库中行的数据。如果读取的行正在执行 DELETE 或者 UPDATE 操作，这时读取操作不会因此去等待行上锁的释放。相反的，InnoDB 存储引擎会去读取行的一个快照存储。</p>
<p>之所以称其为非锁定读，因为不需要等待访问的行上 X 锁的释放。快照数据是指该行的之前版本的数据，该实现是通过 undo 段来完成，而 undo 用来在事务中回滚数据，因此快照数据本身是没有额外的开销的。此外，读取快照数据是不需要上锁的吗，因为没有事务需要对历史的数据进行修改操作。</p>
<p>可以看出，非锁定读机制极大地提提高了数据库的并发性。在 InnoDB 存储引擎的默认设置下，这是默认的读取方式，即读取不会占用和等待表上的锁。但是在不同事务隔离级别下，读取的方式不同，并不是在每个事务隔离级别下都是采用的非锁定的一致性读。此外，即使都是采用的非锁定的一致性读，但是对于快照数据的定义也各不相同。</p>
<p>在事务隔离级别<code>READ COMMITTED</code>和<code>REPEATABLE READ</code>（InnoDB存储引擎的默认事务隔离级别）下，InnoDB 存储引擎使用非锁定的一致性读。然而，对于快照数据的定义却不相同。在<code>READ COMMITTED</code>事务隔离级别下，对于快照数据，非一致性读总是读取被锁定行的最新一份快照数据。而在<code>REPEATABLE READ</code>事务隔离级别下，对于快照数据，非一致性读总是读取事务开始时的行数据版本。</p>
<p>举个栗子，首先在当前 MySQL 数据库的连接回话 A 中执行以下 SQL 语句：</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; begin;</span></pre></td></tr><tr><td class="code"><pre><span class="line">Query OK, 0 rows affected (0.01 sec)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">mysql&gt; select * from parent where id &#x3D;1;</span></pre></td></tr><tr><td class="code"><pre><span class="line">+------+</span></pre></td></tr><tr><td class="code"><pre><span class="line">|   id    |</span></pre></td></tr><tr><td class="code"><pre><span class="line">+------+</span></pre></td></tr><tr><td class="code"><pre><span class="line">|    1     |</span></pre></td></tr><tr><td class="code"><pre><span class="line">+------+</span></pre></td></tr><tr><td class="code"><pre><span class="line">1 row in set (0.00 sec)</span></pre></td></tr></table></figure>

<p>在会话 A 显式的开启了一个事务，并读取了表 parent 中 id 为 1 的数据，但是事务并没有结束。与此同时，用户再开启另一个回话 B，这样可以模拟并发的情况，然后对 B 做如下的操作：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; begin;</span></pre></td></tr><tr><td class="code"><pre><span class="line">Query OK, 0 rows affected (0.00 sec)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">mysql&gt; update parent set id&#x3D;3 where id&#x3D;1;</span></pre></td></tr><tr><td class="code"><pre><span class="line">Query OK, 1 row affected (0.00 sec)</span></pre></td></tr><tr><td class="code"><pre><span class="line">Rows matched: 1  Changed: 1  Warnings: 0</span></pre></td></tr></table></figure>

<p>在会话 B 中将事务表 parent 中 id 为 1 的记录修改为 id=3 ，但是事务同样没有提交。这样 id=1 的行实际上加了一个 X 锁。这时如果在会话 A 中再次读取 id 为 1 的记录，根据 InnoDB 引擎的特性，即在<code>READ COMMITTED</code>和<code>REPEATETABLE READ</code>的事务隔离级别下会使用非锁定的一致性读。回到之前的会话 A ，接着上次未提交的事务，执行 SQL 语句 <code>select * from parent where id=1</code>的操作，这时不管使用<code>READ COMMITTED</code>还是<code>REPEATETABLE READ</code>的事务隔离级别，显示的数据应该都是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from parent where id &#x3D;1;</span></pre></td></tr><tr><td class="code"><pre><span class="line">+------+</span></pre></td></tr><tr><td class="code"><pre><span class="line">|   id    |</span></pre></td></tr><tr><td class="code"><pre><span class="line">+------+</span></pre></td></tr><tr><td class="code"><pre><span class="line">|    1     |</span></pre></td></tr><tr><td class="code"><pre><span class="line">+------+</span></pre></td></tr><tr><td class="code"><pre><span class="line">1 row in set (0.00 sec)</span></pre></td></tr></table></figure>

<p>由于当前 id=1 的数据被修改了1次，因此只有一个行版本的记录。接着，在会话 B 中提交上次的事务：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; commit;</span></pre></td></tr><tr><td class="code"><pre><span class="line">Query OK, 0 rows affected (0.00 sec)</span></pre></td></tr></table></figure>

<p>在会话 B 提交事务之后，在会话 A 中再次运行<code>select * from parent where id=1</code>语句，在<code>READ COMMITTED</code>和<code>REPEATETABLE READ</code>的事务隔离级别下得到的结果就不一样了。对于<code>READ COMMITTED</code>的事务隔离级别，它总是能够读取行的最新版本，如果行被锁定了，则读取最新的一个快照（fresh snapshot）。在上述例子中，因为会话 B 已经提交了事务，所以<code>READ COMMITTED</code>事务隔离级别下会得到如下结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; select @@transaction_isolation\G;</span></pre></td></tr><tr><td class="code"><pre><span class="line">*************************** 1. row ***************************</span></pre></td></tr><tr><td class="code"><pre><span class="line">@@transaction_isolation: REPEATABLE-READ</span></pre></td></tr><tr><td class="code"><pre><span class="line">1 row in set (0.00 sec)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">mysql&gt; select * from parent where id &#x3D;1;</span></pre></td></tr><tr><td class="code"><pre><span class="line">Empty set (0.00 sec)</span></pre></td></tr></table></figure>

<p>而对于<code>REPEATABLE READ</code>的事务隔离级别，总是读取事务开始时的行数据。因此对于<code>REPEATABLE REPEAD</code>事务隔离级别，得到的结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; select @@transaction_isolation\G;</span></pre></td></tr><tr><td class="code"><pre><span class="line">*************************** 1. row ***************************</span></pre></td></tr><tr><td class="code"><pre><span class="line">@@transaction_isolation: REPEATABLE-READ</span></pre></td></tr><tr><td class="code"><pre><span class="line">1 row in set (0.00 sec)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">mysql&gt; select * from parent where id &#x3D;1;</span></pre></td></tr><tr><td class="code"><pre><span class="line">+------+</span></pre></td></tr><tr><td class="code"><pre><span class="line">|   id    |</span></pre></td></tr><tr><td class="code"><pre><span class="line">+------+</span></pre></td></tr><tr><td class="code"><pre><span class="line">|    1     |</span></pre></td></tr><tr><td class="code"><pre><span class="line">+------+</span></pre></td></tr><tr><td class="code"><pre><span class="line">1 row in set (0.00 sec)</span></pre></td></tr></table></figure>

<blockquote>
<p>注意，MySQL 8.0 之前查询当前事务隔离级别的语句是<code>select @@tx_isolation</code>，之后是上面用的<code>select @@transaction_isolation</code></p>
</blockquote>
<p>下面将从时间的角度上展现上述演示的示例过程，如下表所示。需要特别注意的是，对于<code>READ COMMITTED</code>的事务隔离级别而言，从数据库理论的角度来看，其违反了事务 ACID 中的 I 的特性，即隔离性。</p>
<p><img src="http://nas.beritra.com:18081/uploads/big/d0ad4367ae0308988d67fafe16ab57d8.png" alt=""></p>
<h3 id="一致性锁定锁"><a href="#一致性锁定锁" class="headerlink" title="一致性锁定锁"></a>一致性锁定锁</h3><p>在前一节讲到，默认配置下，事务隔离级别是<code>REPEATABLE READ</code>模式，InnoDB 存储引擎的<code>SELECT</code>操作使用一致性非锁定锁。但是在某些情况下，用户需要显式得堆数据库读取操作进行加锁以保证数据逻辑的一致性。InnoDB 存储引擎对于<code>SELECT</code>语句支持两种一致性的锁定读（locking read）操作：</p>
<ul>
<li>SELECT … FOR UPDATE</li>
<li>SELECT … LOCK IN SHARE MODE</li>
</ul>
<p><code>SELECT ... FOR UPDATE</code>堆读取的行记录加一个 X 锁，其他事务不能对已锁定的行加上任何锁。<code>SELECT ... LOCK IN SHARE MODE</code>对读取的行加一个 S 锁，其他事务可以向被锁定的行加 S 锁，但是如果加 X 锁，就会被阻塞。</p>
<p>以上这两个语句必须在同一个事务中，当事务提交了，锁也就释放了。因此在使用两个<code>SELECT</code> 锁的时候，务必记得带上<code>BEGIN</code>，<code>START TRANSACTION</code>或者<code>SET AUTOCOMMIT=0</code>。</p>
<h3 id="自增长与锁"><a href="#自增长与锁" class="headerlink" title="自增长与锁"></a>自增长与锁</h3><p>自增长是非常常用的一个属性，在 InnoDB 引擎的内存结构中，对每个含有自增长值的表都有一个自增长计数器（auto-increment counter）。当对含有自增长的计数器的表进行插入操作时，这个计数器会被初始化，执行如下的语句来得到计数器的值：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT MAX(auto_inc_col) FROM t FOR UPDATE;</span></pre></td></tr></table></figure>

<p>插入操作会依据这个自增的计数器的值加 1 赋予自增长列。这个实现方式称作<code>AUTO-INC Locking</code>。这个锁其实是采用一种特殊的表锁机制，为了提高插入的性能，锁不是在一个事务完成后才释放，而是在完成对自增长值插入 SQL 语句后立即释放。</p>
<p>虽然<code>AUTO-INC Locking</code>从一定程度上提高了并发插入的效率，但是还存在一定性能上的问题。首先对于自增长值得咧并发插入性能较差，事务必须等待前一个插入完成。其次，对于<code>INSERT ... SELECT</code>的大数据量插入会影响插入性能。因为另一个事务中的插入会被阻塞。</p>
<p>从 MySQL 5.1.22 开始，InnoDB 存储引擎中提供了一种轻量级互斥锁的自增长实现机制，这种机制大大提高了自增值的插入性能。从该版本开始，InnoDB 存储引擎提供了一个参数<code>innodb_autoinc_lock_mode</code>来控制自增长的模式，该参数的默认值为 1 。我们对自增长的插入进行分类的话，如图所示。</p>
<p><img src="http://nas.beritra.com:18081/uploads/big/1aba09745c0c14391626b500f0bc1870.png" alt=""></p>
<p>接着来分析参数<code>innodb_autoinc_lock_mode</code>以及各个设置下堆自增的印象，总共有三个有效值可供供设定，即0、1、2，具体说明如下表所示：</p>
<p><img src="http://nas.beritra.com:18081/uploads/big/301223cb3933201dd3f24ccfba86ebdb.png" alt=""></p>
<p>在 InnoDB 存储引擎中，自增长的列必须是索引，同时必须是索引的第一个列。如果不是第一个列，则 MySQL 数据库会抛出异常。</p>
<h3 id="外键和锁"><a href="#外键和锁" class="headerlink" title="外键和锁"></a>外键和锁</h3><p>在 InnoDB 存储引擎中，对于一个外键列，如果没有显式的对这个列加索引，InnoDB 引擎会自动加一个索引，因为这样可以避免表锁。对于外键的插入或更新，首先需要查询父表中的记录，即 SELECT 父表。单是对于父表的 SELECT 操作，不是使用一致性非锁定读的方式，因为这样会发生数据不一致的问题。因此这时使用的是<code>SELECT ... LOCK IN SHARE MODE</code>方式，即主动对父表加一个 S 锁。如果这时候父表已经加上了一个 X 锁，子表上的操作会被阻塞。</p>
<h2 id="锁的算法"><a href="#锁的算法" class="headerlink" title="锁的算法"></a>锁的算法</h2><h3 id="行锁的-3-种算法"><a href="#行锁的-3-种算法" class="headerlink" title="行锁的 3 种算法"></a>行锁的 3 种算法</h3><p>InnoDB 存储引擎有三种行锁的算法，分别是：</p>
<ul>
<li>Record Lock：单个行记录上的锁</li>
<li>Gap Lock：间隙锁，锁定一个范围，但不包含记录本身</li>
<li>Next-Key Lock：Gap Lock+Record Lock，锁定一个范围，并且锁定记录本身</li>
</ul>
<h4 id="Record-Lock"><a href="#Record-Lock" class="headerlink" title="Record Lock"></a>Record Lock</h4><p>Record Lock 总是会锁住索引记录，如果 InnoDB 存储引擎表在建立的时候没有设置任何一个索引，那么这是 InnoDB 存储引擎会使用隐式的主键来进行锁定。比如， <code>SELECT c1 FROM t WHERE c1 = 10 FOR UPDATE;</code> 会阻止其他任何事务操作<code>t.c1</code> = <code>10</code>的行，包括更新、插入和删除操作。</p>
<h4 id="Gap-Lock"><a href="#Gap-Lock" class="headerlink" title="Gap Lock"></a>Gap Lock</h4><p>Gap lock 会锁住两个索引中间的一段间隙（范围），或者索引之前或之后的一段范围。比如， <code>SELECT c1 FROM t WHERE c1 BETWEEN 10 and 20 FOR UPDATE;</code> 会阻止其他事务插入<code>15</code> 到到 <code>t.c1</code>的字段中，无论这个字段中当前有没有记录。因为从 10 到 20 这一段索引已经被锁住了。</p>
<p>这个间隙的范围可以跨越单个索引值，多个索引值，甚至为空。</p>
<p>间隙锁是性能和并发性之间权衡，只在某些事务隔离级别中使用。</p>
<p>对于使用唯一索引来锁定唯一行来锁定行的语句，不需要间隙锁定。（这不包括搜索条件仅包含多列唯一索引的某些列的情况；在这种情况下，会发生间隙锁定。）例如，如果 id 列具有唯一索引，则以下语句仅使用 id 值为 100 的行的索引记录锁，其他会话是否在前面的间隙中插入行都没有关系：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">child</span> <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">100</span>;</span></pre></td></tr></table></figure>

<p>如果 id 未建立索引或索引不唯一，则该语句会锁定前面的间隙。</p>
<p>在这里还值得注意的是，可以通过不同的事务将冲突的锁保持在间隙上。例如，事务 A 可以在间隙上保留一个共享的间隙锁（间隙 S 锁），而事务 B 可以在同一间隙上保留排他的间隙锁（间隙 X 锁）。允许冲突的间隙锁的原因是，如果从索引中清除记录，则必须合并由不同事务保留在记录上的间隙锁。</p>
<p>InnoDB 中的间隙锁是“完全禁止的”，这意味着它们的唯一目的是防止其他事务插入间隙。间隙锁可以共存。一个事务进行的间隙锁定不会阻止另一事务对相同的间隙进行间隙锁定。共享和专用间隙锁之间没有区别。它们彼此不冲突，并且执行相同的功能。</p>
<p>间隙锁定可以显式禁用。如果将事务隔离级别更改为 READ COMMITTED，则会发生这种情况。在这种情况下，将禁用间隙锁定来进行搜索和索引扫描，并且间隙锁定仅用于外键约束检查和重复键检查。</p>
<p>使用 READ COMMITTED 隔离级别还有其他影响。 MySQL 评估 WHERE 条件后，将释放不匹配行的记录锁。对于 UPDATE 语句，InnoDB 进行“半一致”读取，以便将最新的提交版本返回给 MySQL，以便 MySQL 可以确定该行是否与 UPDATE 的 WHERE 条件匹配。</p>
<h4 id="Next-Key-Lock"><a href="#Next-Key-Lock" class="headerlink" title="Next-Key Lock"></a>Next-Key Lock</h4><p>Next-Key Lock 是结合了 Gap Lock 和 Record Lock 的一种锁定算法，在 Next-Key Lock 算法下，InnoDB 对于行的查询都是采用这种锁定算法。例如一个索引有10，11，13和20这四个值，那么该索引可能被 Next-Key Lock 的区间为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(-∞，10]</span></pre></td></tr><tr><td class="code"><pre><span class="line">(10，11]</span></pre></td></tr><tr><td class="code"><pre><span class="line">(11，13]</span></pre></td></tr><tr><td class="code"><pre><span class="line">(13，20]</span></pre></td></tr><tr><td class="code"><pre><span class="line">(20，+∞)</span></pre></td></tr></table></figure>

<p>采用 Next-Key Lock 的锁定技术称为 Next-Key Locking。其设计的目的是为了解决 Phantom Problem，这将在下一个小节介绍。利用这种技术，锁定的不是单个值，而是一个范围，是谓词锁（predict lock）的一种改进。除了 Next-Key Locking，还有 Previous-Key Locking 技术。</p>
<p>同样上述索引 10，11，13 和 20，如果采用 Previous-Key Locking 技术，可锁定的区间会变成：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(-∞，10)</span></pre></td></tr><tr><td class="code"><pre><span class="line">[10，11)</span></pre></td></tr><tr><td class="code"><pre><span class="line">[11，13)</span></pre></td></tr><tr><td class="code"><pre><span class="line">[13，20)</span></pre></td></tr><tr><td class="code"><pre><span class="line">[20，+∞)</span></pre></td></tr></table></figure>

<p>若事务 T1 已经通过 Next-Key Locking 锁定了如下范围：</p>
<p><code>(10,11]、(11,13]</code></p>
<p>当插入新的记录 12 的时候，锁定的范围会变成：</p>
<p><code>(10,11]、(11,12]、(12,13]</code></p>
<p>当查询的索引含有唯一属性的时候，InnoDB 存储引擎会对 Next-Key Lock 进行优化，将其降级为 Record Lock，即仅锁住索引本身，而不是范围，从而提高应用的并发性。</p>
<p>使用下列代码创建测试表 t ：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create table t(a int primary key);</span></pre></td></tr><tr><td class="code"><pre><span class="line">insert into t select 1;</span></pre></td></tr><tr><td class="code"><pre><span class="line">insert into t select 2;</span></pre></td></tr><tr><td class="code"><pre><span class="line">insert into t select 5;</span></pre></td></tr></table></figure>

<p>然后执行下列语句：</p>
<p><img src="http://nas.beritra.com:18081/uploads/big/526914fec4f38a48344b723dfe357d60.png" alt=""></p>
<p>表 t 一共只有1、2、5 三个值。在上面的例子中，会话 A 首先对 a=5 进行 X 素哟定。而由于 a 是主键且唯一，因此锁定的仅仅是 5 这个值，而不是（2,5）这个范围，这样在会话 B 中插入值 4 而不会阻塞，可以立即插入并返回。</p>
<p>若是辅助索引，情况会完全不同。根据下列代码创建测试表 z：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; create table z(a int,b int, primary key(a),key(b));</span></pre></td></tr><tr><td class="code"><pre><span class="line">mysql&gt; insert into z select 1,1;</span></pre></td></tr><tr><td class="code"><pre><span class="line">mysql&gt; insert into z select 3,1;</span></pre></td></tr><tr><td class="code"><pre><span class="line">mysql&gt; insert into z select 5,3;</span></pre></td></tr><tr><td class="code"><pre><span class="line">mysql&gt; insert into z select 7,6;</span></pre></td></tr><tr><td class="code"><pre><span class="line">mysql&gt; insert into z select 10,8;</span></pre></td></tr></table></figure>

<p>表 z 的列 b 是辅助索引，若在会话 A 中开启事务，执行下面的 SQL 语句：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select  * from z where b&#x3D;3 for update;</span></pre></td></tr></table></figure>

<p>这时 SQL 语句将通过索引列 b 进行查询，因此使用传统的 Next-Key Locking技术进行加锁，并且由于有两个索引，需要对其分别加锁。对于聚集索引，仅对列 a 等于 5 的索引加上 Record Lock。而对于辅助索引，其加上的是 Next-Key Lock，锁定范围是（1,3），需要特别注意的，InnoDB 存储引擎还会对辅助索引下一个键值加上 gap lock，即还有一个辅助索引范围为（3,6）的锁，因此，若在新回话 B 中运行下面的 SQL 语句，都会被阻塞。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from z where a&#x3D;5 lock in share mode;</span></pre></td></tr><tr><td class="code"><pre><span class="line">insert into z select 4,2;</span></pre></td></tr><tr><td class="code"><pre><span class="line">insert into z select 6,5;</span></pre></td></tr></table></figure>

<p>原因如下：</p>
<ul>
<li>第一个 SQL 语句不能执行，因为在会话 A 中执行的 SQL 语句已经对聚集索引中列 a=5 的值加上 X 锁，因此执行会被阻塞。</li>
<li>第二个 SQL 语句，主键插入 4 ，没有问题，但是插入的辅助索引 2 在锁定的范围（1,3）中，所以同样会阻塞</li>
<li>第三个 SQL 语句，插入的主键 6 没有被锁定，5 也不在范围（1,3）之间，但是插入的值 5 在另一个锁定的范围（3,6）中，所以同样需要等待。</li>
</ul>
<p>上面的例子可以看出，Gap Lock 的作用是为了阻止多个事务将记录插入到同一个范围内，而这会导致 Phantom Problem 问题的产生。例如上面的例子中，会话 A 用户锁定了 b=3 的记录，如果此时没有锁定（3,6），那么用户可以插入 b 列为 3 的记录，这会导致会话 A 中的用户再次执行查询时返回不同的记录，这就导致了 Phantom Problem 问题的产生。</p>
<p>用户可以通过以下两种方式来显式的关闭 Gap Lock：</p>
<ul>
<li>将事务的隔离级别设置为<code>READ COMMITTED</code></li>
<li>将参数<code>innodb_locks_unsafe_for_binlog</code>设置为 1</li>
</ul>
<p>在上述配置下，除了外键约束和唯一性检查仍然需要 Gap Lock，其余情况仅使用 Record Lock 进行锁定。但需要牢记的是，上述设置破坏了事务的隔离性，并且对于 replication，可能会导致主从数据的不一致。因此从性能上看，<code>READ COMMITTED</code>也不会优于默认的事务隔离级别<code>READ REPEATABLE</code>。</p>
<p>需要再次提醒的是，对于唯一键值的锁定，Next-Key Lock 降级为 Record Lock 仅存在于查询所有的唯一索引列。若唯一索引由多个列组成，而查询仅是查找多个唯一索引列中的其中一个，那么查询其实是 range 类型查询，而不是 point 类型查询，故 InnoDB 存储引擎依然使用 Next-Key Lock 进行锁定。</p>
<h3 id="解决-Phantom-Problem"><a href="#解决-Phantom-Problem" class="headerlink" title="解决 Phantom Problem"></a>解决 Phantom Problem</h3><p>在默认的事务隔离级别下，即<code>REPEATABLE READ</code>下，InnoDB 存储引擎采用 Next-Key Locking 机制来避免 Phantom Problem（幻想问题）。</p>
<p>Phantom Problem 是指在同一事务下，连续执行两次同样的 SQL 可能导致不同的结果，第二次的 SQL 语句可能会返回之前不存在的行。</p>
<p>还是以上一节创建的表 t 为例，表 t 由 1、2、5 三个值组成，如果事务 T1 执行如下 SQL 语句：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from t where a&gt;2 for update;</span></pre></td></tr></table></figure>

<p>注意这时候 T1 并没有进行提交操作，上述应该返回 5 这个结果。如果与此同时，另一个事务 T2 插入了 4 这个值，并且数据库允许该操作，那么事务 T1 再次执行查询 SQL 语句的时候，就会得到结果 4 和 5 。这与第一次查询的结果不同，违反了事务的隔离性，即当前事务可以看到其他事务的结果。</p>
<p>InnoDB 引擎采用了 Next-Key Locking 算法避免出现上面的情况。对于上面的 SQL，实际上锁住的不只是 5 这个单个值，而是对（2,+∞）范围都加了 X 锁，因此对于这个范围内的插入都是不允许的，从而避免 Phantom Problem。</p>
<p>InnoDB 引擎默认的事务隔离级别是<code>REPEATABLE READ</code>，在该隔离级别下，采用 Next-Key Locking 来加锁。而在事务隔离级别<code>READ COMMITTED</code>级别下，仅采用 record Lock，因此在上述示例中，会话 A 需要将事务的隔离级别设置为<code>READ COMMITTED</code>。</p>
<p>此外，用户可以通过 InnoDB 存储引擎的 Next-Key Locking 机制在应用层面实现唯一性检查：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from table where col&#x3D;xxx lock in share mode;</span></pre></td></tr></table></figure>

<p>如果用户通过索引查询一个值，并对该行加上一个 S Lock，那么即使查询的值不存在，锁定的也是一个范围，因此若此行没有任何返回，那么新插入的值一定是唯一的。</p>
<p>这里如果在第一步<code>select ... lock in share mode</code>操作的回收，有多个事务并发操作，这种唯一性检查机制是否存在问题呐？答案是不会，因为这时候会导致死锁，只有一个事务操作成功，其他会抛出死锁的错误提示。</p>
<h2 id="锁问题"><a href="#锁问题" class="headerlink" title="锁问题"></a>锁问题</h2><p>通过锁定机制可以实现事务的隔离性要求，使得事务可以并发的工作。锁提高了并发，但是也有潜在的问题。不过好在事务隔离性的要求，锁只会带来以下三种问题。</p>
<h3 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h3><p>在理解脏读（Dirty Read）之前，需要理解脏数据的概念。脏数据是指未提交的数据，如果读到了脏数据，即一个事务可以读到另外一个事务未提交的数据，则显然违反了数据的隔离性。</p>
<p>下面的表格显示了一个脏读的例子：</p>
<p><img src="http://nas.beritra.com:18081/uploads/big/5fa1953169dcdbe8e205fe9446ab697e.png" alt=""></p>
<p>表 t 还是上面创建的那个，不过不同于上述例子，这里把事务隔离级别改成了<code>READ UNCOMMITTED</code>。因此在会话 A 未提交的前提下，事务 B 两次 SELECT 取得了不同结果，即产生了脏读。</p>
<p>脏读现象在生产环境并不经常发生，由上面例子可以看出来，脏读需要隔离级别为<code>READ UNCOMMITTED</code>，实际上大多数数据库至少都是<code>READ COMMITTED</code>，而 InnoDB 默认的都是<code>READ REPEATABLE</code>。</p>
<p>脏读隔离看似毫无用处，但是一些特殊的情况下还可以将事务的隔离级别放开到<code>READ UNCOMMITTED</code>。例如 replication 环境下的 slave 节点，并且在该 slave 节点上的查询并不需要特别精确的返回值。、</p>
<h3 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h3><p>不可重复读是指在一个事务内多次读取同一个数据集合。在这个事务还没有结束时，另一个事务也访问该同一个数据集合，并做了一些 DML 操作。因此在第一个事务两次读数据之间，由于第二个事务的修改，那么第一个事务读到的数据可能是不一样的。这种情况成为不可重复读。</p>
<p>不可重复读和脏读的区别：脏读读到的是未提交的数据，不可重复读读到的却是提交过的数据，但是其违反了数据库事务一致性的要求。下面的表格展示了一个例子：</p>
<p><img src="http://nas.beritra.com:18081/uploads/big/75e52cbf37518d1129ffec738ac3eba3.png" alt=""></p>
<p>这个例子的前提是，两个事务的隔离级别都调整为<code>READ COMMITTED</code>。会话 B 的事务提交之后，事务 A 进行读取，读到的是 1 和 2 两条记录。</p>
<p>一般情况下，不可重复读是可以接受的，因为读到的是已经提交的数据，本身不会带来太大的问题，因此很多数据库的默认级别设置为<code>READ COMMITTED</code>，允许不可重复读。</p>
<p>在 InnoDB 存储引擎中，使用 Next-Key Lock 算法来避免不可重复读的问题。在 Next-Key Lock 算法下，对于索引的扫描，不仅是锁住了扫描到的索引，还锁着了索引覆盖的范围（gap）。因此在这个范围内的插入都是不被允许的。这样就避免了其他事务在这个范围内插入数据导致不可重复读的问题。</p>
<h3 id="丢失更新"><a href="#丢失更新" class="headerlink" title="丢失更新"></a>丢失更新</h3><p>丢失更新是另一个锁导致的问题，简单来说就是一个事务的更新操作会被另一个事务的更新操作覆盖，从而导致数据不一致。例如：</p>
<ol>
<li>事务 T1 将行记录 r 更新为 v1，但是事务 T1 尚未提交。</li>
<li>与此同时，事务 T2 将行记录 r 更新为 v2，事务 T2 未提交。</li>
<li>事务 T1 提交。</li>
<li>事务 T2 提交。</li>
</ol>
<p>虽然在数据库的任何隔离级别下，都不会导致理论意义上的丢失更新问题，即使是<code>READ UNCOMMITTED</code>的事务隔离级别，对于任何行的 DML 操作，需要对行或者其他粗粒度级别的对象加锁。因此上述步骤中，T2 的更新操作不能顺利执行，会被阻塞。</p>
<p>但是，生产中还会出现类似的另一个逻辑意义上的丢失更新问题，尤其是多用户的计算机系统环境下：</p>
<ol>
<li>事务 T1 查询一行数据，放到本地内存，并显示给一个终端用户 User1。</li>
<li>与此同时，事务 T2 也查询了数据，将数据展示给另一个用户 User2。</li>
<li>User1 修改了这行记录，更新数据库提交。</li>
<li>User2 也修改了记录，更新数据库提交。</li>
</ol>
<p>显然，这个过程中 User1  的更新操作“丢失”了。为了避免这种问题，需要让事务操作串行化，而不是并行。即在操作步骤 1 中，对用户读取的记录加上一个排他锁 X 。同样，在步骤 2 中，同样需要加入排它锁 X 。通过这种方式，步骤 2 就必须等待步骤 1 和 3 完成。下面的表格演示了如何避免上述逻辑上丢失更新问题的产生。</p>
<p><img src="http://nas.beritra.com:18081/uploads/big/2e8c143f61edc551fced109b87191a03.png" alt=""></p>
<h2 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a>阻塞</h2><p>由于不同锁之间的兼容关系，有时候一个事务中的锁需要等待另一个事务中的锁释放它占用的资源，这就是阻塞。</p>
<p>在 InnoDB 存储引擎中，参数<code>innodb_lock_wait_timeout</code>控制等待时间，<code>innodb_rollback_on_timeout</code>用来设定是否在等待超时时堆进行中的事务进行回滚操作。参数<code>innodb_lock_wait_timeout</code>是动态的，可以在数据库运行时动态调整，而<code>innodb_rollback_on_timeout</code>是静态的，不能在运行中修改。</p>
<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><h3 id="死锁的概念"><a href="#死锁的概念" class="headerlink" title="死锁的概念"></a>死锁的概念</h3><p>死锁是指两个或两个以上事务在执行过程中，因争夺锁资源而造成的一种相互等待的现象。</p>
<p>解决死锁最简单的方式是超时，当两个事务相互等待的时候，当其中一个等待超过阈值，进行回滚，另一个事务就可以继续进行。超时机制虽然简单，但是仅仅通过超时后事务回滚的方式处理，或者根据 FIFO 的顺序选择回滚对象。但如果超时的事务所占权重比较大，如事务操作更新很多航，占用了较多的 undo log，这时候采用 FIFO 的方式就不合适了。</p>
<p>因此，除了超时机制，当前数据库还普遍采用 wait-for graph（等待图）的方式来进行死锁检测。 wait-for graph 要求数据库保存以下两种信息：</p>
<ul>
<li>锁的信息链表</li>
<li>事务等待链表</li>
</ul>
<p>通过上述链表可以构造一张图，如果这张图中存在回路，就代表的存在死锁。 wait-for graph 是一种比较主动的死锁检测机制，InnoDB 一般会选择回滚 undo 量最小的事务。</p>
<h3 id="死锁概率"><a href="#死锁概率" class="headerlink" title="死锁概率"></a>死锁概率</h3><p>死锁的概率推导过程就不抄了，直接截图放这里：</p>
<p><img src="http://nas.beritra.com:18081/uploads/medium/c49c74ec349c32bcfba6252d150c04ad.png" alt=""></p>
<p>可以看出死锁发生概率与以下几点有关：</p>
<ul>
<li>系统中事务数量（n），数量越多死锁概率越大。</li>
<li>每个事务的操作量，数量越多死锁概率越大。</li>
<li>操作数据的集合（R），越小则死锁的概率越大。</li>
</ul>
<h3 id="死锁的示例"><a href="#死锁的示例" class="headerlink" title="死锁的示例"></a>死锁的示例</h3><p>下面的表演示了一个死锁的经典情况：</p>
<p><img src="http://nas.beritra.com:18081/uploads/big/beb5c1646f29da096ada91f25e50bcdb.png" alt=""></p>
<p>上面的例子中，会话 B 抛出了 1213 这个错误提示，即表示事务发生了死锁。大多数死锁 InnoDB 引擎本身可以侦测到，不需要人为进行干预。</p>
<p>还有另外一种情况，即当前事务持有了待插入记录的下一个记录的 X 锁，但是在等待队列中存在一个 S 锁的请求，则可能发生死锁。举个栗子，先创建一个表：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE t( a INT PRIMARY KEY)ENGINE&#x3D;INNODB;</span></pre></td></tr><tr><td class="code"><pre><span class="line">INSERT INTO t VALUES (1),(2),(4),(5);</span></pre></td></tr></table></figure>

<p>然后运行下表所示的查询：</p>
<p><img src="http://nas.beritra.com:18081/uploads/big/73be1410494a154abddd702b2fd31e59.png" alt=""></p>
<p>可以看到，会话 A 中已经对记录 4 持有了 X 锁，但是会话 A 中插入记录 3 时会导致死锁发生。这个问题的产生是由于会话 B 中请求记录 4 的 S 锁而发生等待，但之前请求的锁对于主键值记录 1、2 都已经成功，若在时间点 5 能插入记录，那么会话 B 在获得记录 4 持有的 S 锁之后，还需要向后获得记录 3 的记录，这样就显得不合理。因此 InnoDB 引擎在这里主动选择了死锁，而回滚的是 undo log 记录大的事务，这与 AB-BA 死锁的处理方式又有所不同。</p>
<h2 id="锁升级"><a href="#锁升级" class="headerlink" title="锁升级"></a>锁升级</h2><p>锁升级（Lock Escalation）是指将当前锁的粒度降低。举例来说，数据库可以吗一个表的 1000 个行锁升级为一个页锁，或者页锁升级为一个表锁。如果数据库设计中认为锁是稀有资源，想要尽量避免锁的开销，就会频繁出现锁升级现象。</p>
<p>InnoDB 存储引擎不存在锁升级的问题。因为其不是根据每个记录来产生行锁的，而是采用位图。不管一个事务锁住页中的一个记录还是多个记录，开销通常都是一致的。</p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>数据库</tag>
        <tag>锁</tag>
      </tags>
  </entry>
  <entry>
    <title>InnoDB和MyISAM区别和联系</title>
    <url>/2019/12/24/InnoDB%E5%92%8CMyISAM%E5%8C%BA%E5%88%AB%E5%92%8C%E8%81%94%E7%B3%BB/</url>
    <content><![CDATA[<p>从别人博客抄来的 MySQL 中 InnoDB 引擎与 MyISAM 引擎的区别与联系。</p>
<a id="more"></a>

<p>InnoDB：MySQL默认的事务型引擎，也是最重要和使用最广泛的存储引擎。它被设计成为大量的短期事务，短期事务大部分情况下是正常提交的，很少被回滚。InnoDB 的性能与自动崩溃恢复的特性，使得它在非事务存储需求中也很流行。除非有非常特别的原因需要使用其他的存储引擎，否则应该优先考虑 InnoDB 引擎。</p>
<p>MyISAM：在MySQL 5.1 及之前的版本，MyISAM 是默认引擎。MyISAM 提供的大量的特性，包括全文索引、压缩、空间函数（GIS）等，但 MyISAM 并不支持事务以及行级锁，而且一个毫无疑问的缺陷是崩溃后无法安全恢复。正是由于 MyISAM 引擎的缘故，即使 MySQL 支持事务已经很长时间了，在很多人的概念中 MySQL 还是非事务型数据库。尽管这样，它并不是一无是处的。对于只读的数据，或者表比较小，可以忍受修复操作，则依然可以使用 MyISAM（但请不要默认使用 MyISAM，而是应该默认使用 InnoDB）</p>
<h3 id="1、-存储结构"><a href="#1、-存储结构" class="headerlink" title="1、 存储结构"></a>1、 存储结构</h3><p>MyISAM：每个MyISAM在磁盘上存储成三个文件。分别为：<strong>表定义文件、数据文件、索引文件。</strong>第一个文件的名字以表的名字开始，扩展名指出文件类型。.frm 文件存储表定义。数据文件的扩展名为 .MYD (MYData)。索引文件的扩展名是 .MYI (MYIndex)。</p>
<p>InnoDB：所有的表都保存在同一个数据文件中（也可能是多个文件，或者是独立的表空间文件），InnoDB 表的大小只受限于操作系统文件的大小，一般为 2GB。</p>
<h3 id="2、-存储空间"><a href="#2、-存储空间" class="headerlink" title="2、 存储空间"></a>2、 存储空间</h3><p>MyISAM： MyISAM支持支持三种不同的存储格式：静态表(默认，但是注意数据末尾不能有空格，会被去掉)、动态表、压缩表。当表在创建之后并导入数据之后，不会再进行修改操作，可以使用压缩表，极大的减少磁盘的空间占用。</p>
<p>InnoDB： 需要更多的内存和存储，它会在主内存中建立其专用的缓冲池用于高速缓冲数据和索引。</p>
<h3 id="3、-可移植性、备份及恢复"><a href="#3、-可移植性、备份及恢复" class="headerlink" title="3、 可移植性、备份及恢复"></a>3、 可移植性、备份及恢复</h3><p>MyISAM：数据是以文件的形式存储，所以在跨平台的数据转移中会很方便。在备份和恢复时可单独针对某个表进行操作。</p>
<p>InnoDB：免费的方案可以是拷贝数据文件、备份 binlog，或者用 mysqldump，在数据量达到几十 G 的时候就相对痛苦了。</p>
<h3 id="4、-事务支持"><a href="#4、-事务支持" class="headerlink" title="4、 事务支持"></a>4、 事务支持</h3><p>MyISAM：强调的是性能，每次查询具有原子性,其执行数度比 InnoDB 类型更快，但是不提供事务支持。</p>
<p>InnoDB：提供事务支持事务，外部键等高级数据库功能。 具有事务(commit)、回滚(rollback)和崩溃修复能力(crash recovery capabilities)的事务安全(transaction-safe (ACID compliant))型表。</p>
<h3 id="5、-AUTO-INCREMENT"><a href="#5、-AUTO-INCREMENT" class="headerlink" title="5、 AUTO_INCREMENT"></a>5、 AUTO_INCREMENT</h3><p>MyISAM：可以和其他字段一起建立联合索引。引擎的自动增长列必须是索引，如果是组合索引，自动增长可以不是第一列，他可以根据前面几列进行排序后递增。</p>
<p>InnoDB：InnoDB 中必须包含只有该字段的索引。引擎的自动增长列必须是索引，如果是组合索引也必须是组合索引的第一列。</p>
<h3 id="6、-表锁差异"><a href="#6、-表锁差异" class="headerlink" title="6、 表锁差异"></a>6、 表锁差异</h3><p>MyISAM： 只支持表级锁，用户在操作表时，select，update，delete，insert 语句都会给表自动加锁，如果加锁以后的表满足 insert 并发的情况下，可以在表的尾部插入新的数据。</p>
<p>InnoDB： 支持事务和行级锁，是 InnoDB 的最大特色。行锁大幅度提高了多用户并发操作的新能。但是 InnoDB 的行锁，只有在查询条件走索引的时候，如果没有走索引，仍然是锁表。</p>
<h3 id="7、-全文索引"><a href="#7、-全文索引" class="headerlink" title="7、 全文索引"></a>7、 全文索引</h3><p><a href="https://link.zhihu.com/?target=https%3A//blog.csdn.net/u013276277/article/details/78139159">MySql全文索引</a></p>
<p>MyISAM：支持 FULLTEXT 类型的全文索引</p>
<p>InnoDB：MySQL 5.6 以前的版本不支持 FULLTEXT 类型的全文索引，但是 innodb 可以使用 sphinx 插件支持全文索引，并且效果更好。</p>
<p>MySQL 5.6 及以后的版本，MyISAM 和 InnoDB 存储引擎均支持全文索引，只有字段的数据类型为 char、varchar、text 及其系列才可以建全文索引。</p>
<h3 id="8、表主键"><a href="#8、表主键" class="headerlink" title="8、表主键"></a>8、表主键</h3><p>MyISAM：允许没有任何索引和主键的表存在，索引都是保存行的地址。</p>
<p>InnoDB：如果没有设定主键或者非空唯一索引，就会自动生成一个 6 字节的主键(用户不可见)，数据是主索引的一部分，附加索引保存的是主索引的值。</p>
<h3 id="9、表的具体行数"><a href="#9、表的具体行数" class="headerlink" title="9、表的具体行数"></a>9、表的具体行数</h3><p>MyISAM： 保存有表的总行数，如果<code>select count(*) from table;</code>会直接取出出该值。*</p>
<p>InnoDB： 没有保存表的总行数，如果使用<code>select count(*) from table;</code>就会遍历整个表，消耗相当大，但是在加了 where 条件后，MyISAM 和 InnoDB 处理的方式都一样。</p>
<h3 id="10、CRUD操作"><a href="#10、CRUD操作" class="headerlink" title="10、CRUD操作"></a>10、CRUD操作</h3><p>MyISAM：如果执行大量的 SELECT，MyISAM 是更好的选择。</p>
<p>InnoDB：如果你的数据执行大量的 INSERT 或 UPDATE，出于性能方面的考虑，应该使用 InnoDB 表。</p>
<h3 id="11、-外键"><a href="#11、-外键" class="headerlink" title="11、 外键"></a>11、 外键</h3><p>MyISAM：不支持</p>
<p>InnoDB：支持</p>
<p>参考文章：</p>
<p><a href="https://www.zhihu.com/question/20596402/answer/529312016" target="_blank" rel="noopener">Mysql 中 MyISAM 和 InnoDB 的区别有哪些？</a></p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>数据库</tag>
        <tag>InnoDB</tag>
      </tags>
  </entry>
  <entry>
    <title>ConcurrentHashMap使用和原理</title>
    <url>/2019/12/21/ConcurrentHashMap%E4%BD%BF%E7%94%A8%E5%92%8C%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p><code>ConcurrentHashMap</code>是在JDK1.5时，J.U.C 引入的一个同步集合工具类，顾名思义，这是一个线程安全的 HashMap。不同版本的 ConcurrentHashMap，内部实现机制千差万别，本节所有的讨论基于 JDK1.8。</p>
<a id="more"></a>

<h2 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h2><p><img src="http://nas.beritra.com:18081/uploads/big/dd9c8949bded2a52e865cdb1cdc668e0.png" alt=""></p>
<p><strong>ConcurrentHashMap</strong>内部维护了一个<code>Node</code>类型的数组，也就是<strong>table</strong>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">transient volatile Node[] table;</span></pre></td></tr></table></figure>

<p>数组的每一个位置<code>table[i]</code>代表了一个桶，当插入键值对时，会根据键的hash值映射到不同的桶位置，table 一共可以包含 4 种不同类型的桶：<strong>Node</strong>、<strong>TreeBin</strong>、<strong>ForwardingNode</strong>、<strong>ReservationNode</strong>。上图中，不同的桶用不同颜色表示。可以看到，有的桶链接着链表，有的桶链接着树。</p>
<p><strong>TreeBin *<em>所链接的是一颗红黑树，红黑树的结点用 *</em>TreeNode</strong> 表示，所以 ConcurrentHashMap 中实际上一共有五种不同类型的 Node 结点。</p>
<p><em>之所以用<strong>TreeBin</strong>而不是直接用<strong>TreeNode</strong>，是因为红黑树的操作比较复杂，包括构建、左旋、右旋、删除，平衡等操作，用一个代理结点TreeBin来包含这些复杂操作，其实是一种“职责分离”的思想。另外TreeBin中也包含了一些加/解锁的操作。</em></p>
<h2 id="节点定义"><a href="#节点定义" class="headerlink" title="节点定义"></a>节点定义</h2><h3 id="Node-节点"><a href="#Node-节点" class="headerlink" title="Node 节点"></a>Node 节点</h3><p>Node 结点的定义非常简单，也是其它四种类型结点的父类。</p>
<blockquote>
<p>默认链接到<code>table[i]</code>——桶上的结点就是 Node 结点。<br>当出现 hash 冲突时，Node 结点会首先以<strong>链表</strong>的形式链接到 table 上，当结点数量超过一定数目时，链表会转化为红黑树。因为链表查找的平均时间复杂度为<code>O(n)</code>，而红黑树是一种平衡二叉树，其平均时间复杂度为<code>O(logn)</code>。</p>
</blockquote>
<h3 id="TreeNode-结点"><a href="#TreeNode-结点" class="headerlink" title="TreeNode 结点"></a>TreeNode 结点</h3><p>TreeNode就是红黑树的结点，TreeNode 不会直接链接到<code>table[i]</code>——桶上面，而是由TreeBin 链接，TreeBin 会指向红黑树的根结点。</p>
<h3 id="TreeBin-结点"><a href="#TreeBin-结点" class="headerlink" title="TreeBin 结点"></a>TreeBin 结点</h3><p>TreeBin 相当于 TreeNode 的代理结点。TreeBin 会直接链接到<code>table[i]</code>——桶上面，该结点提供了一系列红黑树相关的操作，以及加锁、解锁操作。</p>
<h3 id="ForwardingNode-结点"><a href="#ForwardingNode-结点" class="headerlink" title="ForwardingNode 结点"></a>ForwardingNode 结点</h3><p>ForwardingNode 结点仅仅在扩容时才会使用</p>
<h3 id="ReservationNode-结点"><a href="#ReservationNode-结点" class="headerlink" title="ReservationNode 结点"></a>ReservationNode 结点</h3><p>保留结点，ConcurrentHashMap 中的一些特殊方法会专门用到该类结点。</p>
<h2 id="常量定义"><a href="#常量定义" class="headerlink" title="常量定义"></a>常量定义</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * 最大容量.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * 默认初始容量</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">16</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * The largest possible (non-power of two) array size.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * Needed by toArray and related methods.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * 负载因子，为了兼容JDK1.8以前的版本而保留。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * JDK1.8中的ConcurrentHashMap的负载因子恒定为0.75</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> LOAD_FACTOR = <span class="number">0.75f</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * 链表转树的阈值，即链接结点数大于8时， 链表转换为树.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * 树转链表的阈值，即树结点树小于6时，树转换为链表.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * 在链表转变成树之前，还会有一次判断：</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * 即只有键值对数量大于MIN_TREEIFY_CAPACITY，才会发生转换。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * 这是为了避免在Table建立初期，多个键值对恰好被放入了同一个链表中而导致不必要的转化。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * 在树转变成链表之前，还会有一次判断：</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * 即只有键值对数量小于MIN_TRANSFER_STRIDE，才会发生转换.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TRANSFER_STRIDE = <span class="number">16</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * 用于在扩容时生成唯一的随机数.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> RESIZE_STAMP_BITS = <span class="number">16</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * 可同时进行扩容操作的最大线程数.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_RESIZERS = (<span class="number">1</span> &lt;&lt; (<span class="number">32</span> - RESIZE_STAMP_BITS)) - <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * The bit shift for recording size stamp in sizeCtl.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RESIZE_STAMP_SHIFT = <span class="number">32</span> - RESIZE_STAMP_BITS;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MOVED = -<span class="number">1</span>;                <span class="comment">// 标识ForwardingNode结点（在扩容时才会出现，不存储实际数据）</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEBIN = -<span class="number">2</span>;              <span class="comment">// 标识红黑树的根结点</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RESERVED = -<span class="number">3</span>;             <span class="comment">// 标识ReservationNode结点（）</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HASH_BITS = <span class="number">0x7fffffff</span>;    <span class="comment">// usable bits of normal node hash</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * CPU核心数，扩容时使用</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NCPU = Runtime.getRuntime().availableProcessors();</span></pre></td></tr></table></figure>



<h2 id="字段定义"><a href="#字段定义" class="headerlink" title="字段定义"></a>字段定义</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * Node数组，标识整个Map，首次插入元素时创建，大小总是2的幂次.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K, V&gt;[] table;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * 扩容后的新Node数组，只有在扩容时才非空.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K, V&gt;[] nextTable;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * 控制table的初始化和扩容.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * 0  : 初始默认值</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * -1 : 有线程正在进行table的初始化</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * &gt;0 : table初始化时使用的容量，或初始化/扩容完成后的threshold</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * -(1 + nThreads) : 记录正在执行扩容任务的线程数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> sizeCtl;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * 扩容时需要用到的一个下标变量.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> transferIndex;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * 计数基值,当没有线程竞争时，计数将加到该变量上。类似于LongAdder的base变量</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">long</span> baseCount;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * 计数数组，出现并发冲突时使用。类似于LongAdder的cells数组</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> CounterCell[] counterCells;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * 自旋标识位，用于CounterCell[]扩容时使用。类似于LongAdder的cellsBusy变量</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> cellsBusy;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 视图相关字段</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> KeySetView&lt;K, V&gt; keySet;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> ValuesView&lt;K, V&gt; values;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> EntrySetView&lt;K, V&gt; entrySet;</span></pre></td></tr></table></figure>



<h2 id="get-操作"><a href="#get-操作" class="headerlink" title="get 操作"></a>get 操作</h2><p>get 方法的逻辑很简单，首先根据 key 的 hash 值计算映射到 table 的哪个桶——<code>table[i]</code>。</p>
<ol>
<li>如果<code>table[i]</code>的 key 和待查找 key 相同，那直接返回；</li>
<li>如果<code>table[i]</code>对应的结点是特殊结点（hash值小于0），则通过<code>find</code>方法查找；</li>
<li>如果<code>table[i]</code>对应的结点是普通链表结点，则按链表方式查找。</li>
</ol>
<p>第二种情况下，<code>table[i]</code>是不同的节点，处理方式也会不同：</p>
<h3 id="Node-结点的查找"><a href="#Node-结点的查找" class="headerlink" title="Node 结点的查找"></a>Node 结点的查找</h3><p>当槽<code>table[i]</code>被普通 Node 结点占用，说明是链表链接的形式，直接从链表头开始查找。</p>
<h3 id="TreeBin-结点的查找"><a href="#TreeBin-结点的查找" class="headerlink" title="TreeBin 结点的查找"></a>TreeBin 结点的查找</h3><p>TreeBin 的查找比较特殊，我们知道当槽<code>table[i]</code>被 TreeBin 结点占用时，说明链接的是一棵红黑树。由于红黑树的插入、删除会涉及整个结构的调整，所以通常存在读写并发操作的时候，是需要加锁的。</p>
<blockquote>
<p>ConcurrentHashMap 采用了一种<strong>类似读写锁</strong>的方式：当线程持有写锁（修改红黑树）时，如果读线程需要查找，不会像传统的读写锁那样阻塞等待，而是转而以链表的形式进行查找（TreeBin本身时Node类型的子类，所有拥有 Node 的所有字段）</p>
</blockquote>
<h3 id="ForwardingNode-结点的查找"><a href="#ForwardingNode-结点的查找" class="headerlink" title="ForwardingNode 结点的查找"></a>ForwardingNode 结点的查找</h3><p>ForwardingNode 是一种临时结点，在扩容进行中才会出现，所以查找也在扩容的table上进行。</p>
<h3 id="ReservationNode-结点的查找"><a href="#ReservationNode-结点的查找" class="headerlink" title="ReservationNode 结点的查找"></a>ReservationNode 结点的查找</h3><p>ReservationNode 是保留结点，不保存实际数据，所以直接返回<code>null</code>。</p>
<h2 id="put-操作"><a href="#put-操作" class="headerlink" title="put 操作"></a>put 操作</h2><p>put 方法内部调用了<code>putVal</code>这个私有方法</p>
<p><code>putVal</code>的逻辑还是很清晰的，首先根据<code>key</code>计算<code>hash</code>值，然后通过<code>hash</code>值与<code>table</code>容量进行运算，计算得到<code>key</code>所映射的索引——也就是对应到<strong>table</strong>中桶的位置。</p>
<p>这里需要注意的是计算索引的方式：<code>i = (n - 1) &amp; hash</code></p>
<p><code>n - 1 == table.length - 1</code>，<code>table.length</code> 的大小必须为<strong>2的幂次</strong>的原因就在这里。</p>
<p>读者可以自己计算下，当<code>table.length</code>为2的幂次时，<code>(table.length-1)</code>的二进制形式的特点是除最高位外全部是 1，配合这种索引计算方式可以实现 key 在 table 中的均匀分布，减少 hash 冲突——出现 hash 冲突时，结点就需要以链表或红黑树的形式链接到<code>table[i]</code>，这样无论是插入还是查找都需要额外的时间。</p>
<p><code>putVal</code>方法一共处理四种情况：</p>
<h3 id="1、首次初始化-table-懒加载"><a href="#1、首次初始化-table-懒加载" class="headerlink" title="1、首次初始化 table 懒加载"></a>1、首次初始化 table 懒加载</h3><p><strong>ConcurrentHashMap</strong>在构造的时候并不会初始化 table 数组，首次初始化就在这里通过<code>initTable</code>方法完成。首次加载的时候，会通过<code>sizeCtl</code>变量来控制，只有变量修改成功后才开始初始化，避免了多线程同时初始化的问题。</p>
<h3 id="2、table-i-对应的桶为空"><a href="#2、table-i-对应的桶为空" class="headerlink" title="2、table[i] 对应的桶为空"></a>2、table[i] 对应的桶为空</h3><p>最简单的情况，直接 CAS 操作占用桶<code>table[i]</code>即可。</p>
<h3 id="3、发现-ForwardingNode-结点，说明此时-table-正在扩容，则尝试协助进行数据迁移"><a href="#3、发现-ForwardingNode-结点，说明此时-table-正在扩容，则尝试协助进行数据迁移" class="headerlink" title="3、发现 ForwardingNode 结点，说明此时 table 正在扩容，则尝试协助进行数据迁移"></a>3、发现 ForwardingNode 结点，说明此时 table 正在扩容，则尝试协助进行数据迁移</h3><p>ForwardingNode 结点是 ConcurrentHashMap 中的五类结点之一，相当于一个占位结点，表示当前 table 正在进行扩容，当前线程可以尝试协助数据迁移。</p>
<h3 id="4、出现-hash-冲突-也就是table-i-桶中已经有了结点"><a href="#4、出现-hash-冲突-也就是table-i-桶中已经有了结点" class="headerlink" title="4、出现 hash 冲突,也就是table[i]桶中已经有了结点"></a>4、出现 hash 冲突,也就是<code>table[i]</code>桶中已经有了结点</h3><p>ConcurrentHashMap 就是在最后一种情况这里加锁的。</p>
<p>当两个不同<code>key</code>映射到同一个<code>table[i]</code>桶中时，就会出现这种情况：</p>
<ul>
<li>当<code>table[i]</code>的结点类型为 Node——链表结点时，就会将新结点以“尾插法”的形式插入链表的尾部。</li>
<li>当<code>table[i]</code>的结点类型为 TreeBin——红黑树代理结点时，就会将新结点通过红黑树的插入方式插入。</li>
</ul>
<p>再然后，涉及将链表转换为红黑树 —— <code>treeifyBin</code>，但实际情况并非立即就会转换，当 table 的容量小于 64 时，出于性能考虑，只是对 table 数组扩容1倍——<code>tryPresize</code>。</p>
<h3 id="addCount-操作"><a href="#addCount-操作" class="headerlink" title="addCount 操作"></a>addCount 操作</h3><p>在<code>putVal</code>的最后一步，就是调用<code>addCount</code>方法，把计数器增加，但是并发环境下也不是一个简简单单的操作，我们看下这个方法都做了什么。</p>
<p>在看这个方法之前，必须了解<code>ConcurrentHashMap</code>进行数量统计的基本方法，它引入了两个变量<code>baseCount</code>、<code>counterCells</code>。<code>baseCount</code>负责简单计数，直接 CAS 操作，用于在没有出现竞争的情况下统计，操作失败的再用<code>counterCells</code>进行补充，补充方式有点复杂，这里先不展开，改天值得单独开文解读，总的来说思路是跟 LongAdder 类似。最终计数结果是<code>baseCount</code>、<code>counterCells</code>两个变量取和。</p>
<ol>
<li>判断计数盒子属性是否是空，如果是空，就尝试修改 baseCount 变量，对该变量进行加 X。</li>
<li>如果计数盒子不是空，或者修改 baseCount 变量失败了，则放弃对 baseCount 进行操作。</li>
<li>如果计数盒子是<code>null</code>或者计数盒子的 length 是 0，或者随机取一个位置取于数组长度是<code>null</code>，那么就对刚刚的元素进行 CAS 赋值。</li>
<li>如果赋值失败，或者满足上面的条件，则调用<code>fullAddCount</code>方法重新死循环插入。</li>
<li>这里如果操作 baseCount 失败了（或者计数盒子不是<code>null</code>），且对计数盒子赋值成功，那么就检查 check 变量，如果该变量小于等于 1。直接结束。否则，计算一下 count 变量。</li>
<li>如果 check 大于等于 0 ，说明需要对是否扩容进行检查。</li>
<li>如果 map 的 size 大于<code>sizeCtl</code>（扩容阈值），且 table 的长度没到最大值，那么就进行扩容。</li>
<li>根据 length 得到一个标识符，然后，判断<code>sizeCtl</code>状态，如果小于 0 ，说明其他线程在初始化或者在扩容。</li>
<li>如果正在扩容，那么就校验一下数据是否变化了。如果检验数据不通过，break。</li>
<li>如果校验数据通过了，那么将<code>sizeCtl</code>加一，表示多了一个线程帮助扩容。然后进行扩容。</li>
<li>如果没有在扩容，但是需要扩容。那么就将<code>sizeCtl</code>更新，赋值为标识符左移 16 位 —— 一个负数。然后加 2。 表示已经有一个线程开始扩容了，然后进行扩容。然后再次更新 count，看看是否还需要扩容。</li>
</ol>
<h3 id="transfer-扩容操作"><a href="#transfer-扩容操作" class="headerlink" title="transfer 扩容操作"></a>transfer 扩容操作</h3><p>扩容同样是非常重要的步骤，也是很容易发生线程安全问题的部分，让我们看看<code>ConcurrentHashMap</code>怎么做的：</p>
<ol>
<li>通过计算 CPU 核心数和 Map 数组的长度得到每个线程（CPU）要帮助处理多少个桶，并且这里每个线程处理都是平均的。默认每个线程处理 16 个桶。因此，如果长度是 16 的时候，扩容的时候只会有一个线程扩容。</li>
<li>初始化临时变量<code>nextTable</code>。将其在原有基础上扩容两倍。</li>
<li>死循环开始转移。多线程并发转移就是在这个死循环中，根据一个<code>finishing</code>变量来判断，该变量为 true 表示扩容结束，否则继续扩容。<ul>
<li>进入一个 while 循环，分配数组中一个桶的区间给线程，默认是 16。</li>
<li>出 while 循环，进 if 判断，判断扩容是否结束，如果扩容结束，清空临死变量，更新 table 变量，更新扩容阈值。如果没完成，但已经无法领取区间（没了），该线程退出该方法，并将 sizeCtl 减一，表示扩容的线程少一个了。如果减完这个数以后，sizeCtl 回归了初始状态，表示没有线程再扩容了，该方法所有的线程扩容结束了。（这里主要是判断扩容任务是否结束，如果结束了就让线程退出该方法，并更新相关变量）。然后检查所有的桶，防止遗漏。 </li>
<li>如果没有完成任务，且 i 对应的槽位是空，尝试 CAS 插入占位符，让<code>putVal</code>方法的线程感知。 </li>
<li>如果<code>i</code>对应的槽位不是空，且有了占位符，那么该线程跳过这个槽位，处理下一个槽位。</li>
<li>如果以上都是不是，说明这个槽位有一个实际的值。开始同步处理这个。</li>
<li>到这里，都还没有对桶内数据进行转移，只是计算了下标和处理区间，然后一些完成状态判断。同时，如果对应下标内没有数据或已经被占位了，就跳过了。</li>
</ul>
</li>
<li>处理每个桶的行为都是同步的，此处加了<code>synchronized</code>关键字。防止<code>putVal</code>的时候向链表插入数据。 <ul>
<li>如果这个桶是链表，那么就将这个链表根据<code>length</code>取于拆成两份，取于结果是 0 的放在新表的低位，取于结果是 1 放在新表的高位。 </li>
<li>如果这个桶是红黑数，那么也拆成 2 份，方式和链表的方式一样，然后，判断拆分过的树的节点数量，如果数量小于等于 6，改造成链表。反之，继续使用红黑树结构。 </li>
<li>到这里，就完成了一个桶从旧表转移到新表的过程。</li>
</ul>
</li>
</ol>
<p>多线程无锁扩容的关键就是通过 CAS 设置 sizeCtl 与 transferIndex 变量，协调多个线程对 table 数组中的 node 进行迁移。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>由上面种种可以看到，<code>ConcurrentHashMap</code>对比<code>HashMap</code>和<code>HashTable</code>成功处理线程安全的关键有几个：</p>
<ol>
<li>关键操作加锁。这个说起来简单，但是优化起来很复杂，添加修改删除元素、扩容，<code>HashTable</code>也是这么做的。</li>
<li>善用锁升级，从无锁到偏向锁，再到自旋锁和重量级锁，一步步加码，保证低并发的时候最大效率。</li>
<li>空间换时间，在面对超大并发，自旋锁大量重复消耗的时候，让多个线程同步进行修改，增加效率。</li>
<li>多余线程参与扩容、计数等工作，能不闲着绝不闲着。</li>
</ol>
<p>ConcurrentHashMap 六千多行代码，五十三个内部类，都是精华代码，Doug Lea 大神果然厉害。</p>
<p>参考文章：</p>
<p>简书博主<a href="https://www.jianshu.com/u/434239413000" target="_blank" rel="noopener">莫那一鲁道</a>对<code>ConcurrentHashMap</code>进行了非常细致的总结，本文学习和抄袭了大量文字，更详细的内容建议直接去看原文：<a href="https://www.jianshu.com/p/29d8e66bc3bf" target="_blank" rel="noopener">ConcurrentHashMap 源码阅读小结</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL中的事务</title>
    <url>/2019/12/17/MySQL%E4%B8%AD%E7%9A%84%E4%BA%8B%E5%8A%A1/</url>
    <content><![CDATA[<p>本文主要摘抄自《MySQL技术内幕（InnoDB存储引擎）第二版》，少部分来自网络博客和自己补充。注意，该书内容是基于MySQL 5.6 及更早的版本，具体的实现方式有可能发生了改变，有些内容我做了注释和补充，但是不保证百分百的完整和正确。</p>
<a id="more"></a>

<p>事务（Transaction）是数据库区别于文件系统的重要特性之一。事务会把数据库从一种一致性状态转换为另一种一致状态。在数据库提交工作时，可以确保要么所有修改都已经保存了，要么所有修改都不保存。</p>
<p>InnoDB 存储引擎中的事务完全符合 ACID 的特性。ACID 是以下 4 个词的缩写：</p>
<ul>
<li>原子性（atomicity）</li>
<li>一致性（consistency）</li>
<li>隔离性（isolation）</li>
<li>持久性（durability）</li>
</ul>
<p>本文主要关注事务的原子性这一概念，并说明怎么正确使用事务及编写正确的事务应用程序，避免在事务方面养成一些不好的习惯。</p>
<h2 id="认识事务"><a href="#认识事务" class="headerlink" title="认识事务"></a>认识事务</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>事务可由一条非常简单的 SQL 语句组成，也可以由一组复杂的 SQL 语句组成。事务是访问并更新数据库中各种数据项的一个程序执行单元。在事务操作中，要么都做修改，要么都不做，这就是事务的目的，也是事务模型区别于文件系统的重要特征之一。</p>
<p>理论上说，事务有严格的定义，必须同时满足四个特性，即 ACID 特性。但是数据库厂商出于各种目的，并没有严格去满足事务的 ACID 标准。对于 InnoDB 存储引擎而言，其默认的事务隔离级别为<code>READ REPEATABLE</code> 完全遵循和满足事务的 ACID 特性。这里具体介绍事务的 AICD 特性，并给出相关概念。</p>
<p>A（Atomicity）原子性。在计算机系统中，每个人都将原子性视为理所当然。例如在 C 语言中调用<code>SQRT</code>函数，要么返回正确的平方根值，要么返回错误的代码，而不会在不可预知的情况下改变任何的数据结构和参数。如果<code>SQRT</code>函数被多个程序同时调用，一个程序的返回值也不会是其他程序需要计算的平方根。</p>
<p>然而在数据的事务中实现调用操作的原子性，就没那么简单了，例如一个 ATM 机取款的流程：</p>
<ol>
<li>登录 ATM 机平台，验证密码。</li>
<li>从远程银行的数据库中，取得账户信息。</li>
<li>用户在 ATM 机上输入欲提取的金额。</li>
<li>从远程银行的数据库中，更新账户信息。</li>
<li>ATM 机出款。</li>
<li>用户取钱。</li>
</ol>
<p>整个取款流程应当视作原子操作，即要么都做，要么不做。不能用户钱未从 ATM 机上取得，但是银行卡上的钱已经被扣除了，相信这是任何人都不能接受的一种情况。而通过事务模型，可以保证操作的原子性。</p>
<p>原子性是指整个数据库事务是不可分割的工作单位。只有使事务中所有的数据库操作都执行成功，才算整个事务成功。任何一个 SQL 语句执行失败，已经执行成功的 SQL 语句也必须撤销，数据库状态应该退回到执行事务前的状态。</p>
<p>C（consistency），一致性。一致性是指事务将数据库从一种状态转变为下一种一致的状态。在事务开始之前和结束之后，数据库的完整性约束没有被破坏。事务是一致性的单位，如果事务中某个动作失败了，系统可以自动撤销事务，返回初始化的状态。</p>
<p>I（isolation），隔离性。隔离性还有其他称呼，如并发控制（consurrency control）、可串行化（serializability）、锁（locking）等。事务的隔离性要求每个读写事务的对象对其他事务的操作对象能相互分离，即该事务提交前对其他事务都不可见，通常这使用锁来实现。当前数据库系统中都提供了一种粒度锁（granular lock）的策略，允许事务仅锁住一个实体对象的子集，以此来提高事务之间的并发度。</p>
<p>D（durability），持久性。事务一旦提交，其结果就是永久性的。即使发生宕机等故障，数据库也能将数据恢复。需要注意的是，只能从事务本身的角度来保证结果的永久性。例如，在事务提交后，所有的变化都是永久的。即使当数据库发生崩溃而需要恢复数据时，也能保证恢复后提交的数据都不会丢失。但若不是数据库本身的问题，那么数据有可能丢失。因此保证事务系统的高可靠性（High Reliability），而不是高可用性（High Availability）。对于高可用性的实现，事务本身并不能保证，需要一些系统共同配合来完成。</p>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p>从事务理论的角度来说，可以把事务分为以下几种类型：</p>
<ul>
<li>扁平事务（Flat Transactions）</li>
<li>带有保存点的扁平事务（Flat Transaction with Savepoints）</li>
<li>链事务（Chained Transactions）</li>
<li>嵌套事务（Nested Transaction）</li>
<li>分布式事务（Distributed Transactions）</li>
</ul>
<p><strong>扁平事务（Flat Transaction）</strong>是事务类型中最简单的一种，但在实际生产环境中，可能是最频繁的事务。在扁平事务中，所有操作都处于同一层次，其由<code>BEGIN WORK</code>开始，由<code>COMMIT WORK</code>或<code>ROLLBACK WORK</code>结束，其间的操作是原子的，要么都执行，要么都回滚。因此扁平事务是应用程序成为原子操作的基本组成模块。</p>
<p> 下图显示了扁平事务的三种不同结果：</p>
<p><img src="http://nas.beritra.com:18081/uploads/big/980e4507ab99e2a1f4a78fe7b4c954e8.png" alt=""></p>
<p>扁平事务的主要限制是不能提交或者回滚事务中的某一部分，或者分步骤提交。下面给出了一个扁平事务不足以支持的例子。例如用户在旅行网站上进行自己的旅行度假计划。用户摄像从杭州道意大利的佛罗伦萨，这两个城市之间没有直达的班级，需要用户预定并转乘航班，或者需要搭火车等待。用户旅行度假的事务为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">BEGIN WROK</span></pre></td></tr><tr><td class="code"><pre><span class="line">S1：预定杭州到上海的高铁</span></pre></td></tr><tr><td class="code"><pre><span class="line">S2：上海浦东国际机场坐飞机，预定区米兰的航班</span></pre></td></tr><tr><td class="code"><pre><span class="line">S3：在米兰坐火车前往佛罗伦萨，预定去佛罗伦萨的火车</span></pre></td></tr></table></figure>

<p>但是当用户执行到 S3 的时候，发现由于飞机到达米兰的时间台湾，已经没有当天的火车。这时用户希望在米兰当地住一晚，第二天出发去佛罗伦萨。这时如果事务为扁平事务，则需要回滚之前 S1、S2、S3 的三个操作，这个代价就显得有点大。因为当再次进行该事务的时候，S1、S2 的执行计划是不变的。也就是说，如果有支持计划的回滚操作，那么就不需要终止整个事务。因此就出现了带有保存点的扁平事务。</p>
<p><strong>带有保存点的扁平事务（Flat Transaction with Savepoint）</strong>，除了支持扁平事务支持的操作外，允许在事务执行过程中回滚到同一事务中较早的一个状态。这是因为某霞事务可能在执行过程中出现的错误并不会导致所有的操作都无效，放弃整个事务不合乎要求，开销页太大。<strong>保存点（Savepoint）</strong>用来通知系统应该记住事务当前的状态，以便当以后发生错误时，事务能回到保存点当时的状态。对于扁平的事务来说，其隐式的设置了一个保存点。而在整个事务中，只有一个保存点，因此，回滚只能回滚到事务开始时的状态。保存点用<code>SAVE WORK</code>函数来建立，通知系统记录当前的处理状态。当出现问题的时候，保存点能用作内部的重启动点，根据应用逻辑，决定是回到最近一个保存点还是其他更早的保存点。下图显示了在事务中使用了保存点：</p>
<p><img src="http://nas.beritra.com:18081/uploads/medium/dca2709fdeb84932ccae92cf405fbbe0.png" alt=""></p>
<p>上图显示了如何在事务中使用保存点。灰色背景部分的操作表示由<code>ROLLBACK WORK</code>而导致的部分回滚，实际并没有执行的操作。当用 BEGIN WORK 开启一个事务时，隐式地包含一个保存点，当事务通过<code>ROLLBACK WORK：2</code> 发出部分回滚命令的时候，事务回滚到保存点 2，接着一次执行，并再次执行到<code>ROLLBACK WORK：7</code>，知道最后的<code>COMMIT WORK</code>操作，这时表示事务结束，除灰色阴影部分的操作外，其他的操作都已经执行，并且提交。</p>
<p>另一点需要注意的是，保存点在事务内部是递增的，这从上图中也可以看出。有人可能会想，返回保存点 2 之后，下一个保存点可以是 3，因为之前的动作都终止了。然而新的保存点编号为 5，这意味着<code>ROLLBACK</code>不影响保存点的计数，并且单调递增的编号能保持事务执行的整个历史过程，包括在执行过程中想法的改变。</p>
<p>此外，当事务通过<code>ROLLBACK WORK</code>：2 命令部分回滚命令时，要记住事务并没有完全被回滚，只是回滚到了保存点 2 而已。这代表当前事务还是活跃的，如果想要完全回滚事务，还需要再执行命令<code>ROLLBACK WORK</code>。</p>
<p><strong>链事务（Chained Transaction）</strong>可以视为是保存点模式的一种变种。带有保存点的扁平事务，当事务发生崩溃的时候，所有保存点都将消失，因为其保存点是易失的（volatile），而非持久的（persistent）。这意味着当进行恢复时，事务需要从开始处重新执行，而不能从最近的一个保存点继续执行。</p>
<p>链事务的思想是：在提交一个事务时，释放不需要的数据对象，将必要的数据处理上下文隐式地传给下一个要开始的事务。注意，提交事务操作和开始下一个事务操作将合并为一个原子操作。这意味着下一个事务将看到上一个事务的结果，就好像在一个事务中进行的一样。下图显示了链事务的工作方式：</p>
<p><img src="http://nas.beritra.com:18081/uploads/big/c90bcbd6ddbdd7f6b3571df115408746.png" alt=""></p>
<p>链事务与带有保存点的扁平事务不同的是，带有保存点的扁平事务能回滚到任意正确的保存点。而链事务中的回滚仅限于当前事务，即只能恢复到最近的一个保存点。对于锁的处理，两者也不相同。链事务在执行<code>COMMIT</code>后即释放了当前事务所持有的锁，</p>
<p>而带有保存点的扁平事务不影响迄今为止所持有的锁。</p>
<p><strong>嵌套事务（Nested Transaction）</strong>是一个层次结构框架。由一个顶层事务（top-level transaction）控制着各个层次的事务。顶层事务之下嵌套的事务被称为子事务（subtransaction），其控制着每一个局部的变量。嵌套事务的层次结构如图所示：</p>
<p><img src="http://nas.beritra.com:18081/uploads/big/aa0edf09310f5553bca987baea782926.png" alt=""></p>
<p>下面是 Moss 对嵌套事务的定义：</p>
<ol>
<li>嵌套事务是由若干事务组成的一颗树，子树既可以是嵌套事务，也可以是扁平事务。</li>
<li>处在叶节点的事务是扁平事务。但是每个子事务从根到叶节点的距离可以是不同的。</li>
<li>处于根节点的事务成为顶层事务，其他事物称为子事务。事务的前驱（predecessor）称为父事务（parent），事务的下一层成为儿子事务（child）。</li>
<li>子事务既可以提交也可以回滚。但是它的提交操作并不会马上生效，除非其父事务已经提交。由此可以推论出，任何子事务都在顶层事务提交后才真正的提交。</li>
<li>树中任何一个事务的回滚都会引起它所有的子事务一同回滚，故子事务仅保留 A、C、I 特性，不具有 D 的特性。</li>
</ol>
<p>根据 Moss 的理论，实际的工作是交由叶子节点来完成的，即只有叶子节点的事务才能访问数据库、发送消息、获取其他类型的资源。而高层的事务仅负责逻辑控制，决定何时调用相关的子事务。即使一个系统不支持嵌套事务，用户也可以通过保存点技术来模拟嵌套事务，如图所示：</p>
<p><img src="http://nas.beritra.com:18081/uploads/big/bb67629bf4784eaf753a252db39807c0.png" alt=""></p>
<p>从图中也可以发现，在恢复时采用保存点技术比嵌套查询有更大的灵活性。例如在完成 Tk3 这个事务的时候，可以回滚到保存点 S2 的状态。而在嵌套查询的层次结构中，这是不被允许的。</p>
<p>但是用保存点技术来模拟嵌套事务在锁的持有方面还是与嵌套查询有些区别。当通过保存点技术来模拟嵌套事务时，用户无法选择哪些锁需要被子事务继承，哪些需要被父事务保留。就是说：无论有多少个保存点，所有被锁住的对象都可以被得到和访问。而在查询嵌套中，不同的子事务在数据库对象上持有的锁是不同的。 例如有一个父事务 P1，其持有对象 X 和 Y 的排它锁，现在要开始调用子事务 p11，那么父事务 P1 可以不传递锁，也可以传递所有的锁，也可以只传递一个排他锁。如果子事务 P11 中还有持有对象 X、Y、Z 的排他锁。如果这时又再次调用了一个子事务 P12，那么它可以传递那里已经持有的锁。</p>
<p>然而，如果系统支持在嵌套事务中并行地执行各个事务，在这种情况下，采用保存点的扁平事务来模拟嵌套事务就不切实际了。者从另一个方面反映出，想要实现事务键的并行性，需要真正支持的嵌套事务<strong>。</strong></p>
<p><strong>分布式事务（Distributed Transaction）</strong>通常是在一个分布式环境下运行的扁平事务，因此需要根据数据所在位置访问网络中的不同节点。</p>
<p>假设一个用户在 ATM 机上进行银行的转账操作，例如持卡人从招商银行的储蓄卡转账 10000 元到工商银行的储蓄卡。在这汇总情况下，可以将 ATM 机视为节点 A，招商银行的后台数据库视为节点 B，工商银行的后台数据库视为 C，这个转账操作可以分解为以下的步骤：</p>
<ol>
<li>节点 A 发出转账命令。</li>
<li>节点 B 执行储蓄卡中的余额值减去 10000。</li>
<li>节点 C 执行储蓄卡中的余额值加上 10000。</li>
<li>节点 A 通知用户完成或者节点 A 通知用户操作失败。</li>
</ol>
<p>这里需要使用分布式事务，因为节点 A 不能通过调用一台数据库就完成任务，其需要访问网络中两个节点的数据库，而在每个节点中的数据库执行的事务操作都又是扁平的。对于分布式事务，其同样需要满足 ACID 特性，要么都发生，要么都失效。对于上述例子，如果 2、3 步中任何一个操作失败，都会导致整个分布式事务回滚。</p>
<p>对于 InnoDB 存储引擎来说，支持扁平事务、带有保存点的事务、链事务、分布式事务。对于嵌套事务，其并不原生支持，因此，对于有并行事务需求的用户来说，MySQL 数据库或 InnoDB 存储引擎就显得无能为力了。然而用户仍可以通过带有保存点的事务来模拟串行的嵌套事务。</p>
<h2 id="事务的实现"><a href="#事务的实现" class="headerlink" title="事务的实现"></a>事务的实现</h2><p>事务的隔离性由锁来实现。原子性、一致性、持久性通过数据库的 redo log 或 undo log 来完成。redo log 又称为重做日志，用来保证事务的原子性和持久性。undo log 用来保证事务的一致性。</p>
<p>有人可能会认为 undo 是 redo 的逆过程，其实不然。redo 和 undo 的作用都可以视为是一种恢复操作，redo 恢复提交事务修改的页操作，而 undo 回滚行记录到某个特定版本。因此两者记录的内容不同，redo 通常是物理日志，记录的是页的屋里操作改动，undo 是逻辑日志，根据每行记录进行记录。</p>
<h3 id="redo"><a href="#redo" class="headerlink" title="redo"></a>redo</h3><p>重做日志用来实现事务的持久性，即事务 ACID 中的 D。其由两部分组成：一是内存中的重做日志缓冲（redo log buffer），其是易失的；二是重做日志文件（redo log file），其是持久的。</p>
<p>InnoDB 是事务的存储引擎，通过<code>Force Log at Commit</code>机制实现事务的持久性，即当事务提交（COMMIT）的时候，必须先把事务的所有日志写入到重做日志文件进行持久化，等事务的提交操作完成之后才算完成。这里的日志是指重做日志，在 InnoDB 存储引擎中，由两部分组成，即 redo log 和 undo log。redo log 用来保证事务的持久性，undo log 用来帮助事务回滚以及 MVCC 的功能。redo log 基本上都是顺序写的，在数据库运行时不需要对 redo log 的文件进行读取操作。而 undo log 是需要进行随机读写的。</p>
<p>为了确保每次日志都写入重做日志文件，在每次日志缓冲写入重做日志文件之后，InnoDB 存储引擎都需要调用一次<code>fsync</code>操作。由于重做日志文件打开并没有使用<code>O_DIRECT</code>选项，因此重做日志缓冲先写入文件系统缓存。由于<code>fsync</code>的效率取决于磁盘性能，因此磁盘的性能决定了事务提交的性能，也就是数据库的性能。</p>
<p>InnoDB 存储引擎允许用户手动设置非持久性的情况发生，因此提高数据库的性能。当事务提交的时候，日志不写入重做日志文件，而是等待一个时间周期后再执行<code>fsync</code>操作。由于并非强制在事务提交的时候进行一次<code>fync</code>操作，显然可以提高数据库性能。但是在数据库发生宕机的时候，由于部分日志未发刷新到磁盘，因此会丢失最后一段时间的事务。</p>
<p>参数<code>inndob_flush_log_at_trx_commit</code>用来控制重做日志刷新到磁盘的策略，默认值是 1，表示每次都会调用<code>fsync</code>操作。这个参数还可以设置为 0 或者 2。0 表示事务提交时不进行写入重做日志操作，这个操作仅在 master thread 中完成，而在 master thread 中每一秒会进行一次<code>fsync</code>操作。2 表示事务提交时将重做日志写入重做日志文件，但仅写入文件系统的缓存中，不进行 fsync 操作。在这个设置下，当 MySQL 数据库发生宕机而操作系统不发生宕机时，并不会导致事务的丢失。但是当操作系统宕机时，重启数据库后会丢失未从文件系统缓存刷新到重做日志文件那部分事务。</p>
<p>下图是模拟插入 50 万行数据，参数为 1 是每插入一条就显示执行一次 COMMIT 操作，跟其他参数设置之间的数据库效率对比：</p>
<p><img src="http://nas.beritra.com:18081/uploads/big/d088781618cfc6c54fee66d97f5e098a.png" alt=""></p>
<p>虽然用户可以通过设置参数<code>innodb_flush_log_at_trx_commit</code>为 0 或 2 来提高事务提交的性能，但是需要牢记的事，这种设置方法丧失了事务的 ACID 特性。而针对上述存储过程，为了提高事务的提交性能，应该在将 50 万行数据插入表后进行一次 COMMIT 操作，而不是在每插入一条记录之后进行一次 COMMIT 操作。</p>
<p>在 MySQL 数据库中还有一种二进制日志（binlog），其用来进行 POINT-TIME（PIT）的恢复及主从复制（Replication）环境的建立。从表面上看其和重做日志非常相似，都是记录了对于数据库操作的日志。然而，从本质上来看，二者有着非常大的不同。</p>
<p>首先，重做日志是在 InnoDB 存储引擎层产生，而二进制日志是在 MySQL 数据库的上层产生的，并且二进制日志不仅仅对于 InnoDB 引擎，MySQL 数据库中的任何存储引擎对于数据库的更改都会产生二进制日志。</p>
<p>其次，两种日志记录的内容形式不同。MySQL 数据库上层的二进制日志是一种逻辑日志，其记录的是对应的 SQL 语句（注，这里不严谨，新版本的 MySQL 不完全是对应的 SQL）。而 InnoDB 存储引擎的重做日志在事务进行中不断地被写入，这表现为日志并不是随事务提交的顺序进行写入的。</p>
<h3 id="undo"><a href="#undo" class="headerlink" title="undo"></a>undo</h3><p>重做日志记录的事务的行为，可以很好地通过其对页进行“重做”操作。但是事务有时候还会进行回滚操作，这时就需要 undo。因此在对数据库在进行修改的时候，InnoDB 存储引擎不但会产生 redo，还会产生一定量的 undo。这样如果用户执行的事务或语句由于某种原因失败了，又或者用户用一条<code>ROLLBACK</code>语句请求回滚，就可以利用这些 undo 信息将数据回滚到修改之前的样子。</p>
<p>redo 存放在重做日志文件中，与 redo 不同，undo 存放在数据库内部的一个特殊段（segment）中，这个段称为 undo 段（undo segment）。undo 段位于共享表空间内。可以通过<code>py_innodb_page_info.py</code>工具来查看当前共享表空间中 undo 的数量。</p>
<p>用户通常对 undo 有这样的误解：undo 用于将数据库物理的恢复到执行语句或事务之前的样子——但事实并非如此。undo 是逻辑日志，因此只将数据库逻辑的恢复到原来的样子。所有修改都被逻辑地取消掉了，但是数据结构和页本身在回滚之后可能大不相同。这是因为在多用户并发系统中，可能会有数十、数百甚至数千个并发事务。数据库的主要任务就是协调堆数据记录的并发访问。比如，一个事务在修改当前一个页中某几条记录，同时还有别的事务在对同一个页中另几条记录进行修改。因此，不能将一个页回滚到事务刚开始的样子，因为这样会影响其他事务正在进行的工作。</p>
<p>例如，用户执行了一个 INSERT 10 万条记录的事务，这个事务会导致分配一个新的段，即表空间会增大。在用户执行<code>ROLLBACK</code>时，会将插入的事务进行回滚，但是表空间的大小不会因此收缩。因此，当 InnoDB 存储引擎回滚时，它实际上做的是与先前相反的工作。对于每个 INSERT ，InnoDB 存储引擎会完成一个 DELETE；对于每个 DELETE，InnoDB 存储引擎会执行一个 INSERT；对于每个 UPDATE，InnoDB 引擎会执行一个相反的 UPDATE，将修改前的行放进去。</p>
<p>除了回滚操作，undo 的另一个作用是 MVCC，即在 InnoDB 存储引擎中 MVCC 的实现是通过 undo 来完成。当用户读取一行记录时，若该记录已经被其他事务占用，当前事务可以通过 undo 读取之前的行版本信息，以此实现非锁定读取。</p>
<p>最后也是最重要的一点是，undo log 会产生 redo log，也就是 undo log 的产生会伴随着 redo log 的产生，这是因为 undo log 也需要持久性的保护。</p>
<h3 id="pruge"><a href="#pruge" class="headerlink" title="pruge"></a>pruge</h3><p>delete 和 update 操作可能不会直接删除原有的数据。假设有如下表 t：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE t(</span></pre></td></tr><tr><td class="code"><pre><span class="line">a INT，</span></pre></td></tr><tr><td class="code"><pre><span class="line">b VARCHAR(32)，</span></pre></td></tr><tr><td class="code"><pre><span class="line">PRIMARY KEY(a)，</span></pre></td></tr><tr><td class="code"><pre><span class="line">KEY(n)</span></pre></td></tr><tr><td class="code"><pre><span class="line">)ENGINE&#x3D;Innodb;</span></pre></td></tr></table></figure>

<p>对其执行 如下 SQL 语句：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DELETE FROM t WHERE a&#x3D;1;</span></pre></td></tr></table></figure>

<p>表 t 上列 a 有聚集索引，列 b 上有辅助索引。对于上述 delete 操作，仅仅是将主键列等于 1 的记录<code>delete flag</code>设置为 1，记录并没有被删除，即记录还存在于 B+ 树中。其次，对辅助索引上 a 等于 1，b等于 1 的记录同样没有做任何处理，甚至没有产生 undo log。而真正删除这样记录的操作其实被“延时”了，最终在 purge 操作中完成。</p>
<p>purge 用于最终完成 delete 和 update 操作。这样设计是因为 InnoDB 存储引擎支持 MVCC，所以记录不能在事务提交时立即进行处理。这时其他事务可能正在引用这行，故 InnoDB 存储引擎需要保存记录之前的版本。而是否可以删除改条记录通过 purge 来进行判断。若改行记录已经不被其他任何事务引用，那么就可以进行真正的 delete 操作。可见，purge 操作是清理之前的 delete 和 update 操作，故上述操作“最终”完成。而实际执行的操作为 delete 操作，清理之前行记录的版本。</p>
<h3 id="group-commit"><a href="#group-commit" class="headerlink" title="group commit"></a>group commit</h3><p>若事务为非只读事务，则每次事务提交时需要进行一次<code>fsync</code>操作，以保证重做日志都已经写入磁盘。当数据库发生宕机时，可以通过重做日志进行恢复。虽然固态硬盘的出现提高了磁盘的性能，然而磁盘的<code>fsync</code>性能是有限的。为了提高磁盘<code>fsync</code>的效率，当前数据库都提供了<code>group commit</code>的功能，即一次<code>fsync</code>可以刷新确保多个事务日志被写入文件。对于InnoDB 存储引擎来说，事务提交时会进行两个阶段的操作：</p>
<ol>
<li>修改内存中事务对应的信息，并且将日志写入重做日志缓冲。</li>
<li>调用<code>fsync</code>将确保日志都从重做日志缓冲个写入磁盘。</li>
</ol>
<p>步骤 2 相对于步骤 1 是一个较慢的过程，这是因为存储引擎需要与磁盘打交道。但当有事务进行这个过程时，其他事务可以进行步骤 1 的操作，正在提交的事务完成提交操作后，再次执行步骤 2 时，就可以将多个事务的重做日志通过一次<code>fsync</code>刷新到磁盘，这样就大大减少了磁盘的压力，从而提高了数据库的整体性能。对于写入或更新较为频繁的操作，<code>group commit</code>的效果尤为明显。</p>
<h2 id="事务控制语句"><a href="#事务控制语句" class="headerlink" title="事务控制语句"></a>事务控制语句</h2><p>在 MySQL 命令行的默认设置下，事务都是自动提交（auto commit）的，即执行 SQL 语句之后就会马上执行 COMMIT 操作。因此要显式的开启一个事务需要使用命令<code>BEGIN</code>、<code>START TRANSACTION</code>，或者执行命令<code>SET AUTOCOMMIT=0</code>，禁用当前会话的自动提交。每个数据库厂商自动提交的设置都不相同，每个 DBA 或开发人员需要非常明白这一点，这对之后的 SQL 编程会有非凡的意义，因此用户不能以之前的经验来判断 MySQL 数据库的运行方式。在具体介绍其含义之前，先看看有哪些事务控制语句：</p>
<ul>
<li><code>START TRANSACTION|BEGIN</code>：显式地开启一个事务。</li>
<li><code>COMMIT</code>：提交事务，等价于<code>COMMIT WORK</code>。</li>
<li><code>ROLLBACK</code>：回滚会结束用户的事务，并撤销正在进行的所有未提交的修改。等价于<code>ROLLBACK WORK</code></li>
<li><code>SAVEPOINT identifier</code>：<code>SAVEPOINT</code>允许在事务中创建一个保存点，一个事务中可以有多个保存点。</li>
<li><code>ROLLBACK TO[SAVEPOINT] identifier</code>：这个语句与<code>SAVEPOINT</code>命令一起使用。可以把事务回滚到标记点，而不回滚在此标记点之前的任何工作。例如可以发出两条<code>UPDATE</code>语句，后面跟一个<code>SAVEPOINT</code>，然后又是两条<code>DELETE</code>语句。如果执行<code>DELETE</code>语句期间出现了某种异常情况，并且捕获到了这个异常，同时发出了<code>ROLLBACK TO SAVEPOINT</code>命令，事务就会回滚到指定的<code>SAVEPOINT</code>，撤销<code>DELETE</code>完成的所有工作，而<code>UPDATE</code>语句完成的工作不受影响。</li>
<li><code>SET TRANSACTION</code>：这个语句用来设置事物的隔离级别。InnoDB 存储引擎提供的事务隔离级别有：<code>READ UNCOMMITTED</code>、<code>READ COMMITTED</code>、<code>REPEATABLE READ</code>、<code>SERIALISZABLE</code>。</li>
</ul>
<p><code>START TRANSACTION</code>、<code>BEGIN</code>语句都可以在 MySQL  命令行下显式地开启一个事务。但是在存储过程中，MySQL数据库的分析器会自动将<code>BEGIN</code>识别为<code>BEGIN END</code>，因此在存储过程中只能使用<code>START TRANSACTION</code>语句来开启一个事务。</p>
<p><code>COMMIT</code>和<code>COMMIT WORK</code>语句基本是一致的，都是用来提交事务。不同之处在于<code>COMMIT WORK</code>用来控制事务结束后的行为是<code>CHAIN</code>还是<code>RELEASE</code>的。如果是<code>CHAIN</code>方式，那么事务就变成了链事务。</p>
<p>InnoDB 存储引擎中的事务都是原子的，这说明下述两种情况：构成事务的每条语句都会提交（成为永久），或者所有语句都回滚。这种保护还延伸到单个的语句。一套语句要么完全成功，要么完全回滚（注意，这里说的是语句回滚）。因此一条语句失败并抛出异常时，并不会导致先前已经执行的语句自动回滚。所有的执行都会得到保留，必须由用户自己来决定是否对其进行提交或回滚的操作。</p>
<p>另一个容易犯的错误是<code>ROLLBACK TO SAVEPOINT</code>，虽然有<code>ROLLBACK</code>，但其实并不真正的结束一个事务，因此即使执行了<code>ROLLBACK TO SAVEPOINT</code>，之后也需要显式地运行<code>COMMIT</code>或<code>ROLLBACK</code>命令。</p>
<h2 id="隐式提交的-SQL-语句"><a href="#隐式提交的-SQL-语句" class="headerlink" title="隐式提交的 SQL 语句"></a>隐式提交的 SQL 语句</h2><p>以下 SQL 语句会产生一个隐式的提交操作，即执行完这些语句后，会有一个隐式的<code>COMMIT</code>操作。</p>
<ul>
<li>DDL 语句：<code>ALTER DATABASE...UPGRADE DATA DIRECTORY NAME，ALTER EVENT，ALTER PROCEDURE，ALTER TABLE，ALTER VIEW，CREATE DATABASE，CREATE ENENT，CREATE INDEX，CREATE PROCEDURE，CREATE TABLE，CREATE TRIGGER，CREATE VIEW，DROP DATABASE，DROP EVENT，DROP INDEX，DROP PROCEDURE，DROP TABLE，DROP TRIGGER，DROP VIEW，RENAME TABLE，TRAUNCATE TABLE</code></li>
<li>用来隐式地修改 MySQL 架构的操作：<code>CREATE USER、DROP USER、GRANT、RENAME USER、REVOKE、SET PASSWORD</code></li>
<li>管理语句：<code>ANALYZE TABLE、CACHE INDEX、CHECK TABLE、LOAD INDEX INTO CACHE、OPTIMEIZE TABLE、REPAIR TABLE</code>、</li>
</ul>
<p>另外需要注意的是，<code>TRUNCATE TABLE</code>语句是 DDL，因此虽然和对整张表执行<code>DELETE</code>的结果是一样的，但它不能回滚的。</p>
<h2 id="对于事务操作的统计"><a href="#对于事务操作的统计" class="headerlink" title="对于事务操作的统计"></a>对于事务操作的统计</h2><p>对于 InnoDB 存储引擎是支持事务的，因此 InnoDB 存储引擎的应用需要在考虑每秒请求数（Question Per Second，QPS）的同时，应该关注每秒事务处理的能力（Transaction Per Second，TPS）。</p>
<p>计算 TPS 的方法是（com_commit+com_rollback）/time。但是利用这种方法进行计算的前提是：所有的事务必须都是显式的提交，如果存在隐式地提交和回滚（默认 autocommit=1），不会计算到<code>com_commit</code>和<code>com_rollback</code>中。</p>
<h2 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h2><p>SQL 标准定义的四个隔离级别：</p>
<ul>
<li>READ UNCOMMITTED</li>
<li>READ COMMITTED</li>
<li>REPEATABLE READ</li>
<li>SERIALIZABLE</li>
</ul>
<p>InnoDB 存储引擎默认支持的隔离级别是 REPEATABLE READ，但与标准 SQL 不同的是，InnoDB 存储引擎在 REPEATABLE READ 事务隔离级别下，使用 Next-Key Lock 锁的算法，因此避免幻读的产生。所以说，InnoDB 存储引擎在默认的 REPEATABLE READ的事务隔离级别下，已经能完全保证事务的隔离性要求，即达到 SQL 标准的 SERIALIZABLE 隔离级别。</p>
<p>隔离级别越低，事务请求的锁越少或保持锁的时间就越短，这也是为什么大多数数据库的默认隔离级别是 READ COMMITTED。</p>
<p>大部分用户质疑 SERIALIZABLE 隔离级别带来的性能问题，但是两者的开销几乎是一样的，甚至 SERIALIZABLE 可能更优！因此在 InnoDB 存储引擎中选择 REPEATABLE READ 的事务隔离级别并不会有任何性能的损失。同样的，即使使用 READ COMMITTED 的隔离级别，用户也不会得到性能的大幅提升。</p>
<p>在 InnoDB 存储引擎中，可以使用以下命令来设置当前会话或全局的事务隔离级别：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SET [GLOBAL|SESSION] TRANSACTION ISOLATION LEVEL&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">READ UNCOMMITTED</span></pre></td></tr><tr><td class="code"><pre><span class="line">READ COMMITTED</span></pre></td></tr><tr><td class="code"><pre><span class="line">REPEATABLE READ</span></pre></td></tr><tr><td class="code"><pre><span class="line">SERIALIZABLE</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>如果想在 MySQL 数据库启动时就设置事务的默认隔离级别，那就需要修改 MySQL 的配置文件，在[mysqld]中添加如下行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[mysqld]</span></pre></td></tr><tr><td class="code"><pre><span class="line">transaction-isolation &#x3D; READ-COMMITTED</span></pre></td></tr></table></figure>

<p>查看当前会话的事务隔离级别，可以使用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT @@transaction_isolation\G;</span></pre></td></tr></table></figure>

<p>查看全局的事务隔离级别，可以使用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT @@global.transaction_isolation\G;</span></pre></td></tr></table></figure>

<blockquote>
<p>注意，MySQL 8.0 之前查询当前事务隔离级别的语句是<code>select @@tx_isolation</code>，之后是上面用的<code>select @@transaction_isolation</code></p>
</blockquote>
<p>在 SERIALIABLE 的隔离级别下，InnoDB 引擎会对每个 SELECT 语句后自动加上一个<code>LOCK IN SHARE MODE</code>，即为每个读取操作加一个共享锁。因此在这个事务隔离级别下，读占用了锁，对一致性的非锁定读不再予以支持。这时，事务隔离级别 SERIALIZABLE 符合数据库理论上的要求，即事务是 well-formed 的，并且是 two-phrased 的。</p>
<h2 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h2><h3 id="MySQL-数据库分布式事务"><a href="#MySQL-数据库分布式事务" class="headerlink" title="MySQL 数据库分布式事务"></a>MySQL 数据库分布式事务</h3><p>InnoDB 存储引擎提供了对 XA 事务的支持，并通过 XA 事务来支持分布式事务的实现。分布式事务指的是允许多个独立的事务资源（transaction resources）参与到一个全局事务中。事务资源通常是关系型数据库系统，但也可以是其他类型的资源。全局事务要求在其中的所有参与的事务要么都提交，要么都会滚，这对事务原有的 ACID 要求又有了提高。另外，在使用分布式事务时，InnoDB 存储引擎的事务隔离级别必须设置为 SERIALIZABLE。</p>
<p>XA 事务允许你不同数据库之间的分布式事务，如一台数据库是 MySQL 数据库的，另一台是 Oracle 的，有可能还有一台是 SQL SERVER 数据库的，只要参与到全局事务中的每个节点都支持 XA 事务。</p>
<p>XA 事务由一个或多个资源管理器（Resource  MAanagers）、一个事务管理器（Transaction Manager）以及一个应用程序（Application Program）组成。</p>
<ul>
<li>资源管理器：提供访问事务资源的方法。通常一个数据库就是一个资源管理器。</li>
<li>事务管理器：协调参与全局事务中的各个事务。需要和参与全局事务的所有资源管理器进行通信。</li>
<li>应用程序：定义事务的边界，指定全局事务中的操作。</li>
</ul>
<p>在 MySQL 数据库的分布式事务中，资源管理器就是 MySQL 数据库，事务管理器为连接 MySQL 服务器的客户端。下图显示了一个分布式事务的模型：</p>
<p><img src="http://nas.beritra.com:18081/uploads/big/376ba5d7b0a884ae37b62f1149ff7bea.png" alt=""></p>
<p>分布式事务使用两段式提交（two-phase commit）的方式。在第一阶段，所有参与全局事务的节点都开始准备（PREPARE），告诉事务管理器他们准备号提交了。在第二阶段，事务管理器告诉资源管理器执行<code>ROLLBACK</code>还是<code>COMMIT</code>。如果任何一个节点显示不能提交，则所有的节点都被告知需要回滚。可见与本地事务不同的是，分布式事务需要多一次 PREPARE 的操作，待收到所有节点的同意信息后，再进行<code>COMMIT</code>或是<code>ROLLBACK</code>操作。</p>
<h3 id="内部-XA-事务"><a href="#内部-XA-事务" class="headerlink" title="内部 XA 事务"></a>内部 XA 事务</h3><p>之前讨论的分布式事务是外部事务，即资源管理器是 MySQL 本身。在 MySQL 数据库中还存在另一种分布式事务，其在存储引擎与插件之间，又或者在存储引擎与存储引擎之间，称之为内部 XA 事务。】</p>
<p>最常见的内部 XA 事务存在于 binlog 与 InnoDB 存储引擎之间。由于复制的需要，因此目前绝大多数的数据库都开启了 binlog 功能。在事务提交时，先写二进制日志，再写 InnoDB 存储引擎的重做日志。对上述两个操作的要求也是原子的。即二进制日志和重做日志必须同时写入。若 二进制日志先写了，而在写入 InnoDB 存储引擎时发生了宕机，那么 slave 可能会接收到 master 传过去的二进制日志并执行，最终导致了主从不一致的情况。</p>
<p>为了解决这个问题，MySQL 数据库在 binlog 与 InnoDB 存储引擎之间采用 XA 事务。当事务提交的时候，InnoDB 存储引擎回西安做一个 PREPARE 操作，将事务的 xid 写入，接着二进制日志写入，入股偶在 InnoDB 存储引擎提交前，MySQL 数据库宕机了，那么 MySQL 数据库在重启后会先检查准备的 UXID 事务是否已经提交，若没有，则在存储引擎层再进行一次提交操作。如下图所示：</p>
<p><img src="http://nas.beritra.com:18081/uploads/big/400aead4e7edcec4690b9e6f5f1c296f.png" alt=""></p>
<h2 id="不好的事务习惯"><a href="#不好的事务习惯" class="headerlink" title="不好的事务习惯"></a>不好的事务习惯</h2><h3 id="在循环中提交"><a href="#在循环中提交" class="headerlink" title="在循环中提交"></a>在循环中提交</h3><p>有的开发人员习惯再循环中进行事务的提交，比如可能常写的一个存储过程：</p>
<p><img src="http://nas.beritra.com:18081/uploads/big/af386a3f56b941605de52eb437e33c32.png" alt=""></p>
<p>这个里面的<code>COMMIT</code>命令其实并不关键。因为 InnoDB 存储引擎默认自动提交，这也是经常被开发人员忽视的问题：</p>
<p><img src="http://nas.beritra.com:18081/uploads/big/60caac0b4782048229a8c172ec18b2d7.png" alt=""></p>
<p>其实无论上面哪个存储过程都存在一个问题，当发生错误的时候，数据库会停留在一个位置的位置。例如，用户需要插入 10000 条记录，但是当插入 5000 条时，发生了错误，这时前 5000 条记录都已经存放在数据库中，那应该怎么处理呐？另外一个问题性能问题，上面两个存储过程都不会比下面的存储过程更快，因为下面的存储过程将所有的<code>INSERT</code>都放在了一个事务中：</p>
<p><img src="http://nas.beritra.com:18081/uploads/big/adac784b49794e6d6b386295158a4c02.png" alt=""></p>
<p>第三种方法要快的多！这是因为每次提交都要写一次重做日志，存储过程 load1 和 load2 实际上写了 10000 次重做日志文件，而对存储过程 load3 来说，实际上只写了 1 次。</p>
<p>所以无论从何种角度出发，都不应该在一个循环中反复进行提交操作，无论是显示还是隐式的提交。</p>
<h3 id="使用自动提交"><a href="#使用自动提交" class="headerlink" title="使用自动提交"></a>使用自动提交</h3><p>使用自动提交不是一个好习惯，因为这会使初级 DBA 容易犯错，另外还可能是一些开发人员产生错误的理解。在编写程序开发时，最好把事务的控制权限交给开发人员，即在程序端进行事务的开始和结束。同时，开发人员必须了解是自动提交可能带来的问题。</p>
<h3 id="使用自动回滚"><a href="#使用自动回滚" class="headerlink" title="使用自动回滚"></a>使用自动回滚</h3><p>InnoDB 存储引擎支持通过定义一个 HANDLER 来进行自动事务的回滚操作，如在一个存储过程中发生了错误会自动对其进行回滚操作。因此很多开发人员喜欢在应用程序的存储过程中使用自动回滚操作。</p>
<p>在存储过程中使用自动回滚很容易丢失错误信息，所以应该在程序中控制而不是数据库中。在程序中控制事务的好处是用户可以得知发生错误的原因，然后根据发生的原因进一步调试程序。</p>
<h2 id="长事务"><a href="#长事务" class="headerlink" title="长事务"></a>长事务</h2><p>长事务（Loing-Lived Transaction），顾名思义，就是执行时间较长的事务，比如，对于银行系统中的数据库，每过一个阶段可能需要更新对应账户的利息。如果对应账户的数量非常大，例如对有 1 亿用户的表进行更新操作，可能需要非常长的时间来完成，可能需要一个小时，也可能需要 4、5 个小时，这取决于数据库的硬件配置。然而，由于事务的 ACID 特性，这个操作被封装在一个事务中完成。这就产生了一个问题，在执行过程中，当数据库、操作系统或者硬件发生问题的时候，重新开始事务的代价变得不可接受。数据库需要回滚所有已经发生的变化，而这个过程可能比产生这些变化的时间还要长。因此，对于长事务的问题，有时候可以通过转化为小批量（mini batch）的事务来进行处理。当事务发生错误时，只需要回滚一部分数据，然后接着上次已完成的事务继续进行。</p>
<p>由一个小地方还需要注意，要保证事务在处理工程中，没有其他的事务来更新表中的数据，需要人工加一个共享锁。</p>
<h2 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h2><p>关于 MVCC，感觉博客中好多解释是冲突的，干脆去看官网，以下内容直接粘贴的官网文档：</p>
<h3 id="InnoDB多版本"><a href="#InnoDB多版本" class="headerlink" title="InnoDB多版本"></a>InnoDB多版本</h3><p><code>InnoDB</code>是一个 <a href="https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_mvcc" target="_blank" rel="noopener">多版本的存储引擎</a>：它保留有关已更改行的旧版本的信息，以支持诸如并发和<a href="https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_rollback" target="_blank" rel="noopener">回滚</a>之类的事务功能 。此信息存储在表空间中的数据结构中，该数据结构称为 <a href="https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_rollback_segment" target="_blank" rel="noopener">回滚段</a>（出现在 Oracle 中类似的数据结构之后）。<code>InnoDB</code> 使用回滚段中的信息来执行事务回滚中所需的撤消操作。它还使用该信息来构建行的早期版本，以实现<a href="https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_consistent_read" target="_blank" rel="noopener">一致的读取</a>。</p>
<p>在内部的实现中，<code>InnoDB</code>向数据库中存储的每一行添加了三个字段。包括：</p>
<ul>
<li>一个 6 个字节的<code>DB_TRX_ID</code>字段，表示插入或更新该行的最后一个事务的事务标识符。同样，在内部用更新来实现删除，在更新操作的时候，行中的软删除标记位被标记为删除。</li>
<li>还包含一个 7 字节的 <code>DB_ROLL_PTR</code>字段，称为滚动指针。回滚指针指向写入回滚段的撤消日志（undo log）记录。如果行已更新，则撤消日志记录将保存了更新之前的全部信息，方便进行重建。</li>
<li>一个 6 字节的<code>DB_ROW_ID</code>字段包含一个行 ID，该行 ID 随着插入新行而单调增加。如果 <code>InnoDB</code>自动生成聚集索引，该索引包含行 ID 值。否则，该 <code>DB_ROW_ID</code>列不会出现在任何索引中。</li>
</ul>
<p>回滚段中的撤消日志分为插入撤销和更新撤消日志。插入撤消日志仅在事务回滚时才需要，并且在事务提交后可以立即将其丢弃。更新撤消日志也用于一致的读取中，但是只有在其没有了分配了快照的事务后，才可以被删除。（因为一致性读取可能需要使用更新撤消日志中的信息来构建数据库行的早期版本。）</p>
<p>定期提交您的事务，包括仅用于一致读取的事务。否则， <code>InnoDB</code>将无法丢弃更新撤消日志中的数据，并且回滚段可能会变得太大而填满表空间。</p>
<p>回滚段中的撤消日志记录的物理大小通常小于相应的插入或更新的行。您可以使用此信息来计算回滚段所需的空间。</p>
<p>在<code>InnoDB</code>多版本方案中，当您使用 SQL 语句删除行时，并不会立即将其从数据库中物理删除。<code>InnoDB</code>仅在丢弃那些删除操作的撤销记录时，才物理删除相应的行及其索引记录。此删除操作称为<a href="https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_purge" target="_blank" rel="noopener">purge</a>，它非常快，通常花费与执行删除操作的SQL语句相同的时间顺序。</p>
<p>如果您以大致相同的速率在表中以较小的批次插入和删除行，则由于所有“ 死 ”行，清除线程可能开始滞后并且表可能会变得越来越大 ，从而使所有内容都受磁盘约束而且非常慢。在这种情况下，请限制新行的操作，并通过调整<a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_max_purge_lag" target="_blank" rel="noopener"><code>innodb_max_purge_lag</code></a>系统变量来向清除线程分配更多资源 。有关更多信息，请参见<a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html" target="_blank" rel="noopener">第15.14节“ InnoDB启动选项和系统变量”</a>。</p>
<h3 id="多版本索引和二级索引"><a href="#多版本索引和二级索引" class="headerlink" title="多版本索引和二级索引"></a>多版本索引和二级索引</h3><p><code>InnoDB</code>多版本并发控制（MVCC）对二级索引的处理方式不同于聚簇索引。聚簇索引中的记录将就地更新，其隐藏的系统列指向撤消日志条目，可以从中重建记录的早期版本。与聚簇索引记录不同，辅助索引记录不包含隐藏的系统列，也不会就地更新。</p>
<p>更新二级索引列时，将对旧的二级索引记录进行删除标记，将新记录插入，并最终清除带有删除标记的记录。当二级索引记录被删除标记或二级索引页被较新的事务更新时，<code>InnoDB</code>在聚集索引中查找数据库记录。在聚集索引中，<code>DB_TRX_ID</code>检查记录的记录，如果在启动读取事务后修改了记录，则从撤消日志中检索记录的正确版本。</p>
<p>如果二级索引记录被标记为删除，或二级索引页被更新的事务更新， 则不使用<a href="https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_covering_index" target="_blank" rel="noopener">覆盖索引</a>技术。<code>InnoDB</code>在聚集索引中查找记录，而不是从索引结构中返回值。</p>
<p>但是，如果启用了 <a href="https://dev.mysql.com/doc/refman/8.0/en/index-condition-pushdown-optimization.html" target="_blank" rel="noopener">索引条件下推（ICP）</a>优化，并且<code>WHERE</code>只能使用索引中的字段来评估部分条件，则 MySQL 服务器仍会将<code>WHERE</code>条件的这一部分下推到存储引擎，并使用索引。如果找不到匹配的记录，则避免聚集索引查找。如果找到了匹配的记录，即使在删除标记的记录中，也要在 <code>InnoDB</code>聚簇索引中查找记录。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>我们了解了 InnoDB 存储引擎管理事务的许多方面。了解了事务如何工作以及如何使用。</p>
<p>事务必须遵循 ACID 特性，即 Atomicity（原子性）、Consistency（一致性）、Isolation（隔离性）和 Durability（持久性）</p>
<p>。隔离性通过锁来完成；原子性、一致性、隔离性通过 redo 和 undo 来完成。</p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>数据库</tag>
        <tag>事务</tag>
      </tags>
  </entry>
  <entry>
    <title>离线环境下安装高可用FastDFS</title>
    <url>/2019/12/01/FastDFS%E5%AE%89%E8%A3%85%E6%96%87%E6%A1%A3/</url>
    <content><![CDATA[<p>记录一次离线环境下安装高可用 FastDFS 的过程</p>
<a id="more"></a>

<h4 id="FastDFS安装文档"><a href="#FastDFS安装文档" class="headerlink" title="FastDFS安装文档"></a>FastDFS安装文档</h4><p>需准备2台机器（安装Centos7操作系统），A,B</p>
<p>A：安装tracker，storage（group1），nginx</p>
<p>B：安装tracker，storage（group2），nginx</p>
<p>默认选择A服务器的tracker作为leader，tracker为从</p>
<h4 id="1-安装libfastcommon包"><a href="#1-安装libfastcommon包" class="headerlink" title="1.安装libfastcommon包"></a>1.安装libfastcommon包</h4><ul>
<li><p>解压libfastcommon-1.0.40.tar.gz</p>
</li>
<li><p>cd libfastcommon-1.0.40   |      ./make.sh     |  ./make.sh install</p>
</li>
<li><p>ibfastcommon.so 默认安装到了/usr/lib64/libfastcommon.so，但是FastDFS主程序设置的lib目录是/usr/local/lib，所以此处重新设置软链接：</p>
<p>​     ln -s /usr/lib64/libfastcommon.so /usr/local/lib/libfastcommon.so</p>
</li>
</ul>
<h4 id="2-安装FastDFS"><a href="#2-安装FastDFS" class="headerlink" title="2.安装FastDFS"></a>2.安装FastDFS</h4><ul>
<li><p>解压fastdfs-5.11</p>
</li>
<li><p>cd fastdfs-5.11 | ./make.sh   | ./make.sh install </p>
</li>
<li><p>ln -s /usr/lib64/libfdfsclient.so /usr/local/lib/libfdfsclient.so</p>
</li>
<li><p>cd /etc/fdfs </p>
</li>
<li><p>对三个配置文件进行拷贝,备用</p>
<p>cp client.conf.sample client.conf</p>
<p>cp storage.conf.sample storage.conf</p>
<p>cp tracker.conf.sample tracker.conf</p>
</li>
<li><p>进入 fastdfs-5.11/conf目录,复制以下文件，http.conf和mime.types为了跟nginx模块整合使用，client.conf是fastdfs的客户端测试文件</p>
<p>cp http.conf /etc/fdfs/</p>
<p>cp mime.types /etc/fdfs/</p>
<p>cp client.conf /etc/fdfs/</p>
</li>
</ul>
<h4 id="3-安装tracker"><a href="#3-安装tracker" class="headerlink" title="3.安装tracker"></a>3.安装tracker</h4><ul>
<li><p>新建tracker的目录数据文件和日志文件  mkdir /home/face/FastDFS/tracker</p>
</li>
<li><p>编辑tracker配置文件/etc/fdfs/tracker.conf,主要配置参数如下：</p>
<p>port=22122</p>
<p>base_path= /home/face/FastDFS/tracker</p>
<p>work_thread=4  #最好和cpu核数保持一致</p>
<p>store_lookup=0 #选择上传文件模式 0代表group轮询 1指定特定group 2选择空间最大的group</p>
</li>
<li><p>通过命令启动tracker:  systemctl start fdfs_trackerd</p>
</li>
<li><p>查看/home/face/fastDFS/tracker目录下的data和logs目录，看是否启动成功</p>
</li>
<li><p>通过netstat命令查看端口监听情况：netstat -unltp|grep fdfs      检测22122</p>
</li>
</ul>
<h4 id="4-安装storage"><a href="#4-安装storage" class="headerlink" title="4.安装storage"></a>4.安装storage</h4><ul>
<li><p>新建storage的目录数据文件和日志文件  mkdir /home/face/FastDFS/storage     |     mkdir /home/face/FastDFS/storage/data</p>
</li>
<li><p>编辑storage配置文件/etc/fdfs/storage.conf，主要配置参数如下：</p>
<p>A机器：group_name=group1     B机器：group_name=group2</p>
<p>port=23000</p>
<p>base_path=/home/face/FastDFS/storage</p>
<p>store_path_count=1</p>
<p>store_path0=/home/face/FastDFS/storage/data</p>
<p>tracker_server=A机器ip:22122</p>
<p>tracker_server=B机器ip:22122</p>
</li>
<li><p>通过命令启动storage: systemctl start fdfs_storaged</p>
</li>
<li><p>查看/home/face/fastDFS/storage目录下的data和logs目录，看是否启动成功</p>
</li>
<li><p>看storage服务器是否已经登记到 tracker服务器，运行以下命令：/usr/bin/fdfs_monitor /etc/fdfs/storage.conf</p>
</li>
</ul>
<h4 id="5-安装fastdfs-nginx-module"><a href="#5-安装fastdfs-nginx-module" class="headerlink" title="5.安装fastdfs-nginx-module"></a>5.安装fastdfs-nginx-module</h4><p>上面的4个步骤已经可以上传和下载文件，但是fastdfs自己提供的http服务比较简洁，而且会出现数据同步不及时导致的读取数据不存在的情况，所以需要安装nginx模块来解决这个问题。</p>
<ul>
<li><p>解压fastdfs-nginx-module-master包</p>
</li>
<li><p>cd fastdfs-nginx-module/src   </p>
</li>
<li><p>复制文件到/etc/fdfs/目录下，<br>   cp mod_fastdfs.conf /etc/fdfs/</p>
</li>
<li><p>进入/etc/fdfs/,编辑mod_fastdfs.conf,主要配置参数如下：</p>
<p>base_path=/home/face/FastDFS/storage</p>
<p>tracker_server=A机器ip:22122</p>
<p>tracker_server=B机器ip:22122</p>
<p>A机器：group_name=group1     B机器：group_name=group2</p>
<p>url_have_group_name = true</p>
<p>store_path_count=1</p>
<p>store_path0=/home/face/FastDFS/storage/data</p>
<p>group_count = 2</p>
<p>[group1]<br>group_name=group1<br>storage_server_port=23000<br>store_path_count=1<br>store_path0=/home/face/FastDFS/storage/data<br>[group2]<br>group_name=group2<br>storage_server_port=23000<br>store_path_count=1<br>store_path0=/home/face/FastDFS/storage/data</p>
</li>
<li><p>进入fastdfs-nginx-module/src目录，编辑conf文件，修改如下：  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ngx_addon_name&#x3D;ngx_http_fastdfs_module</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">if test -n &quot;$&#123;ngx_module_link&#125;&quot;; then</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ngx_module_type&#x3D;HTTP</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ngx_module_name&#x3D;$ngx_addon_name</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ngx_module_incs&#x3D;&quot;&#x2F;usr&#x2F;include&#x2F;fastdfs &#x2F;usr&#x2F;include&#x2F;fastcommon&#x2F;&quot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ngx_module_libs&#x3D;&quot;-lfastcommon -lfdfsclient&quot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ngx_module_srcs&#x3D;&quot;$ngx_addon_dir&#x2F;ngx_http_fastdfs_module.c&quot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ngx_module_deps&#x3D;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    CFLAGS&#x3D;&quot;$CFLAGS -D_FILE_OFFSET_BITS&#x3D;64 -DFDFS_OUTPUT_CHUNK_SIZE&#x3D;&#39;256*1024&#39; -DFDFS_MOD_CONF_FILENAME&#x3D;&#39;\&quot;&#x2F;etc&#x2F;fdfs&#x2F;mod_fastdfs.conf\&quot;&#39;&quot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    . auto&#x2F;module</span></pre></td></tr><tr><td class="code"><pre><span class="line">else</span></pre></td></tr><tr><td class="code"><pre><span class="line">    HTTP_MODULES&#x3D;&quot;$HTTP_MODULES ngx_http_fastdfs_module&quot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    NGX_ADDON_SRCS&#x3D;&quot;$NGX_ADDON_SRCS $ngx_addon_dir&#x2F;ngx_http_fastdfs_module.c&quot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    CORE_INCS&#x3D;&quot;$CORE_INCS &#x2F;usr&#x2F;include&#x2F;fastdfs &#x2F;usr&#x2F;include&#x2F;fastcommon&#x2F;&quot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    CORE_LIBS&#x3D;&quot;$CORE_LIBS -lfastcommon -lfdfsclient&quot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    CFLAGS&#x3D;&quot;$CFLAGS -D_FILE_OFFSET_BITS&#x3D;64 -DFDFS_OUTPUT_CHUNK_SIZE&#x3D;&#39;256*1024&#39; -DFDFS_MOD_CONF_FILENAME&#x3D;&#39;\&quot;&#x2F;etc&#x2F;fdfs&#x2F;mod_fastdfs.conf\&quot;&#39;&quot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">fi</span></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="6-安装nginx"><a href="#6-安装nginx" class="headerlink" title="6.安装nginx"></a>6.安装nginx</h4><ul>
<li><p>解压nginx-1.14.2.tar.gz</p>
</li>
<li><p>cd nginx-1.14.2   </p>
</li>
<li><p>./configure  –prefix=/usr/local/nginx –add-module=/usr/src/fastdfs-nginx-module-master/src<br>make &amp;&amp; make install</p>
</li>
<li><p>编辑nginx.conf配置文件，配置如下：                         </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">upstream fdfs_group1 &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">     server A:8080 weight&#x3D;1 max_fails&#x3D;2 fail_timeout&#x3D;30s;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;  </span></pre></td></tr><tr><td class="code"><pre><span class="line"> </span></pre></td></tr><tr><td class="code"><pre><span class="line">upstream fdfs_group2 &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">     server B:8080 weight&#x3D;1 max_fails&#x3D;2 fail_timeout&#x3D;30s;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;  </span></pre></td></tr><tr><td class="code"><pre><span class="line"> </span></pre></td></tr><tr><td class="code"><pre><span class="line">include &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;conf&#x2F;conf.d&#x2F;*.conf;</span></pre></td></tr></table></figure>
</li>
<li><p>创建conf.d文件夹，进入该文件夹，创建tracker.conf和storage.conf</p>
</li>
<li><p>编辑tracker.conf</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">     listen 80;</span></pre></td></tr><tr><td class="code"><pre><span class="line">     server_name A;</span></pre></td></tr><tr><td class="code"><pre><span class="line">     </span></pre></td></tr><tr><td class="code"><pre><span class="line">     location ~ &#x2F;group1&#x2F;M00 &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		proxy_next_upstream http_502 http_504 error timeout invalid_header;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		proxy_pass http:&#x2F;&#x2F;fdfs_group1;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		expires 30d;</span></pre></td></tr><tr><td class="code"><pre><span class="line">     &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">     location ~ &#x2F;group2&#x2F;M00 &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		proxy_next_upstream http_502 http_504 error timeout invalid_header;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		proxy_pass http:&#x2F;&#x2F;fdfs_group2;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		expires 30d;</span></pre></td></tr><tr><td class="code"><pre><span class="line">     &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
</li>
<li><p>编辑stroage.conf</p>
<p>A机器：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	listen 8080;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	server_name A;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	location ~ &#x2F;group1&#x2F;M00 &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		root &#x2F;home&#x2F;face&#x2F;FastDFS&#x2F;storage&#x2F;data;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		index index.html index.htm; </span></pre></td></tr><tr><td class="code"><pre><span class="line">		ngx_fastdfs_module;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>B机器：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	listen 8080;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	server_name B;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	location ~ &#x2F;group2&#x2F;M00 &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		root &#x2F;home&#x2F;face&#x2F;FastDFS&#x2F;storage&#x2F;data;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		index index.html index.htm;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		ngx_fastdfs_module;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
</li>
<li><p>启动nginx：/usr/local/nginx/sbin/nginx</p>
</li>
</ul>
<h4 id="7-测试文件上传，浏览器访问数据"><a href="#7-测试文件上传，浏览器访问数据" class="headerlink" title="7.测试文件上传，浏览器访问数据"></a>7.测试文件上传，浏览器访问数据</h4><ul>
<li><p>编辑3个文件: echo “1111” &gt;&gt;/opt/1.txt &amp;&amp; echo “2222” &gt;&gt;/opt/2.txt &amp;&amp; echo “3333” &gt;&gt;/opt/3.txt</p>
</li>
<li><p>编辑client.conf文件，配置如下：</p>
<p>tracker_server=A机器ip:22122</p>
<p>tracker_server=B机器ip:22122</p>
</li>
<li><p>上传文件:</p>
</li>
</ul>
<p>　　/usr/local/bin/fdfs_test /etc/fdfs/client.conf upload 1.txt<br>　　/usr/local/bin/fdfs_test /etc/fdfs/client.conf upload 2.txt<br>　　/usr/local/bin/fdfs_test /etc/fdfs/client.conf upload 3.txt</p>
<ul>
<li>返回结果中会把上传完成的url 打印出来，复制URL在浏览器打开是否正常</li>
</ul>
]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>FastFDS</tag>
        <tag>高可用</tag>
        <tag>运维</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL基础知识总结</title>
    <url>/2019/12/01/MySQL%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>总结 MySQL 中的一些基础知识点。</p>
<a id="more"></a>

<p>本文尽量按照MySQL 8.0 版本的规则，但是很多参考书籍和资料还是基于 5.* 版本，可能有疏漏。</p>
<h2 id="SQL基础"><a href="#SQL基础" class="headerlink" title="SQL基础"></a>SQL基础</h2><p>SQL 全称是 Structure Query Language（结构化查询语言）。主要分为三个类别：</p>
<ul>
<li>DDL（Data Definiton Languages）语句：数据定义语言，这些语句定义的不同的数据段、数据库、表、列、索引等数据库对象的定义。常用的关键字包括<code>create</code>、<code>drop</code>、<code>alter</code>等。</li>
<li>DML（Data Manipulation Language）语句：数据操纵语句、用于添加、删除、更新和查询数据库记录，并检查数据完整性，常见的语句关键字包括<code>insert</code>、<code>delete</code>、<code>update</code>和<code>select</code>等。</li>
<li>DCL（Data Control Language）语句：数据控制语句，用于控制不同的数据段直接的许可和访问级别的语句。这些语句定义的数据库、表、字段、用户的访问权限和安全级别。主要语句关键字包括<code>grant</code>、<code>revoke</code>等。</li>
</ul>
<h3 id="DDL语句"><a href="#DDL语句" class="headerlink" title="DDL语句"></a>DDL语句</h3><h4 id="数据库增删改查"><a href="#数据库增删改查" class="headerlink" title="数据库增删改查"></a>数据库增删改查</h4><p>数据库创建的格式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE DATABASE db_name</span></pre></td></tr><tr><td class="code"><pre><span class="line">    [[DEFAULT] CHARACTER SET charset_name]</span></pre></td></tr><tr><td class="code"><pre><span class="line">    [[DEFAULT] COLLATE collation_name]</span></pre></td></tr></table></figure>

<p>常用的字符集参数为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create database test_database default CHARACTER SET utf8mb4 collate utf8mb4_unicode_ci;</span></pre></td></tr></table></figure>

<p>建议使用<code>utf8mb4</code>代替<code>utf8</code>，后者在存储比如<code>emoji</code>表情的时候会出错。<code>collate</code>关键字代表的是字符排序规则，会影响结果展示的顺序和<code>order by</code>等排序参数。</p>
<p>删除数据库语句：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">drop database db_name;</span></pre></td></tr></table></figure>

<p>要修改字符集参数的话：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER DATABASE db_name</span></pre></td></tr><tr><td class="code"><pre><span class="line">    [[DEFAULT] CHARACTER SET charset_name]</span></pre></td></tr><tr><td class="code"><pre><span class="line">    [[DEFAULT] COLLATE collation_name]</span></pre></td></tr></table></figure>

<p>MySQL似乎是没有提供对数据库重命名的方法。</p>
<p>如果想查看一共有多少个数据库，可以用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show databases;</span></pre></td></tr></table></figure>

<p>会显示包含系统库在内的所有数据库。</p>
<h4 id="表的增删改查"><a href="#表的增删改查" class="headerlink" title="表的增删改查"></a>表的增删改查</h4><p>创建表的语句比较复杂，直接把官网文档上的完整表述贴了过来：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE [TEMPORARY] TABLE [IF NOT EXISTS] tbl_name</span></pre></td></tr><tr><td class="code"><pre><span class="line">    (create_definition,...)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    [table_options]</span></pre></td></tr><tr><td class="code"><pre><span class="line">    [partition_options]</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">CREATE [TEMPORARY] TABLE [IF NOT EXISTS] tbl_name</span></pre></td></tr><tr><td class="code"><pre><span class="line">    [(create_definition,...)]</span></pre></td></tr><tr><td class="code"><pre><span class="line">    [table_options]</span></pre></td></tr><tr><td class="code"><pre><span class="line">    [partition_options]</span></pre></td></tr><tr><td class="code"><pre><span class="line">    [IGNORE | REPLACE]</span></pre></td></tr><tr><td class="code"><pre><span class="line">    [AS] query_expression</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">CREATE [TEMPORARY] TABLE [IF NOT EXISTS] tbl_name</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#123; LIKE old_tbl_name | (LIKE old_tbl_name) &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">create_definition:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    col_name column_definition</span></pre></td></tr><tr><td class="code"><pre><span class="line">  | &#123;INDEX|KEY&#125; [index_name] [index_type] (key_part,...)</span></pre></td></tr><tr><td class="code"><pre><span class="line">      [index_option] ...</span></pre></td></tr><tr><td class="code"><pre><span class="line">  | &#123;FULLTEXT|SPATIAL&#125; [INDEX|KEY] [index_name] (key_part,...)</span></pre></td></tr><tr><td class="code"><pre><span class="line">      [index_option] ...</span></pre></td></tr><tr><td class="code"><pre><span class="line">  | [CONSTRAINT [symbol]] PRIMARY KEY</span></pre></td></tr><tr><td class="code"><pre><span class="line">      [index_type] (key_part,...)</span></pre></td></tr><tr><td class="code"><pre><span class="line">      [index_option] ...</span></pre></td></tr><tr><td class="code"><pre><span class="line">  | [CONSTRAINT [symbol]] UNIQUE [INDEX|KEY]</span></pre></td></tr><tr><td class="code"><pre><span class="line">      [index_name] [index_type] (key_part,...)</span></pre></td></tr><tr><td class="code"><pre><span class="line">      [index_option] ...</span></pre></td></tr><tr><td class="code"><pre><span class="line">  | [CONSTRAINT [symbol]] FOREIGN KEY</span></pre></td></tr><tr><td class="code"><pre><span class="line">      [index_name] (col_name,...)</span></pre></td></tr><tr><td class="code"><pre><span class="line">      reference_definition</span></pre></td></tr><tr><td class="code"><pre><span class="line">  | check_constraint_definition</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">column_definition:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    data_type [NOT NULL | NULL] [DEFAULT &#123;literal | (expr)&#125; ]</span></pre></td></tr><tr><td class="code"><pre><span class="line">      [AUTO_INCREMENT] [UNIQUE [KEY]] [[PRIMARY] KEY]</span></pre></td></tr><tr><td class="code"><pre><span class="line">      [COMMENT &#39;string&#39;]</span></pre></td></tr><tr><td class="code"><pre><span class="line">      [COLLATE collation_name]</span></pre></td></tr><tr><td class="code"><pre><span class="line">      [COLUMN_FORMAT &#123;FIXED|DYNAMIC|DEFAULT&#125;]</span></pre></td></tr><tr><td class="code"><pre><span class="line">      [STORAGE &#123;DISK|MEMORY&#125;]</span></pre></td></tr><tr><td class="code"><pre><span class="line">      [reference_definition]</span></pre></td></tr><tr><td class="code"><pre><span class="line">      [check_constraint_definition]</span></pre></td></tr><tr><td class="code"><pre><span class="line">  | data_type</span></pre></td></tr><tr><td class="code"><pre><span class="line">      [COLLATE collation_name]</span></pre></td></tr><tr><td class="code"><pre><span class="line">      [GENERATED ALWAYS] AS (expr)</span></pre></td></tr><tr><td class="code"><pre><span class="line">      [VIRTUAL | STORED] [NOT NULL | NULL]</span></pre></td></tr><tr><td class="code"><pre><span class="line">      [UNIQUE [KEY]] [[PRIMARY] KEY]</span></pre></td></tr><tr><td class="code"><pre><span class="line">      [COMMENT &#39;string&#39;]</span></pre></td></tr><tr><td class="code"><pre><span class="line">      [reference_definition]</span></pre></td></tr><tr><td class="code"><pre><span class="line">      [check_constraint_definition]</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">data_type:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    (see Chapter 11, Data Types)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">key_part: &#123;col_name [(length)] | (expr)&#125; [ASC | DESC]</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">index_type:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    USING &#123;BTREE | HASH&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">index_option:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    KEY_BLOCK_SIZE [&#x3D;] value</span></pre></td></tr><tr><td class="code"><pre><span class="line">  | index_type</span></pre></td></tr><tr><td class="code"><pre><span class="line">  | WITH PARSER parser_name</span></pre></td></tr><tr><td class="code"><pre><span class="line">  | COMMENT &#39;string&#39;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  | &#123;VISIBLE | INVISIBLE&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">check_constraint_definition:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    [CONSTRAINT [symbol]] CHECK (expr) [[NOT] ENFORCED]</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">reference_definition:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    REFERENCES tbl_name (key_part,...)</span></pre></td></tr><tr><td class="code"><pre><span class="line">      [MATCH FULL | MATCH PARTIAL | MATCH SIMPLE]</span></pre></td></tr><tr><td class="code"><pre><span class="line">      [ON DELETE reference_option]</span></pre></td></tr><tr><td class="code"><pre><span class="line">      [ON UPDATE reference_option]</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">reference_option:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    RESTRICT | CASCADE | SET NULL | NO ACTION | SET DEFAULT</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">table_options:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    table_option [[,] table_option] ...</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">table_option:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    AUTO_INCREMENT [&#x3D;] value</span></pre></td></tr><tr><td class="code"><pre><span class="line">  | AVG_ROW_LENGTH [&#x3D;] value</span></pre></td></tr><tr><td class="code"><pre><span class="line">  | [DEFAULT] CHARACTER SET [&#x3D;] charset_name</span></pre></td></tr><tr><td class="code"><pre><span class="line">  | CHECKSUM [&#x3D;] &#123;0 | 1&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  | [DEFAULT] COLLATE [&#x3D;] collation_name</span></pre></td></tr><tr><td class="code"><pre><span class="line">  | COMMENT [&#x3D;] &#39;string&#39;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  | COMPRESSION [&#x3D;] &#123;&#39;ZLIB&#39;|&#39;LZ4&#39;|&#39;NONE&#39;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  | CONNECTION [&#x3D;] &#39;connect_string&#39;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  | &#123;DATA|INDEX&#125; DIRECTORY [&#x3D;] &#39;absolute path to directory&#39;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  | DELAY_KEY_WRITE [&#x3D;] &#123;0 | 1&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  | ENCRYPTION [&#x3D;] &#123;&#39;Y&#39; | &#39;N&#39;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  | ENGINE [&#x3D;] engine_name</span></pre></td></tr><tr><td class="code"><pre><span class="line">  | INSERT_METHOD [&#x3D;] &#123; NO | FIRST | LAST &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  | KEY_BLOCK_SIZE [&#x3D;] value</span></pre></td></tr><tr><td class="code"><pre><span class="line">  | MAX_ROWS [&#x3D;] value</span></pre></td></tr><tr><td class="code"><pre><span class="line">  | MIN_ROWS [&#x3D;] value</span></pre></td></tr><tr><td class="code"><pre><span class="line">  | PACK_KEYS [&#x3D;] &#123;0 | 1 | DEFAULT&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  | PASSWORD [&#x3D;] &#39;string&#39;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  | ROW_FORMAT [&#x3D;] &#123;DEFAULT|DYNAMIC|FIXED|COMPRESSED|REDUNDANT|COMPACT&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  | STATS_AUTO_RECALC [&#x3D;] &#123;DEFAULT|0|1&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  | STATS_PERSISTENT [&#x3D;] &#123;DEFAULT|0|1&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  | STATS_SAMPLE_PAGES [&#x3D;] value</span></pre></td></tr><tr><td class="code"><pre><span class="line">  | TABLESPACE tablespace_name [STORAGE &#123;DISK|MEMORY&#125;]</span></pre></td></tr><tr><td class="code"><pre><span class="line">  | UNION [&#x3D;] (tbl_name[,tbl_name]...)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">partition_options:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    PARTITION BY</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#123; [LINEAR] HASH(expr)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        | [LINEAR] KEY [ALGORITHM&#x3D;&#123;1|2&#125;] (column_list)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        | RANGE&#123;(expr) | COLUMNS(column_list)&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        | LIST&#123;(expr) | COLUMNS(column_list)&#125; &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    [PARTITIONS num]</span></pre></td></tr><tr><td class="code"><pre><span class="line">    [SUBPARTITION BY</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#123; [LINEAR] HASH(expr)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        | [LINEAR] KEY [ALGORITHM&#x3D;&#123;1|2&#125;] (column_list) &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      [SUBPARTITIONS num]</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ]</span></pre></td></tr><tr><td class="code"><pre><span class="line">    [(partition_definition [, partition_definition] ...)]</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">partition_definition:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    PARTITION partition_name</span></pre></td></tr><tr><td class="code"><pre><span class="line">        [VALUES</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#123;LESS THAN &#123;(expr | value_list) | MAXVALUE&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            |</span></pre></td></tr><tr><td class="code"><pre><span class="line">            IN (value_list)&#125;]</span></pre></td></tr><tr><td class="code"><pre><span class="line">        [[STORAGE] ENGINE [&#x3D;] engine_name]</span></pre></td></tr><tr><td class="code"><pre><span class="line">        [COMMENT [&#x3D;] &#39;string&#39; ]</span></pre></td></tr><tr><td class="code"><pre><span class="line">        [DATA DIRECTORY [&#x3D;] &#39;data_dir&#39;]</span></pre></td></tr><tr><td class="code"><pre><span class="line">        [INDEX DIRECTORY [&#x3D;] &#39;index_dir&#39;]</span></pre></td></tr><tr><td class="code"><pre><span class="line">        [MAX_ROWS [&#x3D;] max_number_of_rows]</span></pre></td></tr><tr><td class="code"><pre><span class="line">        [MIN_ROWS [&#x3D;] min_number_of_rows]</span></pre></td></tr><tr><td class="code"><pre><span class="line">        [TABLESPACE [&#x3D;] tablespace_name]</span></pre></td></tr><tr><td class="code"><pre><span class="line">        [(subpartition_definition [, subpartition_definition] ...)]</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">subpartition_definition:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    SUBPARTITION logical_name</span></pre></td></tr><tr><td class="code"><pre><span class="line">        [[STORAGE] ENGINE [&#x3D;] engine_name]</span></pre></td></tr><tr><td class="code"><pre><span class="line">        [COMMENT [&#x3D;] &#39;string&#39; ]</span></pre></td></tr><tr><td class="code"><pre><span class="line">        [DATA DIRECTORY [&#x3D;] &#39;data_dir&#39;]</span></pre></td></tr><tr><td class="code"><pre><span class="line">        [INDEX DIRECTORY [&#x3D;] &#39;index_dir&#39;]</span></pre></td></tr><tr><td class="code"><pre><span class="line">        [MAX_ROWS [&#x3D;] max_number_of_rows]</span></pre></td></tr><tr><td class="code"><pre><span class="line">        [MIN_ROWS [&#x3D;] min_number_of_rows]</span></pre></td></tr><tr><td class="code"><pre><span class="line">        [TABLESPACE [&#x3D;] tablespace_name]</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">query_expression:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    SELECT ...   (Some valid select or union statement)</span></pre></td></tr></table></figure>

<p>可以看到创建表的时候，主要分为三个部分，包括创建定义、表选项、分区选项等，实际上大多数时候用不到这么多功能。</p>
<p>不手动指定的话，模式使用<code>InnoDB</code>作为数据库引擎，<code>InnoDB</code>最大支持40亿张表。</p>
<p>一个简单的创建语句：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create table test_table</span></pre></td></tr><tr><td class="code"><pre><span class="line">(</span></pre></td></tr><tr><td class="code"><pre><span class="line">    id    int not null auto_increment primary key,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    name  varchar(20),</span></pre></td></tr><tr><td class="code"><pre><span class="line">    class varchar(20),</span></pre></td></tr><tr><td class="code"><pre><span class="line">    age   int</span></pre></td></tr><tr><td class="code"><pre><span class="line">)engine&#x3D;InnoDB character set utf8mb4;</span></pre></td></tr></table></figure>

<p>创建完成后，可以使用<code>desc</code>关键字查看表结构：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">desc tablename;</span></pre></td></tr></table></figure>

<p><code>desc</code>命令输出的信息相对比较简单，可以使用如下语句查看详细的建表语句：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show create table tablename;</span></pre></td></tr></table></figure>

<p>修改表结构使用<code>alter table</code>语句：</p>
<ul>
<li><p>修改表类型：<code>ALTER TABLE table_name MODIFY [COLUMN] column_definition [FIRST|AFTER colname]</code></p>
</li>
<li><p>增加表字段：<code>ALTER TABLE table_name ADD [COLUMN] column_definition [FIRST|AFTER col_name]</code></p>
</li>
<li><p>删除表字段：<code>ALTER TABLE table_name DROP [COLUMN] col_name</code></p>
</li>
<li><p>修改字段名：<code>ALTER TABLE tablename CHANGE [COLUMN] old_col_name column_definition [FIRST|AFTER col_name]</code></p>
</li>
<li><p>修改字段排列顺序：前面介绍的的字段增加和修改语法(ADD/CNAHGE/MODIFY)中,都有一个可选项 first|after<br>column_name,这个选项可以用来修改字段在表中的位置,默认 ADD 增加的新字段是加在<br>表的最后位置,而 CHANGE/MODIFY 默认都不会改变字段的位置。</p>
</li>
<li><p>重命名表，老版本的MySQL一般使用：<code>ALTER TABLE test_table RENAME to test_table02;</code></p>
<p>MySQL 8.0中支持<code>rename</code>关键字：<code>rename table test_table02 to test_table;</code></p>
</li>
</ul>
<h3 id="DML语句"><a href="#DML语句" class="headerlink" title="DML语句"></a>DML语句</h3><h4 id="插入记录"><a href="#插入记录" class="headerlink" title="插入记录"></a>插入记录</h4><p>表创建好后,就可以往里插入记录了,插入记录的基本语法如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">INSERT INTO tablename (field1,field2,......fieldn) VALUES(value1,value2,......valuesn);</span></pre></td></tr></table></figure>

<h4 id="更新记录"><a href="#更新记录" class="headerlink" title="更新记录"></a>更新记录</h4><p>对于表里的记录值,可以通过 update 命令进行更改,语法如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">UPDATE tablename SET field1&#x3D;value1,field2.&#x3D;value2,......fieldn&#x3D;valuen [WHERE CONDITION]</span></pre></td></tr></table></figure>

<h4 id="删除记录"><a href="#删除记录" class="headerlink" title="删除记录"></a>删除记录</h4><p>如果记录不再需要,可以用 delete 命令进行删除,语法如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DELETE FROM tablename [WHERE CONDITION]</span></pre></td></tr></table></figure>

<h4 id="查询记录"><a href="#查询记录" class="headerlink" title="查询记录"></a>查询记录</h4><p>SELECT 的语法很复杂,所有这里只介绍最基本的语法:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM tablename [WHERE CONDITION]</span></pre></td></tr></table></figure>

<p>太复杂的就不重复了，这些都是基础内容，网上的教程一大把。</p>
<h3 id="DCL语句"><a href="#DCL语句" class="headerlink" title="DCL语句"></a>DCL语句</h3><p>DCL 语句主要是 DBA 用来管理系统中的对象权限时所使用,一般的开发人员很少使用。只记录几条经常用的吧。</p>
<p>这里经常遇到的就是MySQL 8.0和之前版本的不一致，往往在网上搜到一个命令，拿过来不能用，MySQL 8.0的变动以下几个方面：</p>
<h4 id="验证插件和密码加密方式的变化"><a href="#验证插件和密码加密方式的变化" class="headerlink" title="验证插件和密码加密方式的变化"></a>验证插件和密码加密方式的变化</h4><p>在 MySQL 8.0 中，<code>caching_sha2_password</code> 是默认的身份验证插件而不是之前版本的 <code>mysql_native_password</code>，默认的密码加密方式是 <code>SHA2</code> 。</p>
<h4 id="用户授权和修改密码"><a href="#用户授权和修改密码" class="headerlink" title="用户授权和修改密码"></a>用户授权和修改密码</h4><p>之前版本：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GRANT ALL PRIVILEGES ON *.* TO &#96;mike&#96;@&#96;%&#96; IDENTIFIED BY &#39;000000&#39; WITH GRANT OPTION;</span></pre></td></tr></table></figure>

<p>MySQL 8.0版本中正确的授权语句：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE USER &#39;mike&#39;@&#39;%&#39; IDENTIFIED BY &#39;000000&#39;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">GRANT ALL ON *.* TO &#39;mike&#39;@&#39;%&#39; WITH GRANT OPTION;</span></pre></td></tr></table></figure>

<p>可以看到，创建用户和授权是分开的，不再能一个语句搞定。</p>
<p>修改密码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED WITH mysql_native_password BY &#39;新密码&#39;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">FLUSH PRIVILEGES;</span></pre></td></tr></table></figure>

<p>也可以使用mysqladmin命令:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mysqladmin -u root -p password 新密码</span></pre></td></tr></table></figure>

<p>还有很多其他内容，作为开发不用完全掌握，可以详见这个博文：<a href="https://juejin.im/post/5b6eec2cf265da0f5e3315a6" target="_blank" rel="noopener">MySQL 8.0用户和角色管理</a></p>
<h2 id="MySQL数据类型"><a href="#MySQL数据类型" class="headerlink" title="MySQL数据类型"></a>MySQL数据类型</h2><h3 id="数值类型"><a href="#数值类型" class="headerlink" title="数值类型"></a>数值类型</h3><p>MySQL 支持所有标准 SQL 中的数值类型,其中包括严格数值类型(INTEGER、SMALLINT、DECIMAL 和 NUMERIC),以及近似数值数据类型(FLOAT、REAL 和 DOUBLE PRECISION),并在此基础上做了扩展。扩展后增加了TINYINT、MEDIUMINT 和 BIGINT 这 3 种长度不同的整型,并增加了 BIT 类型,用来存放位数据。</p>
<h4 id="整型数据"><a href="#整型数据" class="headerlink" title="整型数据"></a>整型数据</h4><p>对于整型数据,MySQL 还支持在类型名称后面的小括号内指定显示宽度,例如 int(5)表示当数值宽度小于 5 位的时候在数字前面填满宽度,如果不显示指定宽度则默认为 int(11)，一般配合 zerofill 使用。</p>
<p>设置了宽度限制后,如果插入大于宽度限制的值,不会对插入的数据有任何影响,还是按照类型的实际精度进行保存。</p>
<h4 id="小数"><a href="#小数" class="headerlink" title="小数"></a>小数</h4><p>对于小数的表示,MySQL 分为两种方式:浮点数和定点数。浮点数包括 float(单精度)和 double(双精度),而定点数则只有 decimal 一种表示。定点数在 MySQL 内部以字符串形式存放,比浮点数更精确,适合用来表示货币等精度高的数据。</p>
<p>浮点数和定点数都可以用类型名称后加“(M,D)”的方式来进行表示,“(M,D)”表示该值一共显示 M 位数字(整数位+小数位),其中 D 位位于小数点后面,M 和 D 又称为精度和标度。</p>
<p>由于float和double分别以32位和64位存储，所以实际上是可能产生精度丢失的。比如一个float类型的列，插入0.123456789的时候，实际存储到数据库的只是近似值0.123457,，当位数更多的时候这个问题更明显，比如分别向float和double类型的列中插入987654321.123456789，会得到987654000和987654321.1234568。</p>
<p>所以想要存储高精度、准确的数字，还是需要用decimal类型。</p>
<h3 id="日期时间类型"><a href="#日期时间类型" class="headerlink" title="日期时间类型"></a>日期时间类型</h3><p>MySQL中的事件类型有：<code>DATE</code>、<code>DATETIME</code>、<code>TIMESTAMP</code>、<code>TIME</code>、<code>YEAR</code></p>
<p>这些数据类型的主要区别如下:</p>
<ul>
<li>如果要用来表示年月日,通常用 DATE 来表示。</li>
<li>如果要用来表示年月日时分秒,通常用 DATETIME 表示。</li>
<li>如果只用来表示时分秒,通常用 TIME 来表示。</li>
<li>如果需要经常插入或者更新日期为当前系统时间,则通常使用 TIMESTAMP 来表示。TIMESTAMP 值返回后显示为“YYYY-MM-DD HH:MM:SS”格式的字符串,显示宽度固定为 19 个字符。如果想要获得数字值,应在 TIMESTAMP 列添加+0。</li>
<li>如果只是表示年份,可以用 YEAR 来表示,它比 DATE 占用更少的空间。YEAR 有 2 位或4 位格式的年。默认是 4 位格式。在 4 位格式中,允许的值是 1901<del>2155 和 0000。在2 位格式中,允许的值是 70</del>69,表示从 1970~2069 年。 MySQL 以 YYYY 格式显示 YEAR值。</li>
</ul>
<h3 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h3><p>MySQL 包括了 CHAR、VARCHAR、BINARY、VARBINARY、BLOB、TEXT、ENUM 和 SET 等多种字符串类型。下面的表详细列出了这些字符类型的比较。</p>
<p><img src="http://nas.beritra.com:18081/uploads/big/b64c2e300c0f200ee55c674e4d113886.png" alt=""></p>
<h4 id="CHAR和VCHAR类型"><a href="#CHAR和VCHAR类型" class="headerlink" title="CHAR和VCHAR类型"></a>CHAR和VCHAR类型</h4><p>CHAR 和 VARCHAR 很类似,都用来保存 MySQL 中较短的字符串。二者的主要区别在于存储方式的不同：CHAR 列的长度固定为创建表时声明的长度，长度可以为从 0<del>255 的任何值；而 VARCHAR 列中的值为可变长字符串，长度可以指定为0</del>65535( 5.0.3以后)之间的值。在检索的时候，CHAR 列删除了尾部的空格，而 VARCHAR 则保留这些空格。</p>
<h4 id="BINARY-和-VARBINARY-类型"><a href="#BINARY-和-VARBINARY-类型" class="headerlink" title="BINARY 和 VARBINARY 类型"></a>BINARY 和 VARBINARY 类型</h4><p>BINARY 和 VARBINARY 类似于 CHAR 和 VARCHAR,不同的是它们包含二进制字符串而不包含非二进制字符串。</p>
<h4 id="ENUM-类型"><a href="#ENUM-类型" class="headerlink" title="ENUM 类型"></a>ENUM 类型</h4><p>ENUM 中文名称叫枚举类型，它的值范围需要在创建表时通过枚举方式显式指定，对 1<del>255 个成员的枚举需要 1 个字节存储；对于 255</del>65535 个成员，需要 2 个字节存储。最多允许有 65535 个成员。</p>
<h4 id="SET-类型"><a href="#SET-类型" class="headerlink" title="SET 类型"></a>SET 类型</h4><p>Set 和 ENUM 类型非常类似，也是一个字符串对象，里面可以包含 0~64 个成员。根据成员的不同，存储上也有所不同。</p>
<ul>
<li>1~8 成员的集合,占 1 个字节。</li>
<li>9~16 成员的集合,占 2 个字节。</li>
<li>17~24 成员的集合,占 3 个字节。</li>
<li>25~32 成员的集合,占 4 个字节。</li>
<li>33~64 成员的集合,占 8 个字节。</li>
</ul>
<h3 id="其他类型"><a href="#其他类型" class="headerlink" title="其他类型"></a>其他类型</h3><p>MySQL 8中还支持多种空间类型，应该是用来存储地理信息之类的结构化信息的，但是没找到太多中文资料，平时也没用过，就不误人子弟了。</p>
<p>另外还有新增的JSON类型支持。</p>
<h4 id="创建JSON字段"><a href="#创建JSON字段" class="headerlink" title="创建JSON字段"></a>创建JSON字段</h4><p>创建JSON类型的字段很简单，跟其他数据结构没什么区别：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE t1 (jdoc JSON);</span></pre></td></tr></table></figure>

<h4 id="插入JSON"><a href="#插入JSON" class="headerlink" title="插入JSON"></a>插入JSON</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">INSERT INTO t1 VALUES(&#39;&#123;&quot;key1&quot;: &quot;value1&quot;, &quot;key2&quot;: &quot;value2&quot;&#125;&#39;);</span></pre></td></tr></table></figure>

<p>数据库会对JSON的格式进行校验，如果插入错误的格式会报错。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; INSERT INTO t1 VALUES(&#39;[1, 2,&#39;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">ERROR 3140 (22032) at line 2: Invalid JSON text:</span></pre></td></tr><tr><td class="code"><pre><span class="line">&quot;Invalid value.&quot; at position 6 in value (or column) &#39;[1, 2,&#39;.</span></pre></td></tr></table></figure>

<h4 id="查询JSON"><a href="#查询JSON" class="headerlink" title="查询JSON"></a>查询JSON</h4><p>查询 json 中的数据用 column-&gt;path 的形式，其中对象类型 path 这样表示 $.path, 而数组类型则是 $[index]</p>
<p>查询testproject表student字段中json对象id为1的记录：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM testproject WHERE student-&gt;&#39;$.id&#39;&#x3D; 1;</span></pre></td></tr></table></figure>

<p>查询testproject表student字段中json对象id为1或者5的记录：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM testproject WHERE student-&gt;&#39;$.id&#39; in (1,5);</span></pre></td></tr><tr><td class="code"><pre><span class="line">SELECT * FROM testproject WHERE student-&gt;&#39;$.id&#39; &#x3D; 1 or student-&gt;&#39;$.id&#39; &#x3D; 5;</span></pre></td></tr></table></figure>

<h4 id="更新数据"><a href="#更新数据" class="headerlink" title="更新数据"></a>更新数据</h4><p>MySQL 并不支持 column-&gt;path 的形式进行更新操作。如果是整个 json 更新的话，和插入时类似的。如果需要更新JSON中的某个值，需要用系统提供的函数：</p>
<ul>
<li>json_array_append：在json后面追加</li>
<li>json_array_insert：在指定下标插入</li>
<li>json_replace：只替换已经存在的旧值，不存在则忽略</li>
<li>json_set：替换旧值，并插入不存在的新值</li>
<li>json_insert：插入新值，但不替换已经存在的旧值</li>
<li>json_remove：删除元素</li>
</ul>
<p>这部分详细操作可以参考官方文档<a href="https://dev.mysql.com/doc/refman/8.0/en/json.html" target="_blank" rel="noopener">The JSON Data Type</a>和博客<a href="https://zhuanlan.zhihu.com/p/89873632" target="_blank" rel="noopener">mysql支持原生json使用说明</a></p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>InnoDB 表结构</title>
    <url>/2019/11/24/InnoDB%E8%A1%A8%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<p>本文大部分内容摘抄自《MySQL技术内幕（InnoDB存储引擎）第二版》，小部分来源于自己理解和网络博客，由于书比较旧，网络博客也未必准确，我尽量对文中内容进行验证和对比 MySQL 官网文档，但仍然有可能有疏漏。</p>
<a id="more"></a>

<h2 id="索引组织表"><a href="#索引组织表" class="headerlink" title="索引组织表"></a>索引组织表</h2><p>在 InnoDB 存储引擎中，表都是根据主键顺序组织存放的，这种存储方式的表成为索引组织表（Index Organized table）。在 InnoDB 存储引擎表中，每张表都有个主键（Primary Key），如果在创建表的时候没有显式地定义主键，则 InnoDB 会按照以下方式选择或创建主键：</p>
<ul>
<li>首次按判断表中是否有非空的唯一索引（Unique NOT NULL），如果有，则该列为主键。</li>
<li>如果没有，InnoDB 存储引擎会自动创建一个 6 字节大小的指针。</li>
</ul>
<blockquote>
<p> 当表中有多个非空唯一索引的时候，InnoDB 存储引擎将选择建表的时候第一个定义的非空唯一索引作为主键。注意这里是定义索引的顺序，而不是建表的时候列的顺序。</p>
</blockquote>
<h2 id="InnoDB-逻辑存储结构"><a href="#InnoDB-逻辑存储结构" class="headerlink" title="InnoDB 逻辑存储结构"></a>InnoDB 逻辑存储结构</h2><p>从 InnoDB 存储应引擎的存储结构来看，所有的数据都被逻辑的存放在一个空间中，成为表空间（tablespace）。表空间又由段（segment）、区（extent）、页（page）组成。页在一些文档中也成为块（block），InnoDB存储引擎的逻辑存储结构大致如图：</p>
<p><img src="http://nas.beritra.com:18081/uploads/big/6083671fe7d547fd2a8fd496b5bb0904.png" alt=""></p>
<h3 id="表空间"><a href="#表空间" class="headerlink" title="表空间"></a>表空间</h3><p>表空间可以看做是 InnoDB 存储引擎逻辑结构的最高层，所有的数据都存放在表空间中。默认情况下 InnoDB 存储引擎有一个共享表空间 ibdata1，所有的数据都存放在这个表空间中。如果用户开启了参数<code>innodb_fiule_per_table</code>，则每张表内的数据可以单独放在一个表空间中。</p>
<blockquote>
<p>即使启用了<code>innodb_fiule_per_table</code>，每张表的表空间内从存放的也只是数据、索引和插入缓冲Bitmap页，其他类型的数据比如回滚（undo）、插入缓冲索引页、系统事务信息、二次写缓冲（Double write buffer）等还是存放在原有共享表空间。</p>
</blockquote>
<h3 id="段"><a href="#段" class="headerlink" title="段"></a>段</h3><p>上面的图已经显示了表空间是由各个段组成的，常见的段有数据段、索引段、回滚段等。因为前面已经介绍过了 InnoDB 存储引擎表是索引组织（index organized）的，因此数据即索引，索引即数据。那么数据段即 B+ 树的叶子节点（图中的 Leaf node segment），索引段即 B+ 树中的非索引节点（图中的Non-leaf node segment）。回滚段较为特殊。</p>
<h3 id="区"><a href="#区" class="headerlink" title="区"></a>区</h3><p>区是由连续的页组成的空间，在任何情况下，每个区的大小都为 1MB。为了保证区中页的连续性，InnoDB 存储引擎一次从磁盘中申请 4~5 个区。在默认情况下，InnoDB 存储引擎页的大小为 16KB，即一个区中一共有 64 个连续的页。</p>
<p>InnoDB 1.0.x 版本开始引入压缩页，即每个夜的大小可以通过<code>KEY_BLOCK_SIZE</code>设置为 2K、4K、8K，因此每个区对应页的数量就应该是 512、256、128。</p>
<p>InnoDB 1.2.x 版本新增了参数 <code>innodb_page_size</code>，通过该参数可以将默认页的大小设置为 4K、8K，但是页中的数据库不是压缩。这是区中页的数量同样页是 256、128。总之，不论页的大小怎么变化，区的大小总为 1M。</p>
<h3 id="页"><a href="#页" class="headerlink" title="页"></a>页</h3><p>同大多数数据库一样，InnoDB 有页（Page）的概念（也可以称之为块），页是 InnoDB 磁盘管理的最小单位。</p>
<p>在 InnoDB 存储引擎中，常见的页类型有：</p>
<ul>
<li>数据页（B-tree Node）</li>
<li>undo 页（undo Log Page）</li>
<li>系统页（System Page）</li>
<li>事务数据页（Transaction system Page）</li>
<li>插入缓冲位图页（Insert Buffer Bitmap）</li>
<li>插入缓冲空闲列表页（Inser Buffer Free List）</li>
<li>未压缩的二进制大对象页（Uncompressed BLOB Page）</li>
<li>压缩的二进制大对象页（compressed BLOB Page）</li>
</ul>
<h3 id="行"><a href="#行" class="headerlink" title="行"></a>行</h3><p>InnoDB 存储引擎是面向列的（row-oriented），也就是说数据是按行进行存放的。每个页存放的行记录也是有硬性规定的，最多允许存放16KB/2-200行记录，即7992行。</p>
<h2 id="InnoDB-行记录格式"><a href="#InnoDB-行记录格式" class="headerlink" title="InnoDB 行记录格式"></a>InnoDB 行记录格式</h2><p>InnoDB 引擎和大多数数据库一样，记录以行的形式存储。这意味这页中保存着表中一行行的数据。在 InnoDB 1.0.x 版本之前，InnoDB 存储引擎提供了 Compact 和 Redundant 两种格式来存放行记录数据，这也是目前使用最多的一种格式。Redundant 格式是为了兼容之前版本而保留的，MySQL 5.1 之后的版本默认为 Compact 行格式。可以使用命令<code>SHOW TABLE STATUS LIKE &#39;table_name&#39;</code>来查看当前表使用的行格式。（由于书比较旧，我在 MySQL 官网上看到其实不止这两种格式，而默认的格式为 DYNAMIC，具体如下：</p>
<p><img src="http://nas.beritra.com:18081/blog/202005/c87e9baa9a9111ea99b000d861792df0.png" alt=""></p>
<h3 id="Compact-行记录格式"><a href="#Compact-行记录格式" class="headerlink" title="Compact 行记录格式"></a>Compact 行记录格式</h3><p>Compact 行记录格式的设计目标是高效的存储数据，简单来说就是一个页中存放的行数据越多，性能就越高。下图是详细的存储格式：</p>
<p><img src="http://nas.beritra.com:18081/uploads/big/090c385542dcfeb6fdabc2520ffaafd0.png" alt=""></p>
<p>可以看到，Compact 行记录的格式首部是一个非 NULL 变长字段长度列表，并且是按照列的顺序逆序放置的，长度为：</p>
<ul>
<li>若列的长度小于 255 字节，则用 1 字节表示；</li>
<li>若大于 255 个字节，用 2 字节表示。</li>
</ul>
<p>变长字段的长度不可以超过两个字节，因为 VARCHAR 类型的最大长度限制为 65535。变长字段之后的第二个部分是 NULL 标志位，该位指示了该位数据中是否有 NULL 值，有则用 1 表示。接下来的部分是记录头信息（record header），固定占用 5 字节（40位），每位的含义如下：</p>
<p><img src="http://nas.beritra.com:18081/uploads/big/78f4e0e0dc3bd05909f06abf44a56f4b.png" alt=""></p>
<p>最后的部分就是实际存储每个列的数据。需要特别注意的是，NULL 不占用该部分任何空间，即 NULL 除了占用 NULL 标志位之外，实际存储不占用空间。另外，每行数据除了用户定义的之外，还有两个隐藏列，事务ID列和回归指针列，分别是6和7字节大小。如果 InnoDB 表没有定义主键，还会增加一个6字节的 rowid 列。</p>
<h3 id="行溢出数据"><a href="#行溢出数据" class="headerlink" title="行溢出数据"></a>行溢出数据</h3><p>InnoDB 存储引擎可以将一条记录中的某些数据存储在真正的数据页面之外。一般认为 BLOB 、 LOB 这类的大对象列类型的存储会把数据放在数据页面之外。但是不是这样的，BLOB 可以不放在溢出页面，而且即便 VARCHAR 这种类型也可能被存放为行溢出数据。</p>
<p>MySQL 数据库的 VARCHAR 类型理论上可以存放 65535 字节，实际上创建一个 65535 长度的列的时候，会得到错误信息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[42000][1118] Row size too large. The maximum row size for the used table type, not counting BLOBs, is 65535. This includes storage overhead, check the manual. You have to change some columns to TEXT or BLOBs.</span></pre></td></tr></table></figure>

<p>由于还有别的开销，经过实际测试，能存放 VARCHAR 类型的最大长度是65532。</p>
<p>这里需要注意，65535 是说的字节数，如果你是用的是多字节的字符集，比如我用utf8mb4，没个字占用4个字节，创建会提示<code>[42000][1074] Column length too big for column &#39;varchars&#39; (max = 16383); use BLOB or TEXT instead.</code>，即<code>varchar</code>字段已经被限制到了16383的长度。</p>
<p>此外，还要注意，MySQL 官方手册中定义的65535长度是指所有 VARCHAR 列的长度综合，如果综合超过了这个长度，依然无法创建，同样是上面那个错误提示。</p>
<p>即便能够存储65535个字节，但是，InnoDB 引擎的页为 16KB，即16384字节，怎么能存放65535个字节呐？因此，在一般情况下，InnoDB引擎存储的数据都是放在页类型为B-tree node中。但是当发生行溢出的时候，数据存放在页类型为 Uncompress BLOB 页中。</p>
<p>通过工具可以看到，数据也只保存 VARCHAR 的前768的前缀（prefix）数据，之后都是偏移量，指向行溢出页，也就是 Uncompressed BLOB Page。因此，对于行溢出数据，存放采用下图的方式：</p>
<p><img src="http://nas.beritra.com:18081/uploads/big/b5b0d29d8328223c1873f43074172c39.png" alt=""></p>
<p>那么新的问题又来了，多长的 VARCHAR 是保存在单个数据页中的，多长开始会保存在 BLOB 中？</p>
<p>InnoDB存储引擎表是索引组织的，即 B+Tree 结构，这样每个页中至少应该有两条记录（不然就退化成链表了）。因此，如果页中只能存下一条记录，那么 InnoDB 引擎就会自动将行数据放到溢出页中。</p>
<p>经过测试，这个数字是 8098 ，如果少于这个长度，一个页中就可以放入至少两行数据，VARCHAR 类型的行数据就不会被放到 BLOB 页中去。</p>
<p>另一个问题，对于 TEXT 和 BLOB 数据类型，他们也不是永远存放在 Uncompressed BLOB Page 中的，跟 VARCHAR 类似，至少保证一个页中能存放两条记录。当然一般 BLOB 不会这么小，大多数情况下还是会发生行溢出，数据页只保存前 768 字节，实际数据还是存在 BLOB 页中。</p>
<h2 id="InnoDB数据页结构"><a href="#InnoDB数据页结构" class="headerlink" title="InnoDB数据页结构"></a>InnoDB数据页结构</h2><p>页是 InnoDB 存储引擎管理数据库的最小磁盘单位。也类型为 B-tree Node 的页存放的即是表中行的实际数据了。</p>
<p>InnoDB 数据页由以下7个部分组成，如图所示：</p>
<ul>
<li>File Header（文件头）</li>
<li>Page Header（页头）</li>
<li>Infimun 和 Supremum Records</li>
<li>User Records（用户记录，即行记录）</li>
<li>Free Space（空闲空间）</li>
<li>Page Directory（页目录）</li>
<li>File Trailer（文件结尾信息）</li>
</ul>
<p>其中 File Header、Page Header、File Trailer 的大小是固定的，分别为 38、56、8 字节，这些空间用来标记也得一些信息，如  Checksum，数据页所以在的 B+ 树索引的层数等。User Records、Free Space、Page Dirctory 这些部分为实际的行记录存储空间，因此大小是动态的。</p>
<p><img src="http://nas.beritra.com:18081/uploads/big/97aa2daf41d886ac93e40b1dfd88cca5.png" alt=""></p>
<h2 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h2><h3 id="约束完整性"><a href="#约束完整性" class="headerlink" title="约束完整性"></a>约束完整性</h3><p>关系型数据库和文件系统的一个不同点是，关系数据库本身能够保证存储数据的完整性，不需要应用程序的控制，而文件系统一般都需要在程序端进行控制。当前几乎所有的关系型数据库都提供了约束（constraint）机制，来保证数据的完整性。</p>
<p>对 InnoDB 存储引擎本身而言，提供了以下几种约束：</p>
<ul>
<li>Primary Key</li>
<li>Unique Key</li>
<li>Foreign Key</li>
<li>Default</li>
<li>NOT NULL</li>
</ul>
<h3 id="约束的创建和查找"><a href="#约束的创建和查找" class="headerlink" title="约束的创建和查找"></a>约束的创建和查找</h3><p>约束的创建可以用以下两种方式：</p>
<ul>
<li>表建立的时候进行约束定义</li>
<li>利用<code>ALTER TABLE</code>命令来创建约束</li>
</ul>
<p>对于 Unique Key （唯一索引）的约束，用户可以通过命令<code>CREATE UNIQUE INDEX</code>来建立。对于主键约束而言，默认约束名为 PRIMARY  。</p>
<h3 id="约束和索引的区别"><a href="#约束和索引的区别" class="headerlink" title="约束和索引的区别"></a>约束和索引的区别</h3><p>创建约束的方法通常就是创建索引的方法，的确，当用户创建了一个唯一索引就创建了一个唯一约束。但是约束和索引的概念还是有所不同的，约束更是一个逻辑的概念，用来保证数据的完成性，而索引是一个数据结构，既有逻辑上的概念，在数据库中还代表着物理存储的方式。</p>
<h3 id="对错误数据的约束"><a href="#对错误数据的约束" class="headerlink" title="对错误数据的约束"></a>对错误数据的约束</h3><p>在某些设置下，MySQL 允许非法的或不正确的数据的插入或更新，又或者可以在数据库内部将其转化为一个合法的值，如向 NOT NULL 的字段中插入一个 NULL值，MySQL 数据库会将其改为0再插入，因此数据库本身没有对数据的正确性进行约束。而通过设置 <code>sql_mode</code>参数，MySQL 数据库又可以堆输入的合法值进行约束。详细设置可以参考<a href="https://dev.mysql.com/doc/refman/8.0/en/sql-mode.html" target="_blank" rel="noopener">MySQL官方手册中对 sql_mode 的说明</a>。</p>
<h3 id="外键约束"><a href="#外键约束" class="headerlink" title="外键约束"></a>外键约束</h3><p>MyISAM 存储引擎本身不支持外键，而 InnoDB 则完整支持外键约束。现在有一定规模的项目都会不建议甚至强制不允许使用外键，具体原因可以再专门探讨，这里就不详细说明外键的使用方法和原理了，只记录几个知识要点。</p>
<p>可以定义的字表操作：</p>
<ul>
<li>CASCADE：父表变化时子表与父表进行一样的操作</li>
<li>SET NULL：父表变化时子表设为 NULL</li>
<li>NO ACTION：父表抛出错误，阻止操作</li>
<li>RESTRICT：同上, 都是立即检查外键约束</li>
</ul>
<p>数据库默认的设置是 RESTRICT。</p>
<h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><p>在MySQL数据中，视图（View）是一个命名的虚表，它由一个 SQL 查询来定义，可以当做表使用。与持久表（permanent table）不同的是，视图中的数据没有实际的物理存储。</p>
<h3 id="视图的作用"><a href="#视图的作用" class="headerlink" title="视图的作用"></a>视图的作用</h3><p>视图的主要用途之一是被用作一个抽象装置，特别是对于一些应用程序，程序本身不需要关心基表（base table）的结构，只需要按照视图定义来取数据或者更新数据，因此，视图层在一定程度上起到一个安全层的作用。</p>
<p>创建视图的语法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE</span></pre></td></tr><tr><td class="code"><pre><span class="line">    [OR REPLACE]</span></pre></td></tr><tr><td class="code"><pre><span class="line">    [ALGORITHM &#x3D; &#123;UNDEFINED | MERGE | TEMPTABLE&#125;]</span></pre></td></tr><tr><td class="code"><pre><span class="line">    [DEFINER &#x3D; user]</span></pre></td></tr><tr><td class="code"><pre><span class="line">    [SQL SECURITY &#123; DEFINER | INVOKER &#125;]</span></pre></td></tr><tr><td class="code"><pre><span class="line">    VIEW view_name [(column_list)]</span></pre></td></tr><tr><td class="code"><pre><span class="line">    AS select_statement</span></pre></td></tr><tr><td class="code"><pre><span class="line">    [WITH [CASCADED | LOCAL] CHECK OPTION]</span></pre></td></tr></table></figure>

<p>虽然视图是基于基表的虚拟表，但是用户可以对某些视图进行更新操作，其本质就是通过视图的定义来更新基表。</p>
<p>一般称可以进行更新操作的视图成为可更新视图（updatable view）。视图定义中的 WITH CHECK OPTION 就是针对于可更新的视图的，即更新的值是否需要检查。</p>
<h2 id="分区表"><a href="#分区表" class="headerlink" title="分区表"></a>分区表</h2><h3 id="分区概述"><a href="#分区概述" class="headerlink" title="分区概述"></a>分区概述</h3><p>分区功能并不是在存储引擎层完成的，因此不是只有 InnoDB 存储引擎支持分区，常见的存储引擎 MyISAM、NDB 等都支持。但也并不是所有的存储引擎都支持，如 CSV、FEDORATED、MERGE 等就不支持。在使用分区功能前，应该对选择的存储引擎对分区的支持有所了解。</p>
<p>MySQL 数据库在5.1版本时就添加了对分区的支持。分区的过程是将一个表或索引分解为多个更小、更可管理的部分。就访问数据库的应用而言，从逻辑上讲，只有一个表或一个索引，但是在物理上，这个表或索引可能由数十个物理分区组成。每个分区都是独立的对象，可以独自处理，也可以作为一个更大对象的一部分进行处理。</p>
<p>MySQL 数据库支持的分区类型为水平分区，并不支持垂直分区。此外，MySQL 数据的分区是局部分区索引，一个分区中即存放了数据又存放了索引。而全局分区是指，数据存放在各个分区中，但是所有数据的索引放在一个对象中。目前，MySQL 数据库还不支持全局分区。</p>
<p>MySQL 数据库支持以下几种分区：</p>
<ul>
<li>RANGE 分区：行数据基于属于一个给定连续区间的列值被放入分区。MySQL 5.5 开始支持 RANGE COLUMNS 的分区。</li>
<li>LIST 分区：和 RANGE 分区类似，只是 LIST 分区面向的是离散的值。 MySQL 5.5 开始支持 LIST COLUMNS 的分区。</li>
<li>HASH 分区：根据用户自定义的表达式的返回值来进行分区，返回值不能为负数。</li>
<li>KEY 分区：根据 MySQL 数据库提供的哈希函数来进行分区。</li>
</ul>
<p>无论创建何种类型的分区，如果分区表中存在主键或唯一索引时，分区列必须是唯一索引的一个组成部分。</p>
<p>唯一索引是允许 NULL 值的，并且分区列只要是唯一索引的一个组成部分，不需要是整个唯一索引列都是分区列。</p>
<p>另外，如果建表时没有指定主键，唯一索引，可以指定任何一个列为分区列。</p>
<h3 id="分区类型"><a href="#分区类型" class="headerlink" title="分区类型"></a>分区类型</h3><h4 id="RANGE-分区"><a href="#RANGE-分区" class="headerlink" title="RANGE 分区"></a>RANGE 分区</h4><p>RANGE分区是最常用的一种分区。下面的<code>CREATE TABLE</code>语句创建了一个 id 列的区间分区表。当 id 小于10时，数据插入 p0 分区。当 id 等于10 小于 20时，数据插入 p1 分区。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE t&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">id INT</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;ENGINE&#x3D;INNODB</span></pre></td></tr><tr><td class="code"><pre><span class="line">PARTITION BY RANGE(id)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">PARTITION p0 VALUES LESS THAN(10),</span></pre></td></tr><tr><td class="code"><pre><span class="line">PARTITION p1 VALUES LESS THAN(20));</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>这时候查看磁盘上的物理文件，启用分区表之后，文件不再是由一个 ibd 文件组成了，而是由建立分区时的各个分区 ibd 文件组成。</p>
<p>可以通过查询<code>information_cheme</code>架构下的 PARATITIONS 表来查看每个分区的具体信息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM information_scheme.PARTITIONS where table_scheme&#x3D;database() and table_name&#x3D;&#39;t&#39;\G;</span></pre></td></tr></table></figure>

<p>RANGE 分区主要用于日期列的分区，例如销售类的表，按年进行分区存放销售记录。这样的好处就是，便于对表进行管理。比如要删除某一年的数据，不需要在 where 里面写大段的时间参数，只需删除对应年份所在的分区即可。另一个好处就是可以加快某些查询操作，比如查询某一年的销售额，使用预先设定好的分区可以加快查询速度。</p>
<h4 id="LIST-分区"><a href="#LIST-分区" class="headerlink" title="LIST 分区"></a>LIST 分区</h4><p>LIST 分区个 RANGE 分区非常相似，只是分区列的值是离散的，而非连续的。比如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE t(</span></pre></td></tr><tr><td class="code"><pre><span class="line">a INT,</span></pre></td></tr><tr><td class="code"><pre><span class="line">b INT)ENGINE&#x3D;INNODB</span></pre></td></tr><tr><td class="code"><pre><span class="line">PARTITION BY LIST(b)(</span></pre></td></tr><tr><td class="code"><pre><span class="line">PARTITION p0 VALUES IN(1,3,5,7,9),</span></pre></td></tr><tr><td class="code"><pre><span class="line">PARTITION p1 VALUES IN(0,2,4,6,8)</span></pre></td></tr><tr><td class="code"><pre><span class="line">);</span></pre></td></tr></table></figure>

<p>不同于 RANGE 分区中定义的<code>VALUES LESS TAHN</code>语句，LIST 分区使用 <code>VALUES IN</code>。因为每个分区的值是离散的，因此只能定义值。</p>
<h4 id="HASH-分区"><a href="#HASH-分区" class="headerlink" title="HASH 分区"></a>HASH 分区</h4><p>HASH分区的目的是将数据均匀的分不到预先定义的各个分区中，保证各个分区的数据量大致都一样的。在 RANGE 和 LIST 分区中，必须明确指定一个给定的列值或列值集合应该保存在哪个分区中；而在 HASH 分区中，MySQL 自动完成这些工作，用户需要做的只是基于将要进行哈希分区的列值指定一个列值或者表达式，以及指定被分区的表将要被分割的分区数量。</p>
<p>要使用 HASH 分区来分割一个表，要在 CREATE TABLE 语句上添加一个<code>PARTITION BY HASH（expr）</code>子句，其中<code>expr</code>是一个返回一个整数的表达式。它可以仅仅是字段类型为 MySQL 整型的列名。此外，用户很可能需要在后面再添加一个<code>PARTITIONS num</code>子句，其中 num 是一个非负的整数，它表示将要被分割成分区的数量。如果没有包含一个 PARTITIONS 字句，那么分区数量将默认为1。</p>
<p>下面的例子创建了一个 HASH 分区的表 t，分区按日期列 b 进行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE t_hash(</span></pre></td></tr><tr><td class="code"><pre><span class="line">a INT,</span></pre></td></tr><tr><td class="code"><pre><span class="line">b DATETIME)ENGINE&#x3D;INNODB</span></pre></td></tr><tr><td class="code"><pre><span class="line">PARTITION BY HASH(YEAR(b))</span></pre></td></tr><tr><td class="code"><pre><span class="line">PARTITIONS 4;</span></pre></td></tr></table></figure>

<p>MySQL 数据库还支持一种成为 <code>LINEAR HASH</code>的分区，它使用一个更加复杂的算法来确定新行插入到已经分区的表中的位置。它的语法和 HASH 分区的语法相似，只是将关键字 HASH 改为 LINEAR HASH。下面创建的是一个 LINEAR HASH 的分区表：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE t_linear_hash(</span></pre></td></tr><tr><td class="code"><pre><span class="line">a INT,</span></pre></td></tr><tr><td class="code"><pre><span class="line">b DATETIME)ENGINE&#x3D;INNODB</span></pre></td></tr><tr><td class="code"><pre><span class="line">PARTITION BY LINEAR HASH(YEAR(b))</span></pre></td></tr><tr><td class="code"><pre><span class="line">PARTITIONS 4;</span></pre></td></tr></table></figure>

<p>LINEAR HASH 分区的优点在于，增加、删除、合并和拆分分区将变得更加快捷，这有利于处理含有大量数据库的表。缺点在于，与使用 HASH 分区得到的数据分布相比，各个分区间数据的分布可能不太均衡。</p>
<h4 id="KEY-分区"><a href="#KEY-分区" class="headerlink" title="KEY 分区"></a>KEY 分区</h4><p>KEY 分区和 HASH 分区相似，不同之处在于 HASH 分区使用用户定义的函数进行分区，KEY 分区使用 MySQL 数据库提供的函数进行分区，对于 NDB Cluster 引擎，MySQL 数据库使用 MD5 函数来分区；对于其他存储引擎， MySQL 数据库使用其内部的哈希函数，这些函数基于与 PASSWORD() 一样的运算法则。</p>
<h4 id="COLUMNS-分区"><a href="#COLUMNS-分区" class="headerlink" title="COLUMNS 分区"></a>COLUMNS 分区</h4><p>前面介绍的4种分区，分区得条件是：数据必须是整形（integer），如果不是整型，那应该需要通过函数化为整型。MySQL 5.5 版本开始支持 COLUMNS 分区，可以视为 RANGE 分区和 LIST 分区的一种进化。COLUMNS 分区可以直接使用非整形的数据进行分区，分区根据类型直接比较而得，不需要转化为整形。此外 RANGE COLUMNS 分区可以对多个列的值进行分区。</p>
<p>COLUMNS 分区支持以下的数据类型：</p>
<ul>
<li>所有整形类型，如 INT、SMALLINT、TINYINT、BIGINT。FLOAT 和 DECIMAL 则不予支持。</li>
<li>日期类型，如 DATE 和 DATETIME。其余的日期类型则不予支持。</li>
<li>字符串类型，如 CHAR、VARCHAR、BINARY 和 VARBINARY。BLOB 和 TEXT 类型不予支持。</li>
</ul>
<p>对于日期类型的分区，我们不再需要<code>YEAR()</code>和<code>TO_DODAY()</code>函数了，而可以直接使用 COLUMNS。</p>
<h3 id="子分区"><a href="#子分区" class="headerlink" title="子分区"></a>子分区</h3><p>子分区（subpartitioning）是在分区的基础上在进行分区，有时也称这种分区为复合分区（composite partitioning）。MySQL 数据库允许在 RANGE 和 LIST 的分区上在进行 HASH 和 KEY 的子分区。</p>
<p>但是子分区的建立需要注意以下几个问题：</p>
<ul>
<li>每个子分区的数量必须相同。</li>
<li>要在一个分区表的任何分区上使用 SUBPARTITION 来明确定义任何子分区，就必须定义所有的子分区。</li>
<li>每个 SUBPARTITION 子句必须包括子分区的一个名字。</li>
<li>子分区的名字必须是唯一的。</li>
</ul>
<h3 id="分区中的NULL值"><a href="#分区中的NULL值" class="headerlink" title="分区中的NULL值"></a>分区中的NULL值</h3><p>MySQL数据库允许堆 NULL 值进行分区，但是处理方法和其他数据库可能完全不同。MySQL 数据库的分区总是视 NULL 值小于任何一个非 NULL 值，这和 MySQL 数据库中处理 NULL 值的<code>ORDER BY</code>操作是一样的。因此对于不同的分区类型，MySQL 数据库对于 NULL 值的处理也是各不相同。</p>
<ul>
<li><p>对于 RANGE 分区，如果向分区中插入了 NULL 值，则 MySQL 数据库会将该值放入最左边的分区。</p>
</li>
<li><p>LIST 分区必须显式指出向哪个分区中放入 NULL 值，否则会报错。</p>
</li>
<li><p>HASH 分区和 KEY 分区跟上面又不相同，任何分区函数都会将含有 NULL 值的记录返回为0。</p>
</li>
</ul>
<h3 id="分区和性能"><a href="#分区和性能" class="headerlink" title="分区和性能"></a>分区和性能</h3><p>在合理使用分区之前，必须了解分区的使用环境。</p>
<p>数据库的应用分为两类：一类是 OLTP（在线事务处理），如 Blog、电子商务、网络游戏等；另一类是 OLAP（在线分析处理），如数据仓库、数据集市。</p>
<p>对于 OLAP 的应用，分区的确是能够很好地提高查询性能，因为 OLAP 应用大多数查询需要频繁的扫描一张很大的表。</p>
<p>然而对于 OLTP 的应用，分区应该非常小心。在这种应用下，通常不可能获取一张表中超过 10%，大部分通过索引返回几条记录即可。而根据 B+ 树索引的原理，一般的 B+ 树需要2~3次的磁盘 IO ，因此 B+ 树已经可以很好地完成操作，不需要分区的帮助，而且设计不好的分区会带来严重的性能问题。</p>
<h3 id="在表和分区间交换数据"><a href="#在表和分区间交换数据" class="headerlink" title="在表和分区间交换数据"></a>在表和分区间交换数据</h3><p>在MySQL 5.6 开始支持<code>ALTER TABLE ... EXCHANGE PARTITION</code>语法。该语句允许分区或子分区中的数据与另一个非分区的表中的数据进行交换。如果非分区表中的数据为空，那么相当于将分区中的数据移动到非分区表中。若分区表中的数据为空，则相当于将外部表中的数据导入到分区中。</p>
<p>要使用<code>ALTER TABLE ... EXCHANGE PARTITION</code>语句，必须满足：</p>
<ul>
<li>要交换的表和分区表有相同的结构，但是不能含有分区</li>
<li>在非分区表中的数据必须在交换的分区定义中</li>
<li>被交换的表中不能含有外键，或者其他的表含有对该表的外键引用</li>
<li>用户除了需要 ALTER、INSERT 和 CREATE 权限外，还需要 DROP 的权限</li>
</ul>
<p>此外，还有两个小的细节需要注意：</p>
<ul>
<li>使用该语句的时候，不会触发交换表和被交换表上的触发器</li>
<li>AUTO_INCREMENT 列将被重置</li>
</ul>
<p>参考文章：</p>
<p><a href="https://www.jianshu.com/p/1573c4dcecd6" target="_blank" rel="noopener">InnoDB逻辑存储结构</a></p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>数据库</tag>
        <tag>InnoDB</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL原理和优化</title>
    <url>/2019/10/01/MySQL%E5%8E%9F%E7%90%86%E5%92%8C%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<p>本文主要摘抄自《MySQL技术内幕（InnoDB存储引擎）第二版》，少部分来自网络博客和自己补充。注意，该书内容是基于MySQL 5.6 及更早的版本，具体的实现方式有可能发生了改变，有些内容我做了注释和补充，但是不保证百分百的完整和正确。</p>
<a id="more"></a>

<h2 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h2><p>MySQL 5.0 支持的存储引擎包括 MyISAM、 InnoDB、 BDB、 MEMORY、 MERGE、 EXAMPLE、<br>NDB Cluster、ARCHIVE、CSV、BLACKHOLE、FEDERATED 等,其中 InnoDB 和 BDB 提供事务安<br>全表,其他存储引擎都是非事务安全表。</p>
<p>使用<code>show engines</code>命令可以查看支持的存储引擎。我在 MySQL 8.0 中执行命令得到的结果如下：</p>
<p><img src="http://nas.beritra.com:18081/uploads/medium/0b0d90cb4b762609bbbd0ce373b25cc8.png" alt=""></p>
<p>一般使用的都是 InnoDB 引擎，所以主要还是研究 InnoDB 的特性和原理。</p>
<h2 id="自动增长列"><a href="#自动增长列" class="headerlink" title="自动增长列"></a>自动增长列</h2><p>InnoDB 表的自动增长列可以手工插入，但是插入的值如果是空或者 0，则实际插入的将是自动增长后的值。如果插入一个大于当前自增id的数的时候，自增id会变成这个数字，中间的就被跳过了。</p>
<p>可以通过<code>ALTER TABLE *** AUTO_INCREMENT = n;</code>语句强制设置自动增长列的初识值，默认从 1 开始，但是该强制的默认值是保留在内存中的，如果该值在使用之前数据库重新启动，那么这个强制的默认值就会丢失，就需要在数据库启动以后重新设置。</p>
<p>对于 InnoDB 表,自动增长列必须是索引。如果是组合索引,也必须是组合索引的第一列。</p>
<h2 id="外键约束"><a href="#外键约束" class="headerlink" title="外键约束"></a>外键约束</h2><p>MySQL 支持外键的存储引擎只有 InnoDB，在创建外键的时候,要求父表必须有对应的索引，子表在创建外键的时候也会自动创建对应的索引。</p>
<p>在创建索引的时候，可以指定在删除、更新父表时，对子表进行的相应操作，包括 RESTRICT、CASCADE、SET NULL 和 NO ACTION。其中 RESTRICT 和 NO ACTION 相同，是指限制在子表有关联记录的情况下父表不能更新； CASCADE 表示父表在更新或者删除时，更新或者删除子表对应记录；SET NULL 则表示父表在更新或者删除的时候，子表的对应字段被 SET NULL。选择后两种方式的时候要谨慎，可能会因为错误的操作导致数据的丢失。</p>
<p>《阿里巴巴Java规范》中强制要求不能使用外键，所有表之间的关联逻辑应该在业务逻辑中实现。</p>
<h2 id="存储方式"><a href="#存储方式" class="headerlink" title="存储方式"></a>存储方式</h2><p>在 8.0 里面，InnoDB 把数据字典进行重构，大家应该知道数据字典是什么，就是表结构，你的用户定义，所有的跟 DDL 相关放到数据字典里面去。在 8.0 之前，数据字典有两份，一份是存储在 .frm 文件里，另一份是 InnoDB 的数据表里。在8.0之后 .frm 被干掉了，只保留了 InnoDB 中的数据。8.0 中数据库的 innodb 表全部放至在 datadir 下的 mysql.ibd 中，不再把表结构放在 .frm 文件中，而是存放在元数据表中。</p>
<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><h3 id="索引概述"><a href="#索引概述" class="headerlink" title="索引概述"></a>索引概述</h3><p>所有 MySQL 列类型都可以被索引，对相关列使用索引是提高 SELECT 操作性能的最佳途径。根据存储引擎可以定义每个表的最大索引数和最大索引长度，每种存储引擎(如 MyISAM、InnoDB、BDB、MEMORY 等)对每个表至少支持 16 个索引，总索引长度至少为 256 字节。大多数存储引擎有更高的限制。</p>
<p>InnoDB存储引擎支持以下几种常见的索引：</p>
<ul>
<li>B+ 树索引</li>
<li>全文索引</li>
<li>哈希索引</li>
</ul>
<p>B+树索引就是传统意义上的索引，这是目前关系型数据库系统中查找最为常用和最有效的索引。B+树索引的构造类似与二叉树，根据键值（Key Value）快速找到数据。</p>
<h3 id="设计索引的原则和技巧"><a href="#设计索引的原则和技巧" class="headerlink" title="设计索引的原则和技巧"></a>设计索引的原则和技巧</h3><ul>
<li>搜索的索引列，不一定是所要选择的列。换句话说，最适合索引的列是出现在 WHERE子句中的列，或连接子句中指定的列，而不是出现在 SELECT 关键字后的选择列表中的列。</li>
<li>使用惟一索引。考虑某列中值的分布。索引的列的基数越大，索引的效果越好。例如，存放出生日期的列具有不同值，很容易区分各行。而用来记录性别的列，只含有“ M”和“F”，则对此列进行索引没有多大用处，因为不管搜索哪个值，都会得出大约一半的行。</li>
<li>使用短索引。如果对字符串列进行索引，应该指定一个前缀长度，只要有可能就应该这样做。</li>
<li>利用最左前缀。在创建一个 n 列的索引时，实际是创建了 MySQL 可利用的 n 个索引。多列索引可起几个索引的作用，因为可利用索引中最左边的列集来匹配行。这样的列集称为最左前缀。另外，mysql会一直向右匹配直到遇到范围查询(&gt;、&lt;、between、like)就停止匹配，比如a = 1 and b = 2 and c &gt; 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任调整。</li>
<li>不要过度索引。不要以为索引“越多越好”，什么东西都用索引是错误的。</li>
<li>对于 InnoDB 存储引擎的表，记录默认会按照一定的顺序保存，如果有明确定义的主键,则按照主键顺序保存。如果没有主键，但是有唯一索引，那么就是按照唯一索引的顺序保存。如果既没有主键又没有唯一索引，那么表中会自动生成一个内部列，按照这个列的顺序保存。</li>
<li>尽量的扩展索引，不要新建索引。比如表中已经有a的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可。</li>
<li>= 和 in 可以乱序，比如 a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式。</li>
</ul>
<h3 id="索引的操作"><a href="#索引的操作" class="headerlink" title="索引的操作"></a>索引的操作</h3><p>创建索引的详细定义如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE [UNIQUE | FULLTEXT | SPATIAL] INDEX index_name</span></pre></td></tr><tr><td class="code"><pre><span class="line">    [index_type]</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ON tbl_name (key_part,...)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    [index_option]</span></pre></td></tr><tr><td class="code"><pre><span class="line">    [algorithm_option | lock_option] ...</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">key_part: &#123;col_name [(length)] | (expr)&#125; [ASC | DESC]</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">index_option:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    KEY_BLOCK_SIZE [&#x3D;] value</span></pre></td></tr><tr><td class="code"><pre><span class="line">  | index_type</span></pre></td></tr><tr><td class="code"><pre><span class="line">  | WITH PARSER parser_name</span></pre></td></tr><tr><td class="code"><pre><span class="line">  | COMMENT &#39;string&#39;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  | &#123;VISIBLE | INVISIBLE&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">index_type:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    USING &#123;BTREE | HASH&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">algorithm_option:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ALGORITHM [&#x3D;] &#123;DEFAULT | INPLACE | COPY&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">lock_option:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    LOCK [&#x3D;] &#123;DEFAULT | NONE | SHARED | EXCLUSIVE&#125;</span></pre></td></tr></table></figure>

<p>索引的删除语法为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DROP INDEX index_name ON tbl_name</span></pre></td></tr></table></figure>



<h3 id="B-树索引的原理"><a href="#B-树索引的原理" class="headerlink" title="B+树索引的原理"></a>B+树索引的原理</h3><p>关于B树和B+树的结构，可以参考这篇博文：<a href="https://www.cnblogs.com/nullzx/p/8729425.html" target="_blank" rel="noopener">B树和B+树的插入、删除图文详解</a></p>
<p>B+树相比B树，优点包括：</p>
<ol>
<li>B+<strong>树的层级更少</strong>：相较于B树B+每个<strong>非叶子</strong>节点存储的关键字数更多，树的层级更少所以查询数据更快；</li>
<li>B+<strong>树查询速度更稳定</strong>：B+所有关键字数据地址都存在<strong>叶子</strong>节点上，所以每次查找的次数都相同所以查询速度要比B树更稳定;</li>
<li>B+<strong>树天然具备排序功能：</strong>B+树所有的<strong>叶子</strong>节点数据构成了一个有序链表，在查询大小区间的数据时候更方便，数据紧密性很高，缓存的命中率也会比B树高。</li>
<li>B+<strong>树全节点遍历更快：</strong>B+树遍历整棵树只需要遍历所有的<strong>叶子</strong>节点即可，，而不需要像B树一样需要对每一层进行遍历，这有利于数据库做全表扫描。</li>
</ol>
<p>而 B 树相对于 B+ 树的优点是，如果经常访问的数据离根节点很近，而 B 树的非叶子节点本身存有关键字其数据的地址，所以这种数据检索的时候会要比 B+ 树快。</p>
<h3 id="聚簇索引-amp-非聚簇索引"><a href="#聚簇索引-amp-非聚簇索引" class="headerlink" title="聚簇索引 &amp; 非聚簇索引"></a>聚簇索引 &amp; 非聚簇索引</h3><p>聚集索引与非聚集索引的区别是：叶节点是否存放一整行记录</p>
<p>InnoDB 主键使用的是聚簇索引，MyISAM 不管是主键索引，还是二级索引使用的都是非聚簇索引。</p>
<p>下图形象说明了聚簇索引表(InnoDB)和非聚簇索引(MyISAM)的区别：</p>
<p><img src="http://nas.beritra.com:18081/uploads/big/5a3086cee19057902e88e42f4653ba47.jpg" alt=""></p>
<ol>
<li><p>对于<strong>非聚簇索引表</strong>来说（右图），表数据和索引是分成两部分存储的，主键索引和二级索引存储上没有任何区别。使用的是 B+ 树作为索引的存储结构，所有的节点都是索引，叶子节点存储的是索引+索引对应的记录的数据。</p>
</li>
<li><p>对于<strong>聚簇索引表</strong>来说（左图），表数据是和主键一起存储的，主键索引的叶结点存储行数据(包含了主键值)，二级索引的叶结点存储行的主键值。使用的是 B+ 树作为索引的存储结构，非叶子节点都是索引关键字，但非叶子节点中的关键字中不存储对应记录的具体内容或内容地址。叶子节点上的数据是主键与具体记录(数据内容)。</p>
</li>
</ol>
<p>聚簇索引的优点</p>
<ol>
<li><p>当你需要取出一定范围内的数据时，用聚簇索引也比用非聚簇索引好。</p>
</li>
<li><p>当通过聚簇索引查找目标数据时理论上比非聚簇索引要快，因为非聚簇索引定位到对应主键时还要多一次目标记录寻址,即多一次 I/O。</p>
</li>
<li><p>使用覆盖索引扫描的查询可以直接使用页节点中的主键值。</p>
</li>
</ol>
<p>聚簇索引的缺点</p>
<ol>
<li><p><strong>插入速度严重依赖于插入顺序</strong>，按照主键的顺序插入是最快的方式，否则将会出现页分裂，严重影响性能。因此，对于 InnoDB 表，我们一般都会定义一个自增的 ID 列为主键。</p>
</li>
<li><p><strong>更新主键的代价很高，因为将会导致被更新的行移动</strong>。因此，对于 InnoDB 表，我们一般定义主键为不可更新。</p>
</li>
<li><p><strong>二级索引访问需要两次索引查找，第一次找到主键值，第二次根据主键值找到行数据。</strong>二级索引的叶节点存储的是主键值，而不是行指针（非聚簇索引存储的是指针或者说是地址），这是为了减少当出现行移动或数据页分裂时二级索引的维护工作，但会让二级索引占用更多的空间。</p>
</li>
<li><p><strong>采用聚簇索引插入新值比采用非聚簇索引插入新值的速度要慢很多</strong>，因为插入要保证主键不能重复，判断主键不能重复，采用的方式在不同的索引下面会有很大的性能差距，聚簇索引遍历所有的叶子节点，非聚簇索引也判断所有的叶子节点，但是聚簇索引的叶子节点除了带有主键还有记录值，记录的大小往往比主键要大的多。这样就会导致聚簇索引在判定新记录携带的主键是否重复时进行昂贵的I/O代价。</p>
</li>
</ol>
<h3 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h3><p>联合索引是指对表上多个列进行索引，创建方法和单个索引一样，不同之处在于有多个索引列。</p>
<p>联合索引比对每个列分别建索引更有优势，因为索引建立得越多就越占磁盘空间，在更新数据的时候速度会更慢。另外建立多列索引时，顺序也是需要注意的，应该将严格的索引放在前面，这样筛选的力度会更大，效率更高。</p>
<p>联合索引的优势：</p>
<ol>
<li><p>避免回表</p>
<p>在执行计划中，table access by index rowid 代表是回表动作。如在user的id列建有索引，<code>select id from user</code>这个不用回表，直接从索引中读取id的值，而<code>select id,name from user</code>中，不能返回除 id 列其他的值，所以必须要回表。如果建有了 id 和 name 列的联合索引，则可以避免回表。</p>
<p>另外，建立了 id 和 name 的联合索引(id列在在前)，则<code>select id from user</code>可以避免回表，而不用单独建立 id 列的单列索引</p>
</li>
<li><p>两个单列查询返回行较多，同时查返回行较少，联合索引更高效。</p>
<p>如果 <code>select * from user where id=2</code> 和 <code>select * from user where name=&#39;tom&#39;</code> 各自返回的行数比较多，而 <code>select * from user where id=2 and name=&#39;tom&#39;</code> 返回的行数比较少，那么这个时候使用联合索引更加高效。</p>
</li>
</ol>
<h2 id="索引优化和最佳实践"><a href="#索引优化和最佳实践" class="headerlink" title="索引优化和最佳实践"></a>索引优化和最佳实践</h2><p>先来个偷来的大长图：</p>
<p><img src="http://nas.beritra.com:18081/blog/202005/d3b79d089a9811ea99b000d861792df0.jpg" alt="img"></p>
<h3 id="一些其他的技巧"><a href="#一些其他的技巧" class="headerlink" title="一些其他的技巧"></a>一些其他的技巧</h3><ul>
<li>通常来说简单的把可为 NUL 的列改为 NOT NULL 不会对性能提升有多少帮助，只是如果计划在列上创建索引，就应该将该列设置为 NOT NULL。</li>
<li>对整数类型指定宽度，比如 INT(11)，没有任何卵用。INT 使用32位（4个字节）存储空间，那么它的表示范围已经确定，所以 INT(1)和 INT(20)对于存储和计算是相同的。</li>
<li>UNSIGNED 表示不允许负值，大致可以使正数的上限提高一倍。</li>
<li>大表 ALTER TABLE 非常耗时，MySQL 执行大部分修改表结果操作的方法是用新的结构创建一个张空表，从旧表中查出所有的数据插入新表，然后再删除旧表。</li>
</ul>
<h3 id="一些不走索引的情况："><a href="#一些不走索引的情况：" class="headerlink" title="一些不走索引的情况："></a>一些不走索引的情况：</h3><p>MySQL 内部优化器会对 SQL 语句进行优化，如果优化器估计使用全表扫描要比使用索引快，则不使用索引。所以实际上不走索引的情况可能非常多，很难一一列举。以下是一些比较典型的情况。</p>
<h4 id="非独立的列"><a href="#非独立的列" class="headerlink" title="非独立的列"></a>非独立的列</h4><p>“独立的列”是指索引列不能是表达式的一部分，也不能是函数的参数。比如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from where id + 1 &#x3D; 5</span></pre></td></tr></table></figure>

<p>我们很容易看出其等价于 id = 4，但是MySQL无法自动解析这个表达式，使用函数是同样的道理。</p>
<p>另外在查询条件里面用函数计算的话，也是一样的。</p>
<h4 id="模糊查询"><a href="#模糊查询" class="headerlink" title="模糊查询"></a>模糊查询</h4><p>当然不是全部模糊查询都不走索引，如果查询条件前半部分是确定的，就会走索引，即<code>like &#39;xxx%&#39;</code>的情况。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from compare_result where request_id like &#39;%0173f%&#39;;#不走索引</span></pre></td></tr><tr><td class="code"><pre><span class="line">select * from compare_result where request_id like &#39;0173f%&#39;;#走索引</span></pre></td></tr></table></figure>



<h4 id="不等于"><a href="#不等于" class="headerlink" title="不等于"></a>不等于</h4><p> 类似<code>where id !=2</code>或者<code>where id &lt;&gt; 2</code>都不会走索引，尽量使用 UNION 关键字进行表述。</p>
<h4 id="范围查询"><a href="#范围查询" class="headerlink" title="范围查询"></a>范围查询</h4><p>如果是连续的范围，优先用 between 而不是 in。</p>
<p>最后又偷了一个别人的图：</p>
<p><img src="http://nas.beritra.com:18081/blog/202005/gCe4M3snqW.png" alt=""></p>
<p>参考文章：</p>
<p><a href="https://tech.meituan.com/2014/06/30/mysql-index.html" target="_blank" rel="noopener">MySQL索引原理及慢查询优化</a></p>
<p><a href="https://juejin.im/post/5c2c53396fb9a04a053fc7fe#heading-31" target="_blank" rel="noopener">MySQL优化/面试，看这一篇就够了</a></p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>数据库</tag>
        <tag>优化</tag>
      </tags>
  </entry>
  <entry>
    <title>Keepalived+MySQL双主高可用配置</title>
    <url>/2019/01/01/%E7%A6%BB%E7%BA%BF%E7%8E%AF%E5%A2%83%E4%B8%8BKeepalived+MySQL%208.0%E5%AE%89%E8%A3%85%E5%92%8C%E5%8F%8C%E4%B8%BB%E9%AB%98%E5%8F%AF%E7%94%A8%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p>记录一个Keepalived+MySQL 双主高可用配置的配置过程。</p>
<a id="more"></a>

<h3 id="系统环境准备"><a href="#系统环境准备" class="headerlink" title="系统环境准备"></a>系统环境准备</h3><p>两台服务器IP：</p>
<ul>
<li><p>10.17.55.201主要的</p>
</li>
<li><p>10.17.55.202次要的</p>
</li>
</ul>
<p>两台系统版本均为 CentOS Linux release 7.4.1708 (Core)</p>
<p>MySQL官网上下载mysql-8.0.18-1.el7.x86_64.rpm-bundle.tar，即适用于CentOS的MySQL 8.0.18</p>
<h3 id="组件安装"><a href="#组件安装" class="headerlink" title="组件安装"></a>组件安装</h3><p>CentOS可能带有默认的Mariadb，如果不想用的话可以执行<code>rpm -qa|grep mariadb</code>找到所有安装包，然后依次执行<code>rpm -r 每个文件名</code>卸载Mariadb。</p>
<p>然后从官网上下载相应的MySQL安装文件。</p>
<p>安装顺序为</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rpm -ivh mysql-community-common-5.7.17-1.el7.x86_64.rpm   </span></pre></td></tr><tr><td class="code"><pre><span class="line">rpm -ivh mysql-community-libs-5.7.17-1.el7.x86_64.rpm   </span></pre></td></tr><tr><td class="code"><pre><span class="line">rpm -ivh mysql-community-client-5.7.17-1.el7.x86_64.rpm  </span></pre></td></tr><tr><td class="code"><pre><span class="line">rpm -ivh mysql-community-server-5.7.17-1.el7.x86_64.rpm  </span></pre></td></tr><tr><td class="code"><pre><span class="line">rpm -ivh mysql-community-devel-5.7.17-1.el7.x86_64.rpm</span></pre></td></tr></table></figure>

<p>安装最后一个的时候有可能出现依赖openssl的问题，重新安装openssl无效，输入参数<code>-e --nodeps</code>可以解决，暂不清楚原理</p>
<h3 id="数据库配置"><a href="#数据库配置" class="headerlink" title="数据库配置"></a>数据库配置</h3><p>先从主备模式开始进行配置，方便排错。</p>
<h4 id="主实例"><a href="#主实例" class="headerlink" title="主实例"></a>主实例</h4><p>修改配置文件/etc/my.cnf</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[mysqld]</span></pre></td></tr><tr><td class="code"><pre><span class="line">log-bin&#x3D;mysql-bin #日志名称</span></pre></td></tr><tr><td class="code"><pre><span class="line">server-id&#x3D;1 #数据库id,两个实例不能一样</span></pre></td></tr></table></figure>

<p>然后创建用户，用于数据同步，MySQL 8.0之后的用户创建方式和之前不一样</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE USER &#39;repl&#39;@&#39;10.17.55.202&#39; IDENTIFIED WITH mysql_native_password BY &#39;1&#39;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">GRANT REPLICATION SLAVE ON *.* TO &#39;repl&#39;@&#39;10.17.55.202&#39;;</span></pre></td></tr></table></figure>

<p>然后刷新权限</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">flush privileges;</span></pre></td></tr></table></figure>

<p>查看主节点的binary log文件名和位置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show master status;</span></pre></td></tr></table></figure>

<p><img src="http://nas.beritra.com:18081/uploads/big/8a7f799589b2d471ddf3f97a0d8d01e5.png" alt="image-20191119183450339"></p>
<p>记录下来<code>File</code>和<code>Position</code>两个字段，下面要用。</p>
<h4 id="备用实例"><a href="#备用实例" class="headerlink" title="备用实例"></a>备用实例</h4><p>在从节点上设置参数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CHANGE MASTER TO MASTER_HOST&#x3D;&#39;10.17.55.201&#39;,MASTER_USER&#x3D;&#39;repl&#39;,MASTER_PASSWORD&#x3D;&#39;1&#39;,MASTER_LOG_FILE&#x3D;&#39;mysql-bin.000002&#39;,MASTER_LOG_POS&#x3D;1141;</span></pre></td></tr></table></figure>

<p>然后启动从节点<code>start slave</code>，并且查看节点状态<code>show slave status\G</code></p>
<p>如果看到节点的状态信息中包含一下的两条，证明连接成功。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Slave_IO_State: Waiting for master to send event</span></pre></td></tr><tr><td class="code"><pre><span class="line">Slave_SQL_Running_State: Slave has read all relay log; waiting for more updates</span></pre></td></tr></table></figure>

<p>然后验证一下：</p>
<p>切换回主节点，新建一个数据库或者表，从节点中应该同步添加了。</p>
<h4 id="双主环境"><a href="#双主环境" class="headerlink" title="双主环境"></a>双主环境</h4><p>以上搭建的是MySQL主备模式，双主模式其实一样，只不过两者之间互为主备。</p>
<p>同样的，把之前的备用节点当做主节点，之前的主节点当做备用节点，再来一遍。不要忘记修改<code>my.cnf</code>。</p>
<p>配置完成之后继续新建一个数据库或者表，测试是否同步。</p>
<h3 id="Keepalived安装和配置"><a href="#Keepalived安装和配置" class="headerlink" title="Keepalived安装和配置"></a>Keepalived安装和配置</h3><p>CentOS上直接可以用yum安装Keepalived，省了不少事情，不过可能遇到错误</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Error: Package: 1:net-snmp-agent-libs-5.7.2-43.el7.x86_64 (base)</span></pre></td></tr><tr><td class="code"><pre><span class="line">           Requires: libmysqlclient.so.18()(64bit)</span></pre></td></tr><tr><td class="code"><pre><span class="line">Error: Package: 1:net-snmp-agent-libs-5.7.2-43.el7.x86_64 (base)</span></pre></td></tr><tr><td class="code"><pre><span class="line">           Requires: libmysqlclient.so.18(libmysqlclient_18)(64bit)</span></pre></td></tr></table></figure>

<p>安装MySQL安装包中的<code>libs-compat</code>即可</p>
<p>然后对keepalived进行配置，最简配置如下：</p>
<p>主节点：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">! Configuration File for keepalived</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">global_defs &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">   router_id master</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">vrrp_instance VI_1 &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    state MASTER</span></pre></td></tr><tr><td class="code"><pre><span class="line">    interface eth1</span></pre></td></tr><tr><td class="code"><pre><span class="line">    virtual_router_id 51</span></pre></td></tr><tr><td class="code"><pre><span class="line">    priority 100</span></pre></td></tr><tr><td class="code"><pre><span class="line">    advert_int 1</span></pre></td></tr><tr><td class="code"><pre><span class="line">    unicast_src_ip 172.18.0.2</span></pre></td></tr><tr><td class="code"><pre><span class="line">    unicast_peer &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        1172.18.0.3</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    authentication &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        auth_type PASS</span></pre></td></tr><tr><td class="code"><pre><span class="line">        auth_pass 1111</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    virtual_ipaddress &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	172.18.0.10</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>



<p>从节点：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">! Configuration File for keepalived</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">global_defs &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">   router_id master</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">vrrp_instance VI_1 &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    state MASTER</span></pre></td></tr><tr><td class="code"><pre><span class="line">    interface eth1</span></pre></td></tr><tr><td class="code"><pre><span class="line">    virtual_router_id 51</span></pre></td></tr><tr><td class="code"><pre><span class="line">    priority 90</span></pre></td></tr><tr><td class="code"><pre><span class="line">    advert_int 1</span></pre></td></tr><tr><td class="code"><pre><span class="line">    unicast_src_ip 172.18.0.3</span></pre></td></tr><tr><td class="code"><pre><span class="line">    unicast_peer &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        1172.18.0.2</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    authentication &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        auth_type PASS</span></pre></td></tr><tr><td class="code"><pre><span class="line">        auth_pass 1111</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    virtual_ipaddress &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        172.18.0.10</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>主要有几点重要的地方，一个是<code>router_id</code>不能一样，这个是区分每个实力上的标志。</p>
<p>然后<code>state</code>可以都为<code>master</code>，即按照权重来强占。</p>
<p><code>interface</code>填写的是网卡名称，这个要结合自己实际的网卡名。</p>
<p><code>virtual_router_id</code>在同一个网络环境下不可以重复，不然会出问题。</p>
<p><code>priority</code>是权重，按照这个值来确定主节点。</p>
<p>一般采用单播的形式，方便配置而且不影响其他服务，所以两个配置文件中的<code>unicast_src_ip</code>和<code>unicast_peer</code>是相反的。</p>
<p><code>virtual_ipaddress</code>填写需要使用的虚拟IP就可以了。</p>
<p>如果是在容器中创建虚拟IP，有可能遇到错误：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">IPVS: Can&#39;t initialize ipvs: Protocol not available</span></pre></td></tr></table></figure>

<p>开启的必要条件有两个：</p>
<ol>
<li>容器放开权限，即添加参数<code>--privileged</code></li>
<li>宿主机同样需要开启<code>ipvasdm</code></li>
</ol>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>输入<code>ip a</code>应该就可以看到虚拟ip出现在网络信息中。</p>
<p>没有这个命令的话通过<code>yum install iproute</code>安装</p>
<h3 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h3><h4 id="MySQL状态监测脚本"><a href="#MySQL状态监测脚本" class="headerlink" title="MySQL状态监测脚本"></a>MySQL状态监测脚本</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">pgrep -x mysqld &amp;&gt; /dev/null</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> [ $? -ne 0 ]</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">then</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">echo</span> <span class="string">"not running"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">else</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">echo</span> <span class="string">"running"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">fi</span></span></pre></td></tr></table></figure>



<h4 id="Nginx状态监测脚本"><a href="#Nginx状态监测脚本" class="headerlink" title="Nginx状态监测脚本"></a>Nginx状态监测脚本</h4><h4 id="FastDFS检测脚本"><a href="#FastDFS检测脚本" class="headerlink" title="FastDFS检测脚本"></a>FastDFS检测脚本</h4><h4 id="FTP检测脚本"><a href="#FTP检测脚本" class="headerlink" title="FTP检测脚本"></a>FTP检测脚本</h4>]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>运维</tag>
        <tag>MySQL</tag>
        <tag>Keepalived</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解JVM虚拟机笔记</title>
    <url>/2019/01/01/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>本文是《深入理解JVM虚拟机》的读书笔记和摘要</p>
<a id="more"></a>

<h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><h3 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h3><p>根据Java1.7版本的虚拟机规范，Java虚拟机包括以下几个运行时数据区。</p>
<p><img src="http://nas.beritra.com:18081/uploads/big/28a3ed4f719f2d32c9c1ed4845a27b07.jpg" alt=""></p>
<h4 id="一、程序计数器"><a href="#一、程序计数器" class="headerlink" title="一、程序计数器"></a>一、程序计数器</h4><p>程序计数器(Program Counter Register)是一块较小的内存空间，可以看做当前线程所执行的字节码的行号指示器。分支、循环、跳转、异常处理、线程恢复等等都依赖于计数器完成。</p>
<p>每个线程拥有独立的计数器，互相不影响，独立存储。</p>
<p>执行Java方法的时候计数器记录的是虚拟机字节码指令的地址，如果执行的是Native方法，那么计数器则为空(Undefined)。该内存区域是唯一一个在Java虚拟机规范中没有规定任何<code>OutOfMemoryError</code>情况的区域。</p>
<h4 id="二、虚拟机栈"><a href="#二、虚拟机栈" class="headerlink" title="二、虚拟机栈"></a>二、虚拟机栈</h4><p>和程序计数器一样，Java虚拟机栈(Java Virtual Machine Stacks)也是线程私有的，它的生命周期和线程相同。虚拟机栈描述的是Java方法执行的内存模型：每个方法在执行的同时都会创建一个帧栈(Stack Frame)用来存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行完成，都对应着一个栈帧在虚拟机中入栈到出栈的过程。</p>
<p>常规把Java内存区分为堆内存和栈内存的方法过于粗糙，实际上的区域划分更加复杂。</p>
<p>局部变量表存放了编译期可知的各种基本类型(boolean、byte、char、short、int、float、long、double)、对象引用(reference类型，它不等同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置)、和<code>returnAddress</code>类型（指向一条字节码指令的地址）。</p>
<p>64位长度的long和double类型会占用两个局部变量空间（Slot）,其余的数据类型占用一个。进入一个方法的时候，局部表量表的大小就是确定的，运行期间不会在改变。</p>
<p>Java虚拟机规范中对这个区域规定了两种异常状况：如果线程请求的栈深度大于虚拟机所允许的深度，将会抛出<code>StackOverFlowError</code>异常。如果虚拟机栈可以动态扩展，扩展时无法申请足够内存，会抛出<code>OutOfMemoryError</code>异常。</p>
<p>总空间一定的情况下，局部变量表内容越多，栈帧越大，栈深度越小。进行大量递归的时候就有可能导致栈溢出。</p>
<h4 id="三、本地方法栈"><a href="#三、本地方法栈" class="headerlink" title="三、本地方法栈"></a>三、本地方法栈</h4><p>本地方法栈(Native Method Stack)和虚拟机栈作用很相似，两者区别是后者为Java方法（字节码）服务，前者则为虚拟机使用到的Native方法服务。有的虚拟机就干脆合二为一（Sun HotSpot虚拟机），本地方法栈可能抛出的异常也是上面那两个。</p>
<h4 id="四、Java堆"><a href="#四、Java堆" class="headerlink" title="四、Java堆"></a>四、Java堆</h4><p>对于多数应用来说，Java堆（Java Heap）是Java虚拟机管理的最大一块内存。Java堆被所有线程共享，在虚拟机启动的时候创建。此内存区域的唯一目的就是存放对象实例。Java虚拟机规范中规定所有的对象实例和数组都要在堆上分配，但是随着发展，现在变得并不这么绝对。</p>
<p>Java堆内存是垃圾收集管理器管理的主要区域，所以也成为GC堆。从内存回收的角度来看，现代收集器都采用分代收集算法，所以Java堆还可以细分为：新生代和老年代。再细致一点有Eden空间、From Survivor空间、To Survivor空间。</p>
<p>Java堆可以处在物理不连续的内存空间上，只要逻辑连续即可。</p>
<h4 id="五、方法区"><a href="#五、方法区" class="headerlink" title="五、方法区"></a>五、方法区</h4><p>方法区（Method Area）也是所有线程共享的内存区域，用于存储虚拟机加载的类信息、常量、静态变量、即时编译器编译的代码等数据。也称作Non-Heap非堆内存。</p>
<p>Java虚拟机规范堆方法区的限制非常宽松，可以选择不实现垃圾收集，但是这部分区域的回收确实是有必要的。</p>
<p>平时，说到永久带(PermGen space)的时候往往将其和方法区不加区别。这么理解在一定角度也说的过去。因为，《Java虚拟机规范》只是规定了有方法区这么个概念和它的作用，并没有规定如何去实现它。那么，在不同的 JVM 上方法区的实现肯定是不同的了。</p>
<p>同时，大多数用的JVM都是Sun公司的HotSpot。在HotSpot上把GC分代收集扩展至方法区，或者说使用永久代来实现方法区。</p>
<p>在JDK1.8及以后版本，永久带被移除，新出现的元空间（Metaspace）替代了它。元空间属于Native Memory Space</p>
<p>在1.8中，可以使用如下参数来调节方法区的大小</p>
<ul>
<li>XX:MetaspaceSize 元空间初始大小</li>
<li>XX:MaxMetaspaceSize 元空间最大大小<br>超过这个值将会抛出OutOfMemoryError异常:java.lang.OutOfMemoryError: Metadata space</li>
</ul>
<h4 id="六、运行时常量池"><a href="#六、运行时常量池" class="headerlink" title="六、运行时常量池"></a>六、运行时常量池</h4><p>运行时常量池（Runtime Constant Pool）是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池（Constant Pool Table），用于存放编译期生成的各种字面量和符号引用，这部分内容在类加载后进入方法区的运行时常量池中存放。</p>
<p>Java虚拟机堆Class文件的每一部分格式都有严格要求，要符合要求才能被虚拟机认、装载和执行。但是对于运行时常量池，Java虚拟机规范没有做任何细节要求。另外运行时常量池的一个重要特征就是具有动态性，运行期间可一个将新的常量放入池中 ，这种特性被开发人员利用得比较多的便是String类的<code>intern()</code>方法。</p>
<h4 id="七、直接内存"><a href="#七、直接内存" class="headerlink" title="七、直接内存"></a>七、直接内存</h4><p>直接内存（Direct Memory）不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域，但是也被频繁使用，也有可能导致<code>OutOfMemoryError</code>异常出现。</p>
<p>在JDK1.4中新加入的NIO类，引入了基于通道与缓冲区的I/O模式，可以使用Native函数库直接分配堆外内存，然后通过存储在Java堆中的<code>DirectByteBuffer</code>对象作为内存的引用进行操作。</p>
<p>这部分内存不受到Java堆大小的限制，但是仍然收到本机内存空间和处理器寻址空间的限制，也有可能出现<code>OutOfMemoryError</code>异常。</p>
<h3 id="对象创建过程"><a href="#对象创建过程" class="headerlink" title="对象创建过程"></a>对象创建过程</h3><h4 id="类加载"><a href="#类加载" class="headerlink" title="类加载"></a>类加载</h4><p>虚拟机遇到一条new指令的时候，会首先检查指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否被加载、解析和初始化过。如果没有，就限制性类加载过程。这个部分后续讨论。</p>
<h4 id="分配内存"><a href="#分配内存" class="headerlink" title="分配内存"></a>分配内存</h4><p>类加载检查完成之后，虚拟机会对新的对象分配内存。对象所需的内存大小在类加载完成之后就可以完全确定，为对象分配空间的任务等同于把一块确定大小的内存从堆内存中划分出来，这里有两种划分方式：</p>
<ul>
<li>如果内存绝对规整，分配内存就是把指针向后移动与对象大小相等的距离。这种方法叫做指针碰撞（Bump the Pointer）</li>
<li>如果堆中的内存不是规整的，已经使用的和空闲的内存相互交错，分配的时候就需要找到一块足够大的空间划分给对象实例，并维护一个列表记录地址。</li>
</ul>
<p>堆内存是否规整是由垃圾收集器是否带有压缩整理功能决定的。</p>
<p>除此之外，还需要考虑的是对象创建中线程安全的问题，假如两个线程同时移动内存指针，就有可能出现错误，解决这个问题也有两个方案：</p>
<ul>
<li>使用CAS搭配失败重试的方式保证更新操作的原子性。</li>
<li>或者把内存的分配动作按照线程划分在不同的空间之中进行，即每个线程在堆中预先分配一小块内存，成为本地内存分配缓冲区（Thread Local Allocation Buffer，TLAB），虚拟机是否启用TLAB可以用参数<code>-XX:+/-TLAB</code>来设定。</li>
</ul>
<h4 id="初始化信息"><a href="#初始化信息" class="headerlink" title="初始化信息"></a>初始化信息</h4><p>内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），如果使用<code>TLAB</code>，这一工作过程也可以提前至<code>TLAB</code>分配时进行。这一操作保证了对象的实例字段在Java代码中可以不赋初值就直接使用。</p>
<p> 然后，虚拟机需要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。这些信息存放在对象的对象头（Object Header）中，根据虚拟机当前的运行状态不同，比如是否启用偏向锁等，对象头会有不同的设置方式。</p>
<p>从虚拟机的视角，一个新的对象已经产生，但是从 Java 程序的视角来看，对象创建才刚刚开始，init 方法还没执行，所有字段还都为零。所以，执行 new 指令之后会接着执行 init 方法，把对象按照程序员意愿进行初始化。</p>
<h3 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h3><p>在 HotSpot 虚拟机中，对象可以分为三个区域：对象头（Header）、实例数据（Instance Date）和对齐填充（Padding）。</p>
<h4 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h4><p>HotSpot 虚拟机的对象头包括两部分信息：</p>
<ul>
<li>对象自身的运行时数据，如哈希码、GC 分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等，这部分数据在 32 位和 64 位虚拟机上分别为 32bit 和 64bit，官方称它为“Mark Word”。当对象需要存储的运营时数据很多时，它会根据对象的状态复用自己的存储空间。</li>
<li>类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。</li>
<li>如果对象是一个 Java 数组，那在对象头中还必须有一块记录数组长度的数据，因为虚拟机可以通过普通 Java 对象的原数据确定 Java 对象的大小，但是从数组的原数据中却无法确定。</li>
</ul>
<h4 id="实例数据"><a href="#实例数据" class="headerlink" title="实例数据"></a>实例数据</h4><p>实例数据是对象真正存储的有效信息，也就是在程序代码中所定义的各种类型的字段信息，无论从父类继承下来的，还是在子类中定义的，都需要记录起来。这部分的存储顺序收到虚拟机分配策略参数和在源码中定义的顺序影响。</p>
<h4 id="对齐填充"><a href="#对齐填充" class="headerlink" title="对齐填充"></a>对齐填充</h4><p>这部分不是必然存在，没有特殊的含义，仅仅起着占位符的作用。HotSpot VM 的自动内存管理系统要求对象其实地址必须是8字节的整数倍，因此当对象实例数据部分没有对齐的时候，就需要通过对齐填充来补全。</p>
<h3 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h3><p>对象建立之后，Java 程序需要通过栈上的 reference 数据来操作堆上的具体内容。由于 reference 类型在 Java 虚拟机规范中之规定了一个指向对象的引用，并没有定义这个引用应该如何定位、访问堆中对象的具体位置，所以对象访问方式取决于虚拟机如何实现，当前主流有使用句柄和直接指针两种。</p>
<ul>
<li><p>使用句柄访问的话，Java 堆中会单独划分一部分区域作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据和类型数据各自的具体地址信息。</p>
<p><img src="http://nas.beritra.com:18081/uploads/big/a51a8ecfaf1803cb16c4ea5f15600527.png" alt=""></p>
</li>
<li><p>如果使用直接指针访问，那么 Java 对对象的布局中就必须考虑如何放置访问类型数据的相关信息，而 reference 中存储的直接就是对象地址。</p>
<p><img src="http://nas.beritra.com:18081/uploads/big/b260fa468819f8dcb85ecf9cf51c73dd.png" alt=""></p>
</li>
</ul>
<p>这两种方式各有优势，使用句柄的好处是 reference 中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而 reference 本身不需要修改。</p>
<p>使用直接指针的最大好处是速度更快，节省了一次指针定位的开销。HotSpot 使用的是第二种方式。</p>
<h2 id="垃圾收集器和内存分配策略"><a href="#垃圾收集器和内存分配策略" class="headerlink" title="垃圾收集器和内存分配策略"></a>垃圾收集器和内存分配策略</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>垃圾收集出现的时间远比 Java 要早，从出现起，垃圾收集就需要考虑三个问题：</p>
<ul>
<li>哪些内存需要回收</li>
<li>什么时候回收</li>
<li>如何回收</li>
</ul>
<p>在Java内存运行时区域里，程序计数器、虚拟机栈、本地方法栈随线程而生，随线程而灭；栈中的栈帧随着方法的进入和退出有条不紊的进行出栈和入栈操作。每个栈帧中分配的内存基本是在类结构确定下来的时候就是已知的。Java 堆和方法区不一样，只有在运行时才知道创建那些对象，所以这部分内存的分配和回收都是动态的，垃圾收集器所关注的也是这部分内存。</p>
<h3 id="哪些内存需要回收"><a href="#哪些内存需要回收" class="headerlink" title="哪些内存需要回收"></a>哪些内存需要回收</h3><h4 id="引用计数器法"><a href="#引用计数器法" class="headerlink" title="引用计数器法"></a>引用计数器法</h4><p>引用计数器法是这样的：给对象添加一个引用计数器，每当有一个地方引用它时，计数器+1，引用失效的时候，计数器-1，任何时刻计数器为0的对象就不可能再被使用。</p>
<p>主流的Java虚拟机中没有选用这个方法来管理内存的，最主要的原因是很难解决对象循环引用的问题。</p>
<h4 id="可达性分析"><a href="#可达性分析" class="headerlink" title="可达性分析"></a>可达性分析</h4><p>主流的商用程序语言的主流实现中，都是通过可达性分析（Reachability Analysis）来判定对象是否存活的。这个算法的基本思路是通过一系列的成为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称之为引用链（Reference Chain），当一个对象到达GC Roots没有任何引用链相连时，证明此对象不可用。</p>
<h4 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h4><p>无论通过计数器，还是通过可达性分析，判断对象是否存活都与“引用”有关。在JDK1.2之后，Java对引用状态进行了扩充，将引用分为强引用（Strong Reference）、软引用（Soft Reference）、弱引用（Weak Reference）、虚引用（Phantom Reference）4种，这4种引用强度依次逐渐减弱。</p>
<ul>
<li>强引用就是指在代码中普遍存在的，类似于<code>Object obj=new Object()</code>这类引用，只要强引用还存在，垃圾收集器就永远不会回收被引用的对象。</li>
<li>软引用用来描述一些还有用但是不必须的对象。在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之内进行二次回收。如果这次回收之后还是没有足够内存，才会抛出内存溢出异常。</li>
<li>弱引用也是用来描述非必须对象达到，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾回收发生之前。当垃圾收集器工作的时候，无论当前内存是否充足，都会回收掉被弱引用关联的对象。</li>
<li>虚引用也称为幽灵引用或者幻影引用，是最弱的一种引用关系。一个对象是否有虚引用的的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用的唯一目的就是在这个对象被垃圾回收的时候收到一个系统通知。</li>
</ul>
<h4 id="生存还是死亡"><a href="#生存还是死亡" class="headerlink" title="生存还是死亡"></a>生存还是死亡</h4><p>即使在可达性分析算法中不可达的对象，也不是必定被回收，他们暂时处于“缓刑”阶段。要真正宣告一个对象死亡，至少要经历两次标记过程：第一次在可达性分析中发现没有引用链，会被标记并且进行筛选，筛选条件条件是此对象是否有必要执行<code>finalize()</code>方法。当对象没有覆盖<code>finalize()</code>方法或者已经被虚拟机调用过，虚拟机将这两种情况视为“没有必要执行”。</p>
<p>如果有必要执行，对象会被放置在一个叫F-Queue的队列中，稍后由一个虚拟机建立的、低优先级的Finalizer线程去执行。这个“执行”是指虚拟机触发这个方法，但是不承诺等待执行完毕。<code>finalize()</code>方法是对象逃脱死亡的最后一次机会，如果对象要在其中拯救自己，那么与任何一个引用链上的对象建立关联即可。如果建立的关联，比如将自己赋值给了某个类变量，那么第二次标记的时候就会被移除“即将回收”的集合。</p>
<h3 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h3><p>由于垃圾收集算法的实现涉及大量的程序细节，而且各个平台的虚拟机操作内存的方法有各不相同，所以只介绍几种算法的思想和发展过程。</p>
<h4 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h4><p>最基础的算法是“标记-清除”（Mark-Sweep）算法，如名字一样，算法分为“标记”和“清除”两个阶段：首先标记需要回收的对象，然后统一回收。他是最基础的收集算法，但是主要有两点不足：</p>
<ul>
<li>效率问题，标记和清除效率都不高</li>
<li>空间问题，标记清除之后会有大量的不连续内存碎片，空间碎片太多导致后续分配大对象内存的时候，无法找到足够的连续内存而不得不触发另一次垃圾收集动作。</li>
</ul>
<h4 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h4><p>复制算法提高了效率，他可以将内存按照容量划分为大小相等的两块，每次使用其中一块。当一块的内存用完之后，把存活的对象移动到另一块，然后把已经使用的空间一次性清理掉。这个方式实现简单运行高效，但是代价是内存缩小为原来的一半。</p>
<p>现在的商业虚拟机都是采用这种收集算法来回收新生代，由于98%的对象都是“朝生夕死”的，所以不需要1:1的比例划分内存空间，而是划分一块较大的Eden和两块较小的Survivor空间，每次使用Eden和其中一块Survivor。回收的时候，将Eden和Survivor中还存活的对象一次性复制到另一块Survivor中，然后清理掉Eden和使用的Survivor空间。HotSpot虚拟机中默认的Eden和Survivor空间比例划分是8:1。但是，98%的对象可回收只是一般场景下的数据，我们不能保证每次回收都是这样，所以当Survivor空间不够使用时，需要依赖其他内存（这里指老年代）进行分配担保（Handle Promotion）。</p>
<p>当一块Survivor空间中没有足够的空间存放上一次新生代收集下来的存活对象的时候，这些对象会直接通过分配担保机制进入老年代。</p>
<h4 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h4><p>复制收集算法在对象存活率较高的时候就要进行较多的复制操作，效率将会变低。更关键的是如果不想浪费50%的空间，就需要额外空间进行担保，所以老年代不能直接选用这种算法。</p>
<p>根据老年代的特点，有人提出了另外一种“标记-整理”算法，标记过程与“标记-清除”一样，但是后续不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。</p>
<h4 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h4><p>当代商业虚拟机的垃圾收集都是采用分代收集（Generational Collection）算法，根据对象存活周期将不同内存划分为几块。一般是把Java堆分为新生代和老年代，这样可以根据各个年代的特点采用最适当的收集算法。在新生代中，每次垃圾收集都有大量的对象死去，只有少量存活，那就选用复制算法。而老年代存活率高、没有额外空间进行担保，就必须使用“标记-清理”或者“标记-整理”算法来回收。</p>
<h3 id="HotSpot算法实现"><a href="#HotSpot算法实现" class="headerlink" title="HotSpot算法实现"></a>HotSpot算法实现</h3><h4 id="枚举根节点"><a href="#枚举根节点" class="headerlink" title="枚举根节点"></a>枚举根节点</h4><p>可以作为GC Roots的节点主要在全局的引用（例如常量或者静态属性）与执行上下文（栈帧中的本地变量表）中，如果逐个检查里面的引用，会耗费很多时间。</p>
<p>另外，可达性分析对执行的敏感还体现在GC的停顿上，这项分析工作必须在能确保一致性的快照中进行，不可以出现分析过程中对象还在不断变化的情况。所以这导致GC进行时需要停顿所有的Java执行线程（Sun将这个事情称为“Stop The Word”）</p>
<p>由于目前主流的Java虚拟机使用的都是准确式GC，所以当执行系统停顿下来之后，不需要一个不漏的检查玩所有执行上下文和全局的引用位置，虚拟机有办法直接得知哪些地方存放着对象引用。在HotSpot的实现中，是通过使用一组称为OopMap的数据接口来达到这个目的。在类加载完成的时候，HotSpot就把对象内偏移量上是什么类型的数据计算出来，在JIT编译过程中，也会在特定的位置记录下帧和寄存器中哪些位置是引用的。</p>
<h4 id="安全点"><a href="#安全点" class="headerlink" title="安全点"></a>安全点</h4><p>在OopMap的帮助下，HotSpot可以快速的完成GC Root的枚举，但是随着引用变化，不可能每次指令都生成新的OopMap。实际上只有“特定的位置”才会暂停开始GC，这个位置叫做安全点（Safepoint）。Safepoint的选定既不能太少以至于GC等待时间过长，也不能太频繁以至于增大运行时负荷。</p>
<p>对于Safepoint另一个需要考虑的问题是如何在GC发生时让所有线程都跑在最近的安全点上再停下来。这里有两个方案：</p>
<ul>
<li>抢先式中断（Preemptive Suspension）：不需要线程的执行代码主动配合，GC发生的时候先中断全部线程，如果发现有的线程中断地方不在安全点上，就恢复线程，让他跑到安全点上。现在几乎没有虚拟机实现抢先式中断来暂停线程。</li>
<li>主动式中断（Voluntary Suspension）：当GC需要中断线程的时候，不直接对线程操作，而是仅仅设置一个标志，各个线程主动轮询这个标志，发现标志为真的时候主动中断挂起。轮讯标志的地方和安全点是重合的。</li>
</ul>
<h4 id="安全区域"><a href="#安全区域" class="headerlink" title="安全区域"></a>安全区域</h4><p>程序执行的时候，通过Safepoint可以解决如何进入GC的问题，但是程序“不执行”的时候呐？比如线程处于Sleep状态或者Blocked状态，这时候线程无法相应JVM的中断请求，JVM也不太可能等待线程被重新分配CPU时间。对于这种情况，需要安全区域（Safe Region）来解决。</p>
<p>安全区域是指在一段代码中，引用关系不会发生变化，在这个区域中的任何位置进行GC都是安全的。当线程执行到Safe Region中的代码时，会标识自己已经进入了Safe Region，这样发起GC的时候就不用管进入Safe Region状态的线程了。</p>
<h3 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h3><p>如果说收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。</p>
<p>常见的垃圾收集器有以下几种：</p>
<p><img src="http://nas.beritra.com:18081/uploads/big/b5af81a71b8415ae3b4d6378cdd3019f.jpeg" alt=""></p>
<p>他们分别适用于不同分代，连线说明可以配合使用。</p>
<p>jdk1.7 默认垃圾收集器Parallel Scavenge（新生代）+Serial Old（老年代）</p>
<p>jdk1.8 默认垃圾收集器Parallel Scavenge（新生代）+Serial Old（老年代）</p>
<p>jdk1.9 默认垃圾收集器G1</p>
<p>jdk10 默认垃圾收集器G1</p>
<h4 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h4><p>Serial收集器是最基本、历史最悠久的收集器。它是一个单线程收集器，不仅仅是说只是用一个CPU进行垃圾收集工作，更重要的是进行垃圾收集的时候，必须暂停 其他所有工作线程直到收集结束。</p>
<p>Serial依然是Client模式下新生代默认的收集器，他也有着优于其他收集器的地方：简单而高效（单线程环境下）。</p>
<h4 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h4><p>ParNew其实就是Serial收集器的多线程版本，除了使用多条线程进行垃圾收集之外，其余行为包括Serial收集器可用的所有控制参数、收集算法、Stop The Wrokd、对象分配规则、回收策略等都与Serial收集器完全一样。</p>
<p>ParNew是许多运行在Server模式下的虚拟机中首选的新生代收集器，有一个重要的原因是除了Serial收集器外，它是唯一能与CMS收集器配合工作。ParNew在单CPU环境中不会比Serial有更好的效果，甚至由于线程切换的开销可能性能更低。</p>
<h4 id="Parallel-Scavenge收集器"><a href="#Parallel-Scavenge收集器" class="headerlink" title="Parallel Scavenge收集器"></a>Parallel Scavenge收集器</h4><p>Parallel Scavenge收集器是一个新生代收集器，也是使用复制算法的收集器，又是并行的多线程收集器。</p>
<p>Parallel Scavenge收集器的特点是它的关注点与其他收集器不同，CMS等收集器的关注点是尽可能缩短垃圾收集时用户线程的停顿时间，而Parallel Scavenge收集器的目的是达到一个可控制的吞吐量（Throughput）。所谓吞吐量就是CPU用于运行用户代码的时间和总的消耗时间的比值。虚拟机总共运行了100分钟，99分钟用来运行代码，1分钟垃圾收集，那么吞吐量就是99%。</p>
<p>Parallel Scavenge收集器提供了两个参数进行进准控制吞吐量，分别是控制最大垃圾收集停顿时间的<code>-XX:MaxGCPauseMillis</code>参数以及直接设置吞吐量大小的<code>-XX:GCTimeRatio</code>参数。</p>
<p><code>MaxGCPauseMillis</code>参数允许的值是一个大于0的毫秒数，收集器将尽可能的保证内存回收花费的时间不超过设定值。但是这个值不是越小越好，GC停顿时间缩短是以牺牲吞吐量和新生代空间换取的，停顿时间降下来很可能吞吐量也下降了。</p>
<p><code>GCTimeRatio</code>参数的值应当是一个大于0且小于100的整数，也就是垃圾收集时间占总时间的比率，相当于吞吐量的倒数。</p>
<h4 id="Serial-Old收集器"><a href="#Serial-Old收集器" class="headerlink" title="Serial Old收集器"></a>Serial Old收集器</h4><p>Serial Old是Serial收集器的老年代版本，他同样是一个单线程收集器，使用“标记-整理”算法。这个收集器的主要意义也是给Client模式下的虚拟机使用。</p>
<h4 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h4><p>CMS（Concurrent Mark Sweep）收集器是一种以最短回收停顿时间为目标的收集器。从名字就可以看出，CMS收集器是基于“标记-清除”算法实现的，它的运作过程相对于前面几个收集器来说更复杂一点，整个过程分为4个步骤：</p>
<ul>
<li>初始标记（initial mark）</li>
<li>并发标记（concurrent mark）</li>
<li>重新标记（remark）</li>
<li>并发清除（concurrent sweep）</li>
</ul>
<p>其中，初始标记和重新标记仍然需要“Stop The World”。初始标记仅仅标记一下GC Roots能直接关联到的对象，速度很快，并发标记阶段是进行GC Roots Tracing的过程，而重新标记则是为了修正并发标记期间用户程序继续运作而导致的标记变动，这个阶段的停顿时间一般会比初始阶段稍长，但是远比并发标记阶段耗时短。</p>
<p>由于整个过程中耗时最长的并发标记和并发清除过程都可以和用户线程一起工作，所以总体来说CMS收集器的内存回收过程是和用户线程一起并发执行的。</p>
<p>但是，CMS同样有以下明显的缺点：</p>
<ul>
<li><p>CMS收集器对CPU资源非常敏感，默认启动了（CPU数量+3）/4个线程执行回收，也就是当CPU在4个以上并发回收时收集线程占用不少于25%的CPU资源，并且随着CPU数量增加而下降。CPU数量少的时候对用户的影响就很大了。</p>
</li>
<li><p>CMS无法处理浮动垃圾（Floating Garbage），可能出现<code>Concurrent Mode Failure</code>失败而导致另一个Full GC产生。即CMS在并发清除过程中产生的新的垃圾，只能在下一次GC时再处理。</p>
</li>
<li><p>最后一个缺点，由于CMS基于“标记-清除”算法实现，意味着收集结束可能会有大量的空间碎片产生。空间碎片过多会对大内存分配产生麻烦，导致分配内存的时候不得不提前触发Full GC。</p>
</li>
</ul>
<h4 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h4><p>G1是jdk9版本之后JVM默认的垃圾收集器，它具有以下特点：</p>
<ul>
<li>并行和并发：G1可以充分利用多CPU、多核环境下的硬件优势，使用多个CPU来缩短Stop The World停顿的时间。</li>
<li>分代收集：分代概念仍然在G1中保留，但是G1可以不需要与其他收集器配合独自管理整个GC堆。</li>
<li>空间整合：与CMS的“标记-清理”算法不同，G1从整体上看是基于“标记-整理”算法实现，但是从局部（两个Region）来看是基于“复制”算法实现的。无论如何，这两种算法一位置G1运作期间不会产生内存碎片，收集完成后可以提供规整可用的内存。</li>
<li>可预测的停顿：这是G1相对于CMS的另一大优势，G1除了追求低停顿之外，还能建立可预测的停顿时间模型，让使用者明确指定在一个长度为M毫秒的时间片断内，消耗在垃圾收集上的时间不超过N毫秒。</li>
</ul>
<p>G1之前的收集器进行收集的范围都是整个新生代或者老年代，而G1不再是这样。使用G1收集器时，Java堆内存的布局就与其他收集器有很大差别，他将整个Java堆划分为多个大小相等的独立区域（Region）虽然还保留新生代和老年代的概念，但是新生代和老年代不再是物理隔离，都是一部分Region（不需要连续）的集合。</p>
<p>G1收集器之所以能建立可预测的时间模型，因为它有计划地避免在整个Java堆中进行全区域的垃圾收集。G1追踪各个Region里面垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次根据允许的时间优先回收价值最大的Region。</p>
<p>在G1收集器中，Region之间的对象应用以及其他收集器中的新生代及老年代之间的对象引用，虚拟机都是使用Remembered Set来避免全堆扫描的。G1中每个Region都有一个与之对应的Remembered Set，虚拟机发现程序对Reference类型的数据进行写操作的时候，会产生一个Write Barrier暂时中断写操作，检查Reference引用的对象是否处于不同的Region之中，如果是，就通过CardTable把相关引用信息记录到被引用的对象所属的Region的Remembered Set中。内存回收的时候，在GC根节点的枚举范围中加入Remembered Set即可保证不对全堆扫描也不会有遗漏。</p>
<p>除了维护Remembered Set的操作，G1收集器的运作大致可以分为以下几个步骤：</p>
<ul>
<li>初始标记（Initial Marking）</li>
<li>并发标记（Concurrent Marking）</li>
<li>最终标记（Final Marking）</li>
<li>筛选回收（Live Data Counting and Evacuation）</li>
</ul>
<p>可以看出这几个步骤的运作过程和CMS有很多相似之处。初始标记阶段只是标记一下GC Roots能直接关联到的对象，并且修改TAMS（Next Top at Mark Star）的值，让下一阶段用户程序并发运行的时候，能在正确可用的Region中创建对象，这个阶段需要停顿线程，但是耗时很短。并发标记阶段是从GC Roots开始进行可达性分析，这个阶段耗时较长但是可以和用户程序并发执行。最终标记阶段则是修正并发标记阶段产生的标记变动，合并到Remembered Set中。这个阶段需要停顿线程，但是可以并行执行。最后筛选阶段首先对各个Region的回收价值和成本排序，根据用户指定的GC停顿时间来制定回收计划。</p>
<h4 id="GC日志"><a href="#GC日志" class="headerlink" title="GC日志"></a>GC日志</h4><p>一般情况可以通过两种方式来获取GC日志，一种是使用命令动态查看，一种是在容器中设置相关参数打印GC日志。</p>
<p>可以通过jstat命令查看当前正在运行的Java进程的GC状态，命令如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">jstat -gc java进程号 毫秒单位的时间间隔</span></pre></td></tr></table></figure>

<p>结果含义：</p>
<pre><code>S0C：年轻代中第一个survivor（幸存区）的容量 (字节) 
S1C：年轻代中第二个survivor（幸存区）的容量 (字节) 
S0U：年轻代中第一个survivor（幸存区）目前已使用空间 (字节) 
S1U：年轻代中第二个survivor（幸存区）目前已使用空间 (字节) 
EC：年轻代中Eden（伊甸园）的容量 (字节) 
EU：年轻代中Eden（伊甸园）目前已使用空间 (字节) 
OC：Old代的容量 (字节) 
OU：Old代目前已使用空间 (字节) 
PC：Perm(持久代)的容量 (字节) 
PU：Perm(持久代)目前已使用空间 (字节) 
YGC：从应用程序启动到采样时年轻代中gc次数 
YGCT：从应用程序启动到采样时年轻代中gc所用时间(s) 
FGC：从应用程序启动到采样时old代(全gc)gc次数 
FGCT：从应用程序启动到采样时old代(全gc)gc所用时间(s) 
GCT：从应用程序启动到采样时gc用的总时间(s) 
NGCMN：年轻代(young)中初始化(最小)的大小 (字节) 
NGCMX：年轻代(young)的最大容量 (字节) 
NGC：年轻代(young)中当前的容量 (字节) 
OGCMN：old代中初始化(最小)的大小 (字节) 
OGCMX：old代的最大容量 (字节) 
OGC：old代当前新生成的容量 (字节) 
PGCMN：perm代中初始化(最小)的大小 (字节) 
PGCMX：perm代的最大容量 (字节)   
PGC：perm代当前新生成的容量 (字节) 
S0：年轻代中第一个survivor（幸存区）已使用的占当前容量百分比 
S1：年轻代中第二个survivor（幸存区）已使用的占当前容量百分比 
E：年轻代中Eden（伊甸园）已使用的占当前容量百分比 
O：old代已使用的占当前容量百分比 
P：perm代已使用的占当前容量百分比 
S0CMX：年轻代中第一个survivor（幸存区）的最大容量 (字节) 
S1CMX ：年轻代中第二个survivor（幸存区）的最大容量 (字节) 
ECMX：年轻代中Eden（伊甸园）的最大容量 (字节) 
DSS：当前需要survivor（幸存区）的容量 (字节)（Eden区已满） 
TT： 持有次数限制 
MTT ： 最大持有次数限制 </code></pre><h4 id="GC参数"><a href="#GC参数" class="headerlink" title="GC参数"></a>GC参数</h4><p>JVM的GC日志的主要参数包括如下几个：</p>
<ul>
<li><code>-XX:+PrintGC</code> 输出GC日志</li>
<li><code>-XX:+PrintGCDetails</code> 输出GC的详细日志</li>
<li><code>-XX:+PrintGCTimeStamps</code> 输出GC的时间戳（以基准时间的形式）</li>
<li><code>-XX:+PrintGCDateStamps</code> 输出GC的时间戳（以日期的形式，如 2017-09-04T21:53:59.234+0800）</li>
<li><code>-XX:+PrintHeapAtGC</code> 在进行GC的前后打印出堆的信息</li>
<li><code>-Xloggc:../logs/gc.log</code> 日志文件的输出路径</li>
</ul>
<p>在生产环境中，根据需要配置相应的参数来监控JVM运行情况</p>
<h3 id="内存分配和回收策略"><a href="#内存分配和回收策略" class="headerlink" title="内存分配和回收策略"></a>内存分配和回收策略</h3><p>Java的内存管理可以归结为内存的自动分配和自动回收，上面讲了内存回收的策略，下面再说一下内存分配。</p>
<h4 id="对象优先在Eden分配"><a href="#对象优先在Eden分配" class="headerlink" title="对象优先在Eden分配"></a>对象优先在Eden分配</h4><p>大多数情况下，对象在新生代Eden区中分配，当Eden区没足够空间的时候，虚拟机将发起一次Mino GC。</p>
<p>虚拟机提供了<code>-XX:+PrintGCDetail</code>这个参数，告诉虚拟机在发生垃圾内存收集行为的时候打印内存回首日志，并且在进程退出的时候输出当前内存各个区域的分配情况。</p>
<h4 id="大对象直接进入老年代"><a href="#大对象直接进入老年代" class="headerlink" title="大对象直接进入老年代"></a>大对象直接进入老年代</h4><p>所谓大的对象是指需要大量连续空间的Java对象，最典型的是很长的字符串和数组。</p>
<p>虚拟机提供了<code>-XX:PretenureSizeThreshold</code>参数，另大于这个设置值的对象直接在老年代分配。目的是避免Eden区及两个Survivor区之间大量的内存复制。</p>
<h4 id="长期存活的对象进入老年代"><a href="#长期存活的对象进入老年代" class="headerlink" title="长期存活的对象进入老年代"></a>长期存活的对象进入老年代</h4><p> 为了分配哪些对象放在新生代，哪些放在老年代，虚拟机给每个对象定义了一个对象年龄（Age）计数器，如果对象在Eden出生并经过第一次 Minor GC 后仍然存活，并且能被Survivor容纳的话，将被移动到 Survivor 空间中，并且对象年龄设为1。对象在 Survivor 中每经过一次 Minor GC，年龄就增加一岁，当年龄增加到一定程度（默认是 15 岁），就会被晋升到老年代，这个阈值可以通过参数<code>-XX:MaxTenuringThreshold</code>设置。</p>
<h4 id="动态对象年龄判定"><a href="#动态对象年龄判定" class="headerlink" title="动态对象年龄判定"></a>动态对象年龄判定</h4><p>为了适应不同程序的内存状况，不是只有对象年龄大于 MaxTenuringThreshold 才能晋升老年代。如果 Survivor 空间中相同年龄所有对象大小总和大于 Survivor 空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代。</p>
<h4 id="空间分配担保"><a href="#空间分配担保" class="headerlink" title="空间分配担保"></a>空间分配担保</h4><p>在发生 Minor GC 之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有的对象总空间，如果这个条件成立，那么 Minor GC 可以确保是安全的。如果不成立，则虚拟机会查看<code>HandlePromotionFailure</code>设置值是否允许担保失败。如果允许，那么会继续检查老年代最大可用的连续空间是否大于晋升到老年代对象的平均大小。如果大于就尝试进行一次 Minor GC，尽管这次 GC 是有风险的。如果小于，或者不允许冒险，就改为进行一次 Full GC。</p>
<h2 id="虚拟机性能监控和故障处理"><a href="#虚拟机性能监控和故障处理" class="headerlink" title="虚拟机性能监控和故障处理"></a>虚拟机性能监控和故障处理</h2><h3 id="命令行工具"><a href="#命令行工具" class="headerlink" title="命令行工具"></a>命令行工具</h3><table>
<thead>
<tr>
<th align="center">名称</th>
<th align="center">主要作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">jps</td>
<td align="center">JVM Process Status Tool，显示制定系统内所有的HotSpot虚拟机进程</td>
</tr>
<tr>
<td align="center">jstat</td>
<td align="center">JVM Statistics Monitoring Tool，用于收集HotSpot虚拟机各方面的运行数据</td>
</tr>
<tr>
<td align="center">jinfo</td>
<td align="center">Configuration Info for Java，显示虚拟机配置信息</td>
</tr>
<tr>
<td align="center">jmap</td>
<td align="center">Memory Map for Java，生成虚拟机的内存转储快照（heapdump文件）</td>
</tr>
<tr>
<td align="center">jhat</td>
<td align="center">JVM Heap Dump Browser，用于分析heapdump文件，它会建立一个HTTP/HTML服务器，让用户可以在浏览器上查看分析结果</td>
</tr>
<tr>
<td align="center">jstack</td>
<td align="center">Stack Track for Java，显示虚拟机的线程快照</td>
</tr>
</tbody></table>
<h4 id="jps：虚拟机进程状况工具"><a href="#jps：虚拟机进程状况工具" class="headerlink" title="jps：虚拟机进程状况工具"></a>jps：虚拟机进程状况工具</h4><p>jps除了名字像ps命令之外，功能也很类似：可以列出正在运行的虚拟机进程，并且显示虚拟机执行主类（Main Class，Main()函数所在的类）名称以及这些进程的本地虚拟机唯一ID（Local Virtual Machine Identifier，LVMID）。虽然功能简单，但是它是最常用的工具，因为其他JDK工具需要输入它查询出来的LVMID来确定监控的是哪个虚拟机进程。在本地虚拟机进程来说，LVMID和ps命令或者Windows中任务管理器中查到的进程号是一致的。但是如果启动了多个虚拟机进程，就要依赖jps命令根据主类来区分了。</p>
<table>
<thead>
<tr>
<th align="center">选项</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">-q</td>
<td align="center">只输出LVMID，省略主类的名称</td>
</tr>
<tr>
<td align="center">-m</td>
<td align="center">输出虚拟机级进程启动的时候传给主类main()函数的参数</td>
</tr>
<tr>
<td align="center">-l</td>
<td align="center">输出主类的全名，如果进程执行的是Jar包，输出Jar包路径</td>
</tr>
<tr>
<td align="center">-v</td>
<td align="center">输出虚拟机进程启动时JVM参数</td>
</tr>
</tbody></table>
<h4 id="jstat：虚拟机统计信息监视工具"><a href="#jstat：虚拟机统计信息监视工具" class="headerlink" title="jstat：虚拟机统计信息监视工具"></a>jstat：虚拟机统计信息监视工具</h4><p>jstat（JVM Statistics Monitoring Tool）适用于监视虚拟机各种运行状态信息的命令行工具。它可以显示本地或远程虚拟机中的类装载、内存、垃圾收集、JIT编译等运行数据。</p>
<p>jstat命令格式为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">jstat -&lt;option&gt; [-t] [-h&lt;lines&gt;] &lt;vmid&gt; [&lt;interval&gt; [&lt;count&gt;]]</span></pre></td></tr></table></figure>

<p>对于命令格式中的VMID与LVMID需要说明的是，如果是本地虚拟机进程，VMID与LVMID是一致的，如果远程的虚拟机进程，VMID格式应当是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[protocol]:[&#x2F;&#x2F;]lvmid[@hostname[:port]&#x2F;servername]</span></pre></td></tr></table></figure>

<p>参数interval和count代表查询间隔和次数，如果省略这两个参数，说明只查询一次。</p>
<p>选项option代表着用户希望查询的虚拟机信息，主要分为3类：类装载、垃圾收集、运行期编译状况。</p>
<table>
<thead>
<tr>
<th align="center">选项</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">-class</td>
<td align="center">监视类装载、卸载数量、总空间以及类装载所耗费的时间</td>
</tr>
<tr>
<td align="center">-gc</td>
<td align="center">监视Java堆状况，包括Eden区、两个survivor区、老年代、永久带等的容量、已用空间、GC时间合计等信息</td>
</tr>
<tr>
<td align="center">-gccapacity</td>
<td align="center">监视内容与-gc基本相同，但是输出主要关注Java堆各个区域使用的最大、最小空间</td>
</tr>
<tr>
<td align="center">-gcutil</td>
<td align="center">监视内容与-gc基本相同，但是输出主要关注已使用空间占总空间的百分比</td>
</tr>
<tr>
<td align="center">-gccause</td>
<td align="center">与gcutil功能一样，但是会额外输出导致上一次GC产生的原因</td>
</tr>
<tr>
<td align="center">-gcnew</td>
<td align="center">监视新生代GC状况</td>
</tr>
<tr>
<td align="center">-gcnewcapacity</td>
<td align="center">监视内容与-gcnew基本相同，输出主要关注使用到的最大、最小空间</td>
</tr>
<tr>
<td align="center">-gcold</td>
<td align="center">监视老年代GC状况</td>
</tr>
<tr>
<td align="center">-gcoldcapacity</td>
<td align="center">监视内容与-gcold基本相同，输出主要关注使用到的最大、最小空间</td>
</tr>
<tr>
<td align="center">-gcpermcapaciry</td>
<td align="center">输出到永久带使用到的最大、最小空间。注意，由于永久带在JDK1.8之后已经被元空间替代，所以1.8之后都没有了这个选项</td>
</tr>
<tr>
<td align="center">-compiler</td>
<td align="center">输出JIT编译器编译过的方法、耗时等信息</td>
</tr>
<tr>
<td align="center">-printcompilation</td>
<td align="center">输出已经被JIT编译的方法</td>
</tr>
</tbody></table>
<h4 id="jinfo：Java配置信息工具"><a href="#jinfo：Java配置信息工具" class="headerlink" title="jinfo：Java配置信息工具"></a>jinfo：Java配置信息工具</h4><p>jinfo（Configuration Info for Java）的作用是实时地查看和调整虚拟机各项参数。</p>
<p>用法如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Usage:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    jinfo [option] &lt;pid&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        (to connect to running process)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    jinfo [option] &lt;executable &lt;core&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        (to connect to a core file)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    jinfo [option] [server_id@]&lt;remote server IP or hostname&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        (to connect to remote debug server)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">where</span> &lt;option&gt; is one of:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    -flag &lt;name&gt;         to <span class="built_in">print</span> the value of the named VM flag</span></pre></td></tr><tr><td class="code"><pre><span class="line">    -flag [+|-]&lt;name&gt;    to <span class="built_in">enable</span> or <span class="built_in">disable</span> the named VM flag</span></pre></td></tr><tr><td class="code"><pre><span class="line">    -flag &lt;name&gt;=&lt;value&gt; to <span class="built_in">set</span> the named VM flag to the given value</span></pre></td></tr><tr><td class="code"><pre><span class="line">    -flags               to <span class="built_in">print</span> VM flags</span></pre></td></tr><tr><td class="code"><pre><span class="line">    -sysprops            to <span class="built_in">print</span> Java system properties</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &lt;no option&gt;          to <span class="built_in">print</span> both of the above</span></pre></td></tr><tr><td class="code"><pre><span class="line">    -h | -<span class="built_in">help</span>           to <span class="built_in">print</span> this <span class="built_in">help</span> message</span></pre></td></tr></table></figure>

<p>比如使用<code>-flag</code>查看JVM参数<br> <code>jinfo -flag MaxMetaspaceSize 18348</code>，得到结果<code>-XX:MaxMetaspaceSize=536870912</code>，即MaxMetaspaceSize为512M<br><code>jinfo -flag ThreadStackSize 18348</code>，得到结果<code>-XX:ThreadStackSize=256</code>，即Xss为256K</p>
<p>jinfo也可以调整JVM参数：</p>
<p>如果是布尔类型的JVM参数: jinfo -flag [+|-]<name>  PID，enable or disable the named VM flag<br> 如果是数字/字符串类型的JVM参数    jinfo  -flag <name>=<value> PID，to set the named VM flag to the given value</p>
<p>那么怎么知道有哪些JVM参数可以动态修改呐？可以用下面这个命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Linux环境：java -XX:+PrintFlagsInitial | grep manageable</span></pre></td></tr><tr><td class="code"><pre><span class="line">Window环境：java -XX:+PrintFlagsInitial | findstr manageable</span></pre></td></tr></table></figure>



<h4 id="jmap：Java内存映像工具"><a href="#jmap：Java内存映像工具" class="headerlink" title="jmap：Java内存映像工具"></a>jmap：Java内存映像工具</h4><p>jmap（Memory Map for Java）命令用于生成堆转储快照（一般称为heapdump或者dump文件）。如果不适用jmap命令，想要获取Java堆转储快照，还有一些比较暴力的手段：比如使用<code>-XX:+HeapDumpOnOutOfMemoryError</code>参数，可以让虚拟机在OOM异常出现之后自动生成dump文件，通过<code>-XX:+HeapDumpOnCtrlBreak</code>参数则可以使用[ctrl]+[Break]键让虚拟机生成dump文件，又或者在Linux系统下通过<code>Kill -3</code>命令发送进程退出信号“吓唬”一下虚拟机，也能拿到dump文件。</p>
<p>除此之外，jmap还可以查询finalize执行队列，Java堆和永久带的详细信息，如空间使用率、当前使用的哪种收集器等。</p>
<p>jmap命令格式：</p>
<p><code>jmap [option] vmid</code></p>
<p>option选项的合法值与具体含义如下：</p>
<table>
<thead>
<tr>
<th align="center">选项</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">-dump</td>
<td align="center">生成Java堆转储快照。格式为：<code>-dump:[live, ]format=b，files=&lt;filename&gt;</code>，其中live子参数说明是否只dump出存活的对象</td>
</tr>
<tr>
<td align="center">-finalizerinfo</td>
<td align="center">显示在F-Queue中等待FInalizer线程执行finalizer方法的对象。只在Linux/Solaris平台下有效</td>
</tr>
<tr>
<td align="center">-heap</td>
<td align="center">显示Java堆详细信息，如使用哪种回收器、参数配置、分代状况等。只在Linux/Solaris平台下有效。</td>
</tr>
<tr>
<td align="center">-histo</td>
<td align="center">显示堆中对象统计信息，包括类、实例数量、合计容量</td>
</tr>
<tr>
<td align="center">-permstat</td>
<td align="center">以ClassLoader为统计口径显示永久带内存状态。只在Linux/Solaris平台下有效</td>
</tr>
<tr>
<td align="center">-F</td>
<td align="center">当虚拟机进程没有对-dump选项响应时，可以使用这个选项强制生成dump快照。只在Linux/Solaris平台下有效</td>
</tr>
<tr>
<td align="center">-clstats</td>
<td align="center">打印类加载器的统计信息</td>
</tr>
<tr>
<td align="center">-J</td>
<td align="center">传递参数给jmap的JVM</td>
</tr>
</tbody></table>
<h4 id="jhat：虚拟机堆转储快照分析工具"><a href="#jhat：虚拟机堆转储快照分析工具" class="headerlink" title="jhat：虚拟机堆转储快照分析工具"></a>jhat：虚拟机堆转储快照分析工具</h4><p>Sun  JDK提供jhat（JVM Heap Analysis Tool）命令与jmap搭配使用，来分析jmap生成的堆转储快照。jhatm内置了一个微型的HTTP/HTML服务器，生成dump文件的分析成果后，可以在浏览器中查看。</p>
<p>执行命令<code>jhatp 文件名</code>，屏幕显示<code>Server is ready</code>的提示后，打开浏览器localhost的7000端口就可以看到分析结果。</p>
<h4 id="jstack：Java堆栈跟踪工具"><a href="#jstack：Java堆栈跟踪工具" class="headerlink" title="jstack：Java堆栈跟踪工具"></a>jstack：Java堆栈跟踪工具</h4><p>jstack（Stack Track for Java）命令用于生成虚拟机当前时刻的线程快照（一般称为threaddump或者javacore文件）。线程快照就是当前虚拟机内每一条线程正在执行的方法堆栈的集合，生成快照的主要目的是定位线程出现长时间停顿的原因，如线程死锁、死循环、请求外部资源导致的长时间等待等。</p>
<p>jstack命令的格式：</p>
<p><code>jstack [option] vmid</code></p>
<table>
<thead>
<tr>
<th align="center">选项</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">-F</td>
<td align="center">当正常输出的请求不被相应时，强制输出线程堆栈</td>
</tr>
<tr>
<td align="center">-l</td>
<td align="center">除堆栈外，显示关于锁的附加信息</td>
</tr>
<tr>
<td align="center">-m</td>
<td align="center">如果调用本地方法的话，可以显示C/C++的堆栈</td>
</tr>
</tbody></table>
<p><code>java.lang.Thread</code>类的<code>getAllStackTraces()</code>方法可以获取所有线程的<code>StackTraceElement</code>对象。使用这个方法可以用简单的几行代码完成jstack的大部分功能。</p>
<h4 id="Jconsole：Java监视与管理控制台"><a href="#Jconsole：Java监视与管理控制台" class="headerlink" title="Jconsole：Java监视与管理控制台"></a>Jconsole：Java监视与管理控制台</h4><p>JConsole（Java Monitoring and Management Console）是一种基于JMX的可视化管理工具。</p>
<p>通过JDK/bin目录下的<code>jsonsole</code>应用就可以启动JConsole，启动后将自动搜索本机运行的所有虚拟机进程。双击选择一个进城之后即可开始监控。</p>
<p>监控页面一目了然，不需要做太多说明。JConsole可以监控包括堆内存、线程、类、CPU等各个使用情况，</p>
<h4 id="VisualVM：多合一故障处理工具"><a href="#VisualVM：多合一故障处理工具" class="headerlink" title="VisualVM：多合一故障处理工具"></a>VisualVM：多合一故障处理工具</h4><p>VisualVM（All-in-One Java Troubleshooting Tool）是目前为止随JDK发布的功能最强大的故障处理工具，并且在可预见的未来都是官方主力发展的虚拟机故障处理工具。</p>
<p>VisualVM可以做到：</p>
<ul>
<li>显示虚拟机进程以及进程的配置、环境信息（jps、jinfo）。</li>
<li>监视应用程序的CPU、GC、堆、方法去以及线程的信息（jps、jstack）。</li>
<li>dump以及分析堆转储快照（jamp、jhat）。</li>
<li>方法记得性能运行性能分析，找出被调用最多、运行时间最长的方法。</li>
<li>离线程序快照：收集程序的运行时配置、线程dump、内存dump等信息建立一个快照，可以将快照发送给开发者处进行Bug反馈。</li>
<li>其他Plugins</li>
</ul>
<p>Intellij IDEA已经集成了VisualVM，详细的使用方法先留个坑，后续再填。</p>
<h2 id="类文件结构"><a href="#类文件结构" class="headerlink" title="类文件结构"></a>类文件结构</h2><h3 id="Class文件的结构"><a href="#Class文件的结构" class="headerlink" title="Class文件的结构"></a>Class文件的结构</h3><p>Class文件是一组以8位字节为基础的二进制流，各个数据项目严格按照顺序紧凑的排列在Class文件之中，中间没有添加任何分隔符，这使得整个Class文件中存储的内容几乎全部是程序运行的必要数据，没有空隙存在。当遇到占用8字节以上空间的数据项时，会按照高位在前的方式分割成若干8位字节进行存储。</p>
<p>根据Java虚拟机规范的规定，Class文件格式 采用一种类似于C语言结构体的伪结构来存储数据，这种伪结构只有两种数据类型：无符号数和表。</p>
<h2 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h2><p>Class 文件中描述的各种信息，最终都要加载到虚拟机之中才能运行和使用。而虚拟机如何加载这些 Class 文件？Class 文件中的信息进入到虚拟机后会发生什么变化？这些都是本章需要讲解的内容。</p>
<p>虚拟机把描述类的数据从 Class 文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的 Java 类型，就是虚拟机的类加载机制。在 Java 语言中，类型的加载、连接和初始化过程都是在程序运行期间完成的。</p>
<h3 id="类加载的时机"><a href="#类加载的时机" class="headerlink" title="类加载的时机"></a>类加载的时机</h3><p>类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：</p>
<ul>
<li>加载（Loading）</li>
<li>验证（Verification）</li>
<li>准备（Preparation）</li>
<li>解析（Resolution）</li>
<li>初始化（Initialization）</li>
<li>使用（Using）</li>
<li>卸载（Unloading）</li>
</ul>
<p>共七个阶段。其中验证、准备、解析三个部分统称连接（Linking），这七个阶段的发生顺序如图所示：</p>
<p><img src="http://nas.beritra.com:18081/uploads/big/04010d6fe65f96d49f64f18a40528d8a.png" alt=""></p>
<p>在图中，加载、验证、准备、初始化和卸载这 5 个阶段是顺序的，类的加载必须按照这种顺序按部就班地开始，而解析阶段则不一定：它在某些情况下可以在初始化阶段之后开始，这是为了支持 Java 语言的运行时绑定（也称为动态绑定或晚期绑定）。注意在，这里写的是“开始”，而不是按部就班的“进行”或者“完成”。强调这点的原因是这些阶段通常都是交叉混合进行的，通常会在一个阶段执行的过程中调用、激活下一个阶段。</p>
<p>虚拟机规范严格规定了有且只有 5 种情况必须立即对类进行“初始化”（而加载、验证、准备自然需要在此之前开始）：</p>
<ul>
<li>遇到 <code>new、getstatic、putstatic、invokestatic</code>这 4 条字节码指令的时候，如果类没有进行过初始化，则先需要触发其初始化。生成这 4 条指令的最常见的 Java 代码场景是：使用<code>new</code>关键字实例化对象的时候、读取或者设置一个类的静态字段（被<code>final</code>修饰、已在编译器把结果放入常量池的静态字段除外）的时候，以及调用一个类的静态方法的时候。</li>
<li>使用<code>java.lang.reflect</code>包的方法对类进行反射调用的时候。如果类没有进行初始化，则需要先触发其初始化。</li>
<li>当初始化一个类的时候，如果发现其父类还没有进行过初始化，则先需要出发其父类的初始化。</li>
<li>当虚拟机启动时，用户需要指定一个要执行的主类（包含<code>main()</code>方法的那个类），虚拟机会先初始化这个主类。</li>
<li>当使用 JDK 1.7 的动态语言支持时，如果一个<code>java.lang.invoke.MethodHandle</code>实例最后的解析结果是<code>REF_getStatic</code>、<code>REF_putStatic</code>、<code>REF_invokeStatic</code>的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化。</li>
</ul>
<p>对于这 5 种会触发类进行初始化的场景，虚拟机规范中使用了一个很强烈的限定于：“有且只有”，这 5 种场景中的行为成为对一个类进行主动引用。除此之外，所有的引用类的方式都不会触发初始化，称为被动引用。</p>
<p>对于静态字段，只有直接定义这个字段的类才会被初始化，因此通过子类来引用父类中定义的静态字段，只会出发父类的初始化而不会触发子类的初始化。至于是否要触发子类的加载和验证，在虚拟机规范中尚未明确规定，这点取决于虚拟机的具体实现。对于 Sun HotSpot 虚拟机来说，可以通过<code>-XX:TraceClassLoading</code>参数观察到此操作会导致子类的加载。</p>
<p>使用类的常亮也不会对这个类进行初始化，而是在编译阶段通过常量传播优化，将该常量存储到使用这个常亮的类的常量池中，后续对该常量的调用都会转化为该类堆自身常量池的引用。</p>
<p>接口的加载过程和类加载过程稍有一些不同，针对接口需要做一些特殊说明：接口也有初始化过程，这一点与类是一致的。接口中不能使用<code>static{}</code>代码块，但是编译期仍然会为接口生成<code>&lt;clinit&gt;()</code>类构造器，用于初始化接口中所定义的成员变量。接口与类真正有区别的是前面所讲说的 5 种“有且只有”需要开始初始化场景中的第 3 种：当一个类在初始化时，要求其父类全部都已经初始化过了，但是一个接口在初始化时，并不要求其父接口全部都完成了初始化，只有在真正用到父接口的时候（如引用接口定义的常亮）才会初始化。</p>
<h3 id="类加载的过程"><a href="#类加载的过程" class="headerlink" title="类加载的过程"></a>类加载的过程</h3><p>加载、验证、准备、解析和初始化这 5 个阶段的具体动作。</p>
<h4 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h4><p>加载是“类加载”（Class Loading）的一个阶段，在加载阶段，虚拟机需要完成以下 3 件事：</p>
<ul>
<li>通过一个类的全限定名来获取定义此类的二进制字节流。</li>
<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</li>
<li>在内存中生成一个代表这个类的<code>java.lang.Class</code>对象，作为方法区这个类的各种数据的访问入口。</li>
</ul>
<p>虚拟机规范的这三点都不具体，因此虚拟机实现和具体引用的灵活度都是相当大的。所以出现过很多种加载方式：</p>
<ul>
<li>从 ZIP 包中读取，这很常见，最终成为日后 JAR、EAR、WAR 格式的基础。</li>
<li>从网络中获取，这种场景最典型的应用就是 Applet。</li>
<li>运行时计算生成，这种场景使用得最多的就是动态代理技术，在<code>java.lang.reflect.Proxy</code>中，就是利用<code>ProxyGenerator.generateProxyClass</code>来为特定接口生成形式为<code>$Proxy</code>的代理类二进制字节流。</li>
<li>从其他文件中读取，典型场景是 JSP 引用，即由 JSP 文件生成对应的 Class 类。</li>
<li>从数据库中读取，这种场景相对少见，例如有些中间件服务器（如 SAP Netweaver）可以选择把程序安装到数据库中来完成程序代码在集群见的分发。</li>
</ul>
<p>相对于类加载过程的其他阶段，一个非数组类的加载阶段（准确的说，是加载阶段中获取类的二进制字节流的动作）是开发人员可控性最强的，因为加载阶段既可以使用系统提供的引导类加载器来完成，也可以由用户自定义的类加载器去完成，开发人员可以通过定义自己的类加载器去控制字节流的获取方式（即重写一个类加载器的<code>loadClass()</code>方法）。</p>
<p>对于数组类来说情况有所不同，数组类本身不是通过类加载器区创建，它是由 Java 虚拟机直接创建的。但是数组类和类加载器仍有很密切的关系，因为数组类的元素类型（Element Type，值得是数组去掉所有维度的类型）最终仍要靠类加载去去创建，一个数组类创建过程就遵循以下规则：</p>
<ul>
<li>如果数组的组件类型（Component Type，指的是数组去掉一个维度的类型）是引用类型，那就递归采用上面的加载过程去加载这个组件类型，数组将在加载该组件类型的类加载器的类空间上被标识。</li>
<li>如果数组的组件类型不是引用类型（如<code>int[]数组</code>），Java 虚拟机将会把数组标记为与引导类加载器关联。</li>
<li>数组的可见性与他的组件类型的可见性一致，如果组件类型不是引用类型，那数组类的可见性将默认为<code>public</code>。</li>
</ul>
<p>加载阶段完成后，虚拟机外部的二进制字节流文件就按照虚拟机所需的格式存储在方法去之中，方法区中的数据存储格式由虚拟机实现自行定义，虚拟机规范未规定此区域的具体结构。然后在内存中实例化一个<code>java.lang.Class</code>类的对象（并没有明确在 Java 堆中，对于 HotSpot 虚拟机而言，Class 对象比较特殊，它虽然是对象，但是存放在方法区里面），这个对象将作为程序访问方法区中的这些类型数据的外部接口。</p>
<p>加载阶段与连接阶段的部分内容（如一部分字节码文件格式验证动作）是交叉进行的，加载阶段尚未完成，连接阶段可能已经开始，但这些夹在加载阶段之中进行的动作，仍然属于连接阶段的内容，这两个阶段的开始时间仍然保持着固定的先后顺序。</p>
<h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><p>验证是连接阶段的第一步，这一阶段的目的是确保 Class 文件中的字节流中包含的信息符合虚拟机要求，并且不会危害虚拟机自身的安全。</p>
<p>Java 语言本身是相对安全的语言，使用纯粹的 Java 代码无法做到诸如访问数组边界以外的数据、将对象转型为它未实现的类型、跳转到不存在的代码行之类的事情，如果这样做了，编译器会拒绝编译。验证阶段大致上会完成以下 4 个阶段的检验动作：</p>
<ul>
<li>文件格式验证：主要验证字节流是否符合 Class 文件格式的规范，并且能够被当前版本的虚拟机处理。</li>
<li>元数据验证：对字节码描述的信息进行语义分析，以保证其描述的信息符合 Java 语言规范的要求。</li>
<li>字节码验证：第三阶段是整个验证过程中最复杂的一个阶段，主要目的是通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。在第二阶段对元数据信息中的数据类型做完校验后，这个阶段将对类的方法体进行教研分析，保证被校验类的方法在运行时不会做出危害虚拟机安全的事件。如果一个类方法体的字节码没有通过字节码验证，那肯定是有问题的，但是如果一个方法体通过了字节码验证，也不能说明其一定就是安全的。</li>
<li>符号引用验证：最后一个阶段的校验发生在虚拟机将符号引用转化为直接引用的时候，这个转化动作将在连接的第三阶段——解析阶段中发生就。符号引用验证的目的是确保解析动作能正常执行，如果无法通过符号引用验证，那么将会抛出<code>java.lang.IncompatibleClassChangeError</code>异常的子类。</li>
</ul>
<p>对于虚拟机的类加载机制来说，验证阶段是一个非常重要的、但不是一定必要（因为对程序运行期没有影响）的阶段。如果所运行的全部代码已经被反复使用和验证过，那么在实施阶段可以考虑使用<code>-Xverify:none</code>参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。</p>
<h4 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h4><p>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将在方法区中进行分配。假设一个类变量的定义为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> value=<span class="number">123</span>;</span></pre></td></tr></table></figure>

<p>那变量 value 在准备阶段过后的初始值为 0 而不是 123，因为这个时候尚未开始执行任何 Java 方法，而把 value 赋值为 123 的<code>putstatic</code>指令是程序被编译后，存放于类构造器<code>&lt;clinit&gt;()</code>方法之中，所以把 value 赋值为 123 的动作将在初始化阶段才会执行。下表列出了 Java 中所有基本数据类型的零值。</p>
<p><img src="http://nas.beritra.com:18081/uploads/big/a694fc404774cb03d0a60f51afd316d1.png" alt=""></p>
<p>有一些特殊情况：如果类字段的字段属性表中存在<code>ConstantValue</code>属性，那么准备阶段变量 value 就会被初始化为<code>ConstantValue</code>属性所指的值，假设上面类变量 value 的定义变为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> value=<span class="number">123</span>;</span></pre></td></tr></table></figure>

<p>编译时 Javac 将会为 value 生成<code>ConstantValue</code>属性，在准备阶段虚拟机就会根据<code>ConstantValue</code>的设置将 value 赋值为 123。</p>
<h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h4><p>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。直接引用与符号引用的关系：</p>
<ul>
<li>符号引用（Symbolic References）：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量。符号引用与虚拟机实现的内存布局无关，引用的目标不一定已经加载到内存中。</li>
<li>直接饮用（Direct References）：直接饮用可以是直接指向目标的指针、相对偏移量或一个能间接定位到目标的句柄。直接引用是和虚拟机实现的内存布局相关的，如果有了直接饮用，那引用的目标一定已经在内存中存在了。</li>
</ul>
<h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>类初始化阶段是加载过程的最后一步，在前面的过程中，除了加载阶段用户应用程序可以通过自定义类加载器参与之外，其余动作完全由虚拟机主导和控制的。到了初始化阶段，才真正开始执行类中定义的 Java 程序代码。</p>
<p> 在准备阶段，变量已经赋值过一次系统要求的初始值，而在初始化阶段，则根据程序员通过程序定制的主观计划区初始化类变量和其他字段，或者从另外一个角度表达：初始化阶段是执行类构造器<code>&lt;clinit&gt;()</code>方法的过程。</p>
<ul>
<li><code>&lt;clinit&gt;()</code>方法是由编译器自动收集类中所有类变量的赋值动作和静态语句块（<code>static{}</code>块）中的语句合并产生的，编译器收集的顺序由语句在源文件中出现的顺序所决定。静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块可以赋值，但是不能访问。</li>
<li><code>&lt;clinit&gt;()</code>方法与类的构造函数不同，它不需要显式地调用父类构造器，虚拟机会保证在子类的<code>&lt;clinit&gt;()</code>方法执行之前，父类的<code>&lt;clinit&gt;()</code>方法已经执行完毕。因此在虚拟机中第一个被执行的<code>&lt;clinit&gt;()</code>方法的类肯定是<code>java.lang.Object</code>。</li>
<li>由于父类的<code>&lt;clinit&gt;()</code>方法先执行，所以意味着父类中定义的静态语句块要优先于子类的变量赋值操作。</li>
<li><code>&lt;clinit&gt;()</code>方法对于类或借口来说并不是必须的，如果一个类中没有静态语句块，也没有对变量的赋值操作，那么编译器可以不为这个类生成<code>&lt;clinit&gt;()</code>方法。</li>
<li>接口中不能使用静态语句块，但仍然有变量初始化的赋值操作，因此接口与类一样都会先生成<code>&lt;clinit&gt;()</code>方法。但是接口与类不同的是，执行接口的<code>&lt;clinit&gt;()</code>方法不需要先执行父类的<code>&lt;clinit&gt;()</code>方法。只有当父接口中定义的变量使用时，父接口才会初始化。另外，接口的实现类在初始化时也不会执行接口的<code>&lt;clinit&gt;()</code>方法。</li>
<li>虚拟机会保证一个类的<code>&lt;clinit&gt;()</code>方法在多线程环境下被正确的加锁、同步。如果多个线程去初始化一个类，那么只会有一个线程去执行这个类的<code>&lt;clinit&gt;()</code>方法，其他线程都需要阻塞等待，直到活动线程执行<code>&lt;clinit&gt;()</code>方法完毕。</li>
</ul>
<h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><h4 id="类与类加载器"><a href="#类与类加载器" class="headerlink" title="类与类加载器"></a>类与类加载器</h4><p>类加载器虽然只用于实现类的加载动作，但是它在 Java 程序中起到的作用却远远不限于类加载阶段。对于任何一个类，都需要由加载它的类加载器和这个类本身一同确立其在 Java 虚拟机中的唯一性，每个类加载器，都拥有一个独立的类名称空间。表达的更通俗一些：比较两个类是否“相等”，只有在这两个类是由同一个类加载器加载的前提下才有意义，否则，即使这两个类来源于同一个 Class 文件，被同一个虚拟机加载，只要加载他们的类加载器不同，那这两个类就必定不同。</p>
<h4 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h4><p>从虚拟机角度来讲，只有两种不同的类加载器：一种是启动类加载器（Bootstrap ClassLoader），这个类加载器使用 C++ 语言实现，是虚拟机自身的一部分；另一种就是所有其他的类加载器，这些类加载器都是由 Java 实现，独立于虚拟机外部，并且全部继承自抽象类<code>java.lang.ClassLoader</code>。</p>
<p>从 Java 开发人员的角度来看，类加载器还可以划分的更细致：</p>
<ul>
<li>启动类加载器（Bootstrap ClassLoader）：这个类加载器负责将存放在<code>&lt;JAVA_HOME&gt;\lib</code>目录中的，或者被<code>-Xbootclasspath</code>参数所指定的路径中的，并且是虚拟机是别的类库加载到虚拟机内存中。</li>
<li>扩展类加载器（Extension ClassLoader）：这个类加载器由<code>sun.misc.Launcher$ExtClassLoader</code>实现，它负责加载<code>&lt;JAVA_HOME&gt;\lib\ext</code>目录中的，或者被<code>java.ext.dirs</code>系统变量所指定的路径中的所有类库，开发者可以直接使用扩展类加载器。</li>
<li>应用程序类加载器（Application ClassLoader）：这个类加载器由<code>sun.misc.Launcher$ExtClassLoader</code>实现。由于这个类加载器是 ClassLoader 中的<code>getSystemClassLoader()</code>方法的返回值，所以一般也称它为系统类加载器。它负责加载用户路径（ClassPath）上所指定的类库，开发者可以直接使用这个类加载器。</li>
</ul>
<p>我们的应用程序都是由这 3 种类加载器相互配合进行加载的，如果有必要，还可以加入自己定义的类加载器。这些类加载器之间的关系一般如图所示：</p>
<p><img src="http://nas.beritra.com:18081/uploads/big/17e4a5d77426df4bb5549bc5316112bb.jpg" alt=""></p>
<p>这种层次关系，称之为类加载器的双亲委派模型（Parents Delegation Model）。双亲委派模型的要求除了顶层的启动类加载器外，其余的类加载器都应当有自己的父类加载器。这里类加载器之间的父子关系一般不会以继承（Inheritance）的关系来实现，而是通过使用组合（Compositon）关系来复用父加载器的代码。</p>
<p>双亲委派模型的工作过程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围内没有找到所需的类）时，子加载器才尝试自己加载。</p>
<p>使用双亲委派模型来组织类加载器之间的关系，有一个显而易见的好处就是 Java 类随着它的类加载器一起具备了带有优先级的层次关系。例如类<code>java.lang.Object</code>，它存放在<code>rt.jar</code>中，无论哪一个类加载器需要加载这个类，最终都是委派个处于模型最顶端的启动类加载器进行加载，因此<code>Object</code>类在程序的各种类加载器环境中都是同一个类。相反，如果没有使用双亲委派模型，由各个类加载器去自行加载的话，如果用户自己编写了一个<code>java.lang.Object</code>的类，也放在程序的<code>ClassPath</code>下，那么系统就会出现多个不同的<code>Object</code>类，Java 类型基础的行为也不能保证了。</p>
<p>双亲委派模型对于保证 Java 程序的稳定运行非常重要，但是实现却很简单，实现双亲委派模型的代码都集中在<code>java.lang.ClassLoader</code>的<code>loadClass()</code>方法中，逻辑清晰易懂：先检查是否已经被加载过，如果没有加载则调用父加载器的<code>loadClass()</code>方法，若父加载器为空则默认使用启动类加载器作为父加载器。如果父加载器加载失败，抛出<code>ClassNotFoundException</code>异常后，再调用自己的<code>findClass()</code>方法进行加载。</p>
<p>参考目录：</p>
<p><a href="https://www.jianshu.com/p/c321d0808a1b" target="_blank" rel="noopener">jinfo命令详解</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
        <tag>虚拟机</tag>
      </tags>
  </entry>
  <entry>
    <title>RESTful API</title>
    <url>/2018/04/17/RESTful%20API/</url>
    <content><![CDATA[<p>RESTful API到底怎么玩？记录一下。</p>
<a id="more"></a>

<h2 id="是啥"><a href="#是啥" class="headerlink" title="是啥"></a>是啥</h2><p>按照是啥、有啥用、怎么用的分析步骤，先解决RESTful是什么的问题。先上高大上的定义，wiki这么说：</p>
<blockquote>
<p><strong>表现层状态转换</strong>（英语：<strong>Representational State Transfer</strong>，缩写：<strong>REST</strong>）</p>
</blockquote>
<p>##有啥用</p>
<p>我的理解RESTful就是一种设计风格，通俗点说就是我们设计API的一种指导思想。主要有几个特点：</p>
<ul>
<li>统一</li>
<li>无状态</li>
<li>可缓存</li>
<li>分层</li>
</ul>
<p>其他特征没觉得有什么用，暂且不说。个人觉得无状态是RESTful最大的特点，和http协议的设计思路类似。另外RESTful应该着重强调对资源的控制，即每一个URI代表一种资源，客户端通过HTTP动词，对服务端的资源进行操作。</p>
<p>但是回到有啥用这个问题上，个人觉得风格统一，容易理解，方便使用是比较大的优点，其他的倒是没有了。</p>
<h2 id="怎么用"><a href="#怎么用" class="headerlink" title="怎么用"></a>怎么用</h2><p>RESTful的核心思想是用五个HTTP动词对资源进行操作：</p>
<ol>
<li>GET(获取) 从服务器获取一个资源或者资源列表</li>
<li>POST(创建) 在服务器上创建一个新资源</li>
<li>PUT(更新) 以整体方式更新服务器上的一个资源</li>
<li>PATCH(更新) 更新服务器上的某个资源的部分属性</li>
<li>DELETE(删除) 删除服务器上的资源</li>
</ol>
<p>另外有两个不常用的动词：</p>
<ol>
<li>HEAD 获取资源元数据</li>
<li>获取信息。这个cors解决跨域的时候有可能用到。</li>
</ol>
<p>以下是一篇文章中的栗子：</p>
<ul>
<li>GET /zoos:获取所有动物园信息</li>
<li>POST /zoos: 创造一个新的动物园</li>
<li>GET /zoos/ZID: 获取整个动物园对象</li>
<li>PUT /zoos/ZID: 更新整个动物园对象</li>
<li>PATCH /zoos/ZID: 更新动物园对象中的某些属性</li>
<li>DELETE /zoos/ZID: 删除动物园</li>
<li>GET /zoos/ZID/animals: 获取ZID这个动物园下的所有动物</li>
</ul>
<p>可以看出这里的栗子URL采用了path info的模式，所有查询参数都在URL路径中。但是RESTful风格一般没有对这个做要求，放在后面的参数中也可以。</p>
<p>##认证怎么搞</p>
<p>常用的接口认证有如下几种方式：</p>
<h3 id="Token-JSON-Web-Token"><a href="#Token-JSON-Web-Token" class="headerlink" title="Token(JSON Web Token)"></a>Token(JSON Web Token)</h3><p>JWT 是JSON风格轻量级的授权和身份认证规范，可实现无状态、分布式的Web应用授权，JWT主要由以下三部分构成，由.进行连接</p>
<ul>
<li>Header</li>
<li>Payload</li>
<li>Signature</li>
</ul>
<p>所以完整的JWT格式应该是类似<code>xxxxx.yyyyy.zzzzz</code>这样。</p>
<h4 id="Header"><a href="#Header" class="headerlink" title="Header"></a>Header</h4><p>header主要声明token类型和使用的加密算法，比如：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="attr">"alg"</span>: <span class="string">"HS256"</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="attr">"typ"</span>: <span class="string">"JWT"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>然后将头部进行Base64加密，得到第一部分。</p>
<h4 id="Payload"><a href="#Payload" class="headerlink" title="Payload"></a>Payload</h4><p>payload包含你进行认证需要的数据，比如：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="attr">"sub"</span>: <span class="string">"1234567890"</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="attr">"name"</span>: <span class="string">"John Doe"</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="attr">"admin"</span>: <span class="literal">true</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>然后将有效Payload用Base64进行编码，以形成JWT的第二部分。</p>
<h4 id="Signature"><a href="#Signature" class="headerlink" title="Signature"></a>Signature</h4><p>要创建签名部分，必须要有已经编码的header，编过码的Payload，一个密匙（secret）和加密算法。</p>
<p>例如，如果想使用HMAC SHA256算法，签名将按以下方式创建：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HMACSHA256(base64UrlEncode(header) + <span class="string">"."</span> +base64UrlEncode(payload),secret)</span></pre></td></tr></table></figure>

<p>更详细的文档可以参见官方网站：<a href="https://jwt.io/" target="_blank" rel="noopener">https://jwt.io/</a></p>
<h3 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h3><p>既然前后端分离了，就不可避免的要遇到跨域问题。跨域问题单独拎出来总结吧。</p>
<p>//TODO</p>
<p>参考资料：</p>
<ul>
<li><a href="https://yuedu.baidu.com/ebook/780324fbf121dd36a32d8269?pn=1&rf=https%3A%2F%2Fyuedu.baidu.com%2Febook%2F780324fbf121dd36a32d8269%3Fpn%3D1" target="_blank" rel="noopener">架构风格与基于网络应用软件的架构设计</a></li>
<li><a href="[http://www.ruanyifeng.com/blog/2014/05/restful_api.html](http://www.ruanyifeng.com/blog/2014/05/restful_api.html)">RESTful API 设计指南</a></li>
<li><a href="https://zh.wikipedia.org/wiki/%E8%A1%A8%E7%8E%B0%E5%B1%82%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2" target="_blank" rel="noopener">wiki REST</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2011/09/restful.html" target="_blank" rel="noopener">理解RESTful架构</a></li>
<li><a href="https://www.cnblogs.com/moonz-wu/p/4211626.html" target="_blank" rel="noopener">好RESTful API的设计原则</a></li>
<li><a href="https://mingshan.fun/2017/12/19/restful-api-token/" target="_blank" rel="noopener">RESTful API风格基于Token的鉴权机制分析(与JWT结合)</a></li>
</ul>
]]></content>
      <categories>
        <category>最佳实践</category>
      </categories>
      <tags>
        <tag>RESTful</tag>
        <tag>最佳实践</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习（一）线性回归</title>
    <url>/2018/04/17/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/</url>
    <content><![CDATA[<p>注意到大多数机器学习的课程都是从线性回归开始讲的，而且这部分直觉上的最容易理解，所以我也从线性回归开始学习。</p>
<a id="more"></a>

<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>面对素不相识的概念，我们先来个素质三连：What、Why、How。</p>
<h3 id="什么是线性回归？"><a href="#什么是线性回归？" class="headerlink" title="什么是线性回归？"></a>什么是线性回归？</h3><p>线性回归是机器学习中最简单、基础的模型，维基百科<a href="https://zh.wikipedia.org/wiki/%E7%B7%9A%E6%80%A7%E5%9B%9E%E6%AD%B8" target="_blank" rel="noopener">线性回归</a>条目中如此介绍：</p>
<blockquote>
<p>在统计学中，<strong>线性回归</strong>（Linear regression）是利用称为<strong>线性回归</strong>方程的最小平方函数对一个或多个自变量和因变量之间关系进行建模的一种<strong>回归</strong>分析。 这种函数是一个或多个称为<strong>回归</strong>系数的模型参数的<strong>线性</strong>组合。 只有一个自变量的情况称为简单<strong>回归</strong>，大于一个自变量情况的叫做多元<strong>回归</strong></p>
</blockquote>
<p>举一个简单的栗子：</p>
<p>有如下一组数据，我们想根据这些数据研究他们之间的规律。</p>
<p><img src="1.png" alt="图"></p>
<p>用脚趾头都能看出来，这横轴和纵轴数据是线性相关的，但是你不能用脚趾头证明它，所以需要有一种模型描述他们之间的规律，要尽量保证误差最小，从而能通过已有的数据预测未知的数据。</p>
<h3 id="为什么要用线性回归？"><a href="#为什么要用线性回归？" class="headerlink" title="为什么要用线性回归？"></a>为什么要用线性回归？</h3><p>这个问题太显而易见反而不容易回答，现实中很多数据之间的关系是线性的，只有一个因变量一个自变量就可以表述它们之间的关系，直觉上也知道用简单线性回归再合适不过了。当然，多个参数自变量也可以是线性回归，不过叫多元线性回归。但是需要注意，线性回归对异常值非常敏感，所以要不要用，怎么用还得仔细考量。</p>
<p>###怎么回归？</p>
<p>突然感觉在概述中问这三个问题好蠢，都说清楚的话这篇文章就讲完了…所以下面就详细说怎么回归，先从最简单的一元线性回归，又叫简单线性回归开始。</p>
<p>##一元线性回归</p>
<p>小学大概就学过，在直角坐标系中描述一条直线的方程是<code>y=kx+b</code>，这里也是一样的，我们的目的是寻找一个合适的方程，能最好的描述<code>x</code>和<code>y</code>的关系，这个方程在大多数课程里叫<code>假设函数 hypothesis function</code>，所以一元线性回归方程就是：</p>
<p><img src="2.png" alt=""></p>
<p>两个Theta怎么选，我们的目的应该是尽量拟合所有的点，所以需要一个指标来描述我们选的值合不合适，我们把它称作损失函数<code>cost function 或者 loss function</code>，这两个名称的含义似乎有些微不同，但是我没搞很清楚，先留个疑问。损失函数使用每个点上的对<code>h(x)</code>预期值与实际值的偏差先平方再取平均来描述，如下图所示。</p>
<p><img src="3.png" alt=""></p>
<p>它这里前面参数多了个二分之一，只是为了后续方便计算。我们的目标就是计算大量的<code>cost function</code>，然后找到其中的最小值。</p>
<p>参考：</p>
<p><a href="http://studentdeng.github.io/blog/2014/07/28/machine-learning-tutorial/" target="_blank" rel="noopener">机器学习(一) 简单的背景介绍、线性回归、梯度下降</a></p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>Rancher CI/CD Pipeline 初步学习</title>
    <url>/2018/02/06/Rancher-CI-CD-Pipeline-%E5%88%9D%E6%AD%A5%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>最近的工作任务是研究Docker、Rancher上CI/CD 流程，记录一些学习过程。</p>
<a id="more"></a>

<h2 id="什么是CI-CD"><a href="#什么是CI-CD" class="headerlink" title="什么是CI/CD"></a>什么是CI/CD</h2><p>CI/CD的意思就是持续集成(Continuous integration)和持续交付(continuous delivery)或持续部署(continuous deployment)。这三个步骤组成了现在软件开发的基本流程。</p>
<p>初次接触到这些概念基本是懵的，尤其是小公司或者传统软件行业，对软件迭代速度没那么高的要求。什么叫集成？怎么算持续？集成的意思就是说快速的把新开发的特性合并到主干上，可以理解为git上把某一个feature分支合并到master上，不过这一过程还包括了程序的构建和测试。持续集成一般是指每天进行很多次集成，它的目的主要是快速的更新产品，既能方便调整方向，又能及时发现bug，从而实现了“小步快跑”的策略。</p>
<p>而持续交付是指频繁的将产品交到用户或者质量评审团队手里，以供评审，通过之后就可以进入到生产。持续部署是指自动化部署到生产环境。通过实施CI/CD，可以在一天进行很多次的产品迭代，从而提升竞争力。</p>
<p>CI/CD的一般流程也就是软件开发的生命周期，只不过完全将其自动化。从git进行代码提交开始，webhook检测到提交事件之后，开始进行单元测试，测试通过之后，将代码合并到主分支，然后进行构建。构建完成在进行集成测试、系统测试，测试无误就可以交付了。然后进行部署，其中可能会有灰度发布，或者用户体验不佳然后进行版本回滚的操作。</p>
<h2 id="基于Docker的CI-CD有什么优势"><a href="#基于Docker的CI-CD有什么优势" class="headerlink" title="基于Docker的CI/CD有什么优势"></a>基于Docker的CI/CD有什么优势</h2><p>由于自身理解不深，搜集了一些博文的观点：</p>
<blockquote>
<p>一个完整的流程入是这样的，用户（也就是开发人员）将包含Dockerfile的源码从本地push到Git服务器上，然后触发Jenkins进行构建源码，源码构建完成后紧接着进行Docker image的构建，一切构建完成之后，顺带将构建成功的image上传到企业内部的镜像仓库，到此刻为止，其实一个基本的CI（持续集成）已经算是结束，剩下的部分就是持续部署或者进行持续的交付开发产物了。在以前传统的软件发布模式中，持续集成的产物是编译打包好的代码，如果想要发布程序，发布系统需要在持续集成的制品库中去获得对应的代码，然后根据一系列的环境检查来准备应用的运行时环境，而在此过程中往往会涉及到比较多的基本组件依赖，所以在整体的发布周期内来看，还是有一些问题的。在Docker或者容器时代，我们将容器的镜像构建部分融入到持续集成（CI）环节，最终持续集成的产出物是一些已经处理好依赖关系，基本不需要人工进行二次干预的Docker image，而在CD环节，发布系统只需要设置和管理很少的信息就能够很快将image运行起来，快速地将业务发布出去。<br>在上面整个环节中，其实无非就是增加了Docker的那一层处理，但其实在整个软件开发的生命周期中，它是产生了极大的影响的。首先，部署系统不需要为统一的部署框架去做更多逻辑抽象，业务研发在开发代码的过程中选择自己依赖的base image即可，最终运行起来的业务也就是你当时提供的base image的模样；其次，由于base image已经处理好了相关的依赖，所以当发布系统拿到业务的image的时候，发布操作将会变得异常迅速，这对于互联网时代可谓是非常重要的；最后一点，也是我感受最深的，就是研发构建好的image可以在任何的Docker环境中run起来，研发人员不需要再关系环境一致性的问题，他们在自己本地的测试环境能够运行起来的应用，那么到生成环境也一定可以。<br>——<a href="http://dockone.io/article/2482" target="_blank" rel="noopener">基于Docker的CI/CD流水线实践</a></p>
</blockquote>
<h2 id="一个想象的Java-CI-CD-流程"><a href="#一个想象的Java-CI-CD-流程" class="headerlink" title="一个想象的Java CI/CD 流程"></a>一个想象的Java CI/CD 流程</h2><p>说了一堆理论的东西，回归到实际环境，由于我们公司主要开发语言是Java，我就先想象了一下对于Java语言，应该是个怎么样的CI/CD流程。首先，研发人员开发完成某一阶段之后，提交代码到主分支，然后触发webhook，开启pipeline。首先，应该在一个带有JDK的容器中下载代码，然后用maven下载依赖、编译、打包，然后运行测试，测试通过之后把class文件、jar包和配置文件转移到一个只含有jre的容器，进行镜像的构建步骤，然后推送到镜像仓库，最后将镜像发布，生成新的容器实例。</p>
<h2 id="重点关注问题"><a href="#重点关注问题" class="headerlink" title="重点关注问题"></a>重点关注问题</h2><p>关于CI/CD Pipeline，主要需要从以下几个方面着手考虑。</p>
<h3 id="崇伟提到重点关注的几个问题"><a href="#崇伟提到重点关注的几个问题" class="headerlink" title="崇伟提到重点关注的几个问题"></a>崇伟提到重点关注的几个问题</h3><ol>
<li>git分支管理大致怎样？</li>
<li>构建镜像的版本号如何管理？</li>
<li>测试环节，如何整合自动化测试？</li>
<li>推送镜像的目标harbor，是否区分开发环境/测试环境/正式环境？</li>
<li>发布流程是否可以控制，比如整合到运维的发布流管理系统？</li>
<li>灰度发布，调研时也需要关注</li>
</ol>
<h4 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h4><p>Rancher Pipeline的触发是用git某一个分支的webhook。每一个stage可以设置触发条件，包括commit ID、分支名、仓库url这三种进行区分。</p>
<p>这里需要考虑的主要问题是要如何指导研发人员的的git工作流，怎么设置分支，目标是尽量少的对现有方案进行改动。</p>
<p>这里可以参照两篇文章<a href="https://yaowenjie.github.io/devops/thinking-in-two-kinds-of-ci-cd-strategies-and-git-branch-models" target="_blank" rel="noopener">关于两种CI/CD策略与git分支模型的思考</a>、<a href="http://nvie.com/posts/a-successful-git-branching-model/" target="_blank" rel="noopener">A successful Git branch model</a></p>
<h4 id="版本号"><a href="#版本号" class="headerlink" title="版本号"></a>版本号</h4><p>Pipeline构建过程中可以使用以下变量：</p>
<table>
<thead>
<tr>
<th>NAME</th>
<th>DESC</th>
</tr>
</thead>
<tbody><tr>
<td>CICD_GIT_COMMIT</td>
<td>git commit sha</td>
</tr>
<tr>
<td>CICD_GIT_BRANCH</td>
<td>git branch</td>
</tr>
<tr>
<td>CICD_GIT_URL</td>
<td>git repository url</td>
</tr>
<tr>
<td>CICD_PIPELINE_ID</td>
<td>pipeline id</td>
</tr>
<tr>
<td>CICD_PIPELINE_NAME</td>
<td>pipeline name</td>
</tr>
<tr>
<td>CICD_TRIGGER_TYPE</td>
<td>trigger type</td>
</tr>
<tr>
<td>CICD_NODE_NAME</td>
<td>jenkins node name</td>
</tr>
<tr>
<td>CICD_ACTIVITY_ID</td>
<td>pipeline history record id</td>
</tr>
<tr>
<td>CICD_ACTIVITY_SEQUENCE</td>
<td>run number of pipeline history record</td>
</tr>
</tbody></table>
<p>都可以作为版本号，其中视频教程中推荐使用CICD_ACTIVITY_SEQUENCE，这基本可以当做一个Pileline的自增序号。</p>
<p>这里主要考虑得是在发布流中对版本号的控制。</p>
<h4 id="测试环节整合自动化测试"><a href="#测试环节整合自动化测试" class="headerlink" title="测试环节整合自动化测试"></a>测试环节整合自动化测试</h4><p>在一个步骤中选择类型为task之后，都可以执行shell，在这里可以调用自动化测试的命令。</p>
<h4 id="harbor是否区分环境"><a href="#harbor是否区分环境" class="headerlink" title="harbor是否区分环境"></a>harbor是否区分环境</h4><p>可以区分，不过通过仓库、镜像名、tag都可以作为区分，是不是还有必要分开多个环境？</p>
<h4 id="发布流程"><a href="#发布流程" class="headerlink" title="发布流程"></a>发布流程</h4><p>发布流程每一步都可以设置权限控制，相关人员确认后再进行下一步。</p>
<p>关于是否可以整合Jenkins插件，视频中说现在不支持，建议不要混搭。</p>
<h4 id="灰度发布"><a href="#灰度发布" class="headerlink" title="灰度发布"></a>灰度发布</h4><p>灰度发布的关键在于流量控制和版本控制，要求能快速切换版本，控制每个版本的流量。Rancher Pipeline中现有的相关操作是upgrade service可以设置步长，即选择保留的版本数量，同时可以选择先上线新版本再关闭旧版本，或是先关闭再上线，这个操作的时间间隔也可以设置。在Rancher操作界面中也可以随时会滚版本。关于流量控制可以使用HAproxy等负载均衡来做。</p>
<h3 id="现有的工具"><a href="#现有的工具" class="headerlink" title="现有的工具"></a>现有的工具</h3><p>询问多个同事得知，各个项目组还没有统一的流程，旭哥的eSim团队可能是相对比较健全的，之前使用过GitLab和Jenkins，现在基于方便考虑，切换到了同一家出品的Bitbucket+Bamboo。以ESim为例，当前的发布流程是这样：</p>
<ol>
<li>提交代码到各自feature分支</li>
<li>每日把各自feature分支合并到develop分支（触发自动化build），同时执行单元测试用例。有冲突解决冲突，直至冲突解决完成</li>
<li>develop拉release分支提测</li>
<li>测试通过在bamboo上将release发布</li>
</ol>
<h2 id="Rancher-Pipeline-Demo-环境搭建"><a href="#Rancher-Pipeline-Demo-环境搭建" class="headerlink" title="Rancher Pipeline Demo 环境搭建"></a>Rancher Pipeline Demo 环境搭建</h2><h3 id="启动环境"><a href="#启动环境" class="headerlink" title="启动环境"></a>启动环境</h3><p>Rancher Pipeline的搭建非常简单，首先需要满足Rancher server版本在v1.6.13以上，这里我们选择了v1.6.14。然后在商店里搜索pipeline就可以看到，不需要额外配置，启动服务就可以了。</p>
<p>启动完成之后，Rancher UI界面顶部菜单会出现一个新的按钮”流水线”，点击即可进入Pipeline界面。<br><img src="1.jpg" alt=""></p>
<h3 id="仓库认证和授权"><a href="#仓库认证和授权" class="headerlink" title="仓库认证和授权"></a>仓库认证和授权</h3><p>进入Pipeline界面之后，点击添加流水线，它会让你先完成仓库授权和添加代码仓库：<br><img src="2.jpg" alt=""></p>
<p>当前支持的代码仓库只有两个，GitHub和GitLab，我这里选择了自己部署的GitLab。首先打开Gitlab，登陆，点击右上角自己的头像，在下拉菜单中选择setting：<br><img src="3.jpg" alt=""></p>
<p>然后在新的页面里选择application，name里面取个名字，Redirect URI是Pipeline提供给你的，复制过来就行，然后选一个权限，我选择的api，最后保存：<br><img src="5.jpg" alt=""></p>
<p>其中，Redirect URI 在这里：<br><img src="4.jpg" alt=""></p>
<p>都完成之后，GitLab会生成一个ID和密钥，将这两个值复制到Pipeline中：<br><img src="6.jpg" alt=""></p>
<p>然后别忘了选中”使用私有GitLab部署”，然后填上ip，就可以了，最后点击gitlab验证。<br><img src="7.jpg" alt=""></p>
<p>页面会跳到GitLab，点击认证，这一步就完了。</p>
<h3 id="流水线配置"><a href="#流水线配置" class="headerlink" title="流水线配置"></a>流水线配置</h3><p>回到流水线界面，点击添加流水线，会让你选择git用户、仓库和分支，按照各自情况选好需要跟踪的分支，点击添加，第一个阶段就完成了。</p>
<p>然后点击添加第二个阶段，这里可以选择并行或者串行，这里的并行或者串行是指本构建阶段(stage)下的每个步骤(step)执行逻辑。同时可以看到，这里有两个可选选项，分别提供条件筛选和审核。如果不满足条件，步骤不执行。或者执行到这一步的，等待审核人审核，审核通过之前不会执行。<br><img src="8.jpg" alt=""></p>
<p>添加完阶段之后添加一个步骤，Rancher教程以go语言为例，选择步骤类型为task，然后镜像为golang:1.8，输入需要执行的shell，这一步的作用就是把代码复制到相应的容器中，然后进行编译，使用容器作为编译环境保证了环境的一致性。这里的那些参数只是为了演示的时候加快变异速度，其实最重要的就是一步<code>go build</code><br><img src="9.jpg" alt=""></p>
<p>进行到这里，无误的话源代码已经编译完成，应该执行单元测试。所以下一个阶段基本相同，再添加一个阶段，添加一个步骤，步骤类型task，命令稍有不同。<br><img src="10.jpg" alt=""></p>
<p>单元测试完成，开始构建镜像。添加一个阶段，添加一个步骤，这里步骤类型选择build，这里的build是指build image。Dockerfile可以在这里填写，或者直接从代码中拉取，这里选择的是从代码中拉，由于只是demo，Dockerfile非常简单:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FROM alpine</span></pre></td></tr><tr><td class="code"><pre><span class="line">EXPOSE 8080</span></pre></td></tr><tr><td class="code"><pre><span class="line">COPY .&#x2F;bin&#x2F;outyet &#x2F;usr&#x2F;bin&#x2F;outyet</span></pre></td></tr><tr><td class="code"><pre><span class="line">ENTRYPOINT &#x2F;usr&#x2F;bin&#x2F;outyet</span></pre></td></tr></table></figure>
<p>同时可以看到镜像标签那里使用了上面说到的变量<code>CICD_ACTIVITY_SEQUENCE</code>，可以看做是一个自增序列。<br>这一步顺利完成之后，就构建好了一个名为outyet的镜像，版本号是一个数字，然后被推送到2.8.0.3:8001/pipeline仓库。<br><img src="11.jpg" alt=""></p>
<p>进行到这里，自动集成的步骤就完成了。然后应该把镜像推送到Rancher中，产生容器实例，进行自动发布。新建一个阶段，添加一个步骤，这里步骤类型选择为upgradeStack。编写docker-compose配置文件，Pipeline会自动从仓库中拉取镜像，然后产生容器实例，更新之前发布的版本。<br><img src="12.jpg" alt=""></p>
<h2 id="实际应用下的步骤"><a href="#实际应用下的步骤" class="headerlink" title="实际应用下的步骤"></a>实际应用下的步骤</h2><p>上面基于GoLang语言的Demo是一个最小化的步骤示例，其实对于go语言来讲，编译是很简单的一个步骤，因为没有其他语言复杂的包依赖，构建产物也是直接的可执行文件，最后直接执行即可。但是对于公司广泛应用的Java来说，构建步骤需要考虑Jar包依赖的情况，而一般以来的Jar包都是通过maven管理，git上面是不会记录的，所以拉下来的源代码没办法直接进行编译。</p>
<p>第一反应是想到了两种方式：</p>
<ol>
<li>研发使用统一的基础镜像，在本地进行编译和打包，我们后续只对镜像进行管理。Intellij IDEA提供了插件倒是方便了直接生成镜像。</li>
<li>提供maven环境，统一在服务器上进行编译和打包，研发还是只提供源码就好。</li>
</ol>
<p>第一种想法很快就被舍弃，因为研发小伙伴未必都对docker了解，水平参差不齐的话很难对镜像进行要求和管理，学习成本略高。maven环境的话只需要把第二个阶段里golang镜像换成一个包含jdk、maven的镜像即可。</p>
<p>所以，结合现有的git flow，建议一个完整的开发流程如下：</p>
<ol>
<li>研发人员在各自负责的模块新开feature分支，强制要求每日合并到develop分支，强制要求编写单元测试用例。</li>
<li>在完成阶段性开发之后，develop分支合并到release分支或者master分支，触发webhook，开启Pipelin。</li>
<li>Rancher Pipeline 将代码下载到一个包含JDK和maven的镜像中，进行编译和打包。</li>
<li>执行单元测试。</li>
<li>测试无误之后，以一个只含有JRE的基础镜像中构建一个新的应用镜像，推送到Harbor。</li>
<li>测试环境从Harbor拉取镜像，产生容器示例，供QA进行完整的测试。</li>
<li>测试无误后发布到正式环境，这一步应当选择QA人员为审核人，审核通过的话自动发布。</li>
</ol>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>了解相关信息的过程中，也听到了一些其他的方案，比如Gogs搭配jenkins，或者GitOps和Kubernetes。但是前者集成度不佳，后者依赖于我们尚未使用的K8s，所以暂不做考虑。Rancher分享中提到的Drone似乎也是一个不错的选择，可以直接对接企业微信，推送状态，精力原因还没做详细了解，后续再进行对比。</p>
<p>参考：<br><a href="https://github.com/rancher/pipeline/blob/master/docs/README.md" target="_blank" rel="noopener">Rancher Pipeline Referince Guide</a></p>
]]></content>
      <categories>
        <category>容器</category>
      </categories>
      <tags>
        <tag>容器云</tag>
        <tag>Rancher</tag>
        <tag>Docker</tag>
        <tag>CI/CD</tag>
      </tags>
  </entry>
  <entry>
    <title>ELK应用栈的搭建和测试</title>
    <url>/2018/01/26/ELK%E5%BA%94%E7%94%A8%E6%A0%88%E7%9A%84%E6%90%AD%E5%BB%BA%E5%92%8C%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<p>本篇记录搭建、测试ELK应用栈的过程。</p>
<a id="more"></a>

<h2 id="Logstash-安装和使用"><a href="#Logstash-安装和使用" class="headerlink" title="Logstash 安装和使用"></a>Logstash 安装和使用</h2><h3 id="安装运行"><a href="#安装运行" class="headerlink" title="安装运行"></a>安装运行</h3><p>Logstash依赖于Java，所以需要预先安装jre，建议1.8版本及以上。然后在官网可以直接下载二进制压缩文件，解压即可。</p>
<h3 id="创建最简单的示例"><a href="#创建最简单的示例" class="headerlink" title="创建最简单的示例"></a>创建最简单的示例</h3><p>Logstash管道有两个最基本元素，输入和输出，和一个可选的元素，拦截器。输入插件从一个输入源中消费数据，拦截器插件按照你指定的方式修改数据，然后输出插件将数据写入到一个目的地。</p>
<p>想要验证Logstash的安装是否成功，可以运行最基本的Logstash管道：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd logstash</span></pre></td></tr><tr><td class="code"><pre><span class="line">bin&#x2F;logstash -e &#39;input &#123; stdin &#123; &#125; &#125; output &#123; stdout &#123;&#125; &#125;&#39;</span></pre></td></tr></table></figure>

<p><code>-e</code>标志可以直接通过命令行指定配置，从而让你快速的测试配置而不用多次修改一个配置文件。这个示例中的管道从标准输入<code>stdin</code>中获取输入，然后用一个结构化的格式把数据移动到标准输出<code>stdout</code>。</p>
<p>在启动Logstash完成之后，看到<code>Pipline started</code>提示后，可以在命令行中输入<code>hello world</code>，你会看到：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hello world</span></pre></td></tr><tr><td class="code"><pre><span class="line">2018-01-25T09:26:53.134Z caih-OptiPlex-7050 hello world</span></pre></td></tr></table></figure>

<p>Logstash在信息中添加了时间戳和主机名。</p>
<h3 id="使用Logstash解析日志"><a href="#使用Logstash解析日志" class="headerlink" title="使用Logstash解析日志"></a>使用Logstash解析日志</h3><p>前例中，我们创建了一个最基本的Logstash管道用来测试Logstash是否启动成功。实际应用中，Logstash管道会复杂很多，它会有多个不同类型的输入，有拦截器，还有输出插件。</p>
<h4 id="直接使用Logstash跟踪日志文件"><a href="#直接使用Logstash跟踪日志文件" class="headerlink" title="直接使用Logstash跟踪日志文件"></a>直接使用Logstash跟踪日志文件</h4><p>Logstash也可以不借助Filebeat，直接跟踪日志文件。</p>
<p>这里我们写一个简单的shell脚本，名为log.sh，每一秒钟往日志文件里输出一个时间戳，然后跟踪这个日志文件。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># &#x2F;bin&#x2F;bash</span></pre></td></tr><tr><td class="code"><pre><span class="line">while :</span></pre></td></tr><tr><td class="code"><pre><span class="line">do</span></pre></td></tr><tr><td class="code"><pre><span class="line">  current&#x3D;&#96;date &quot;+%Y-%m-%d %H:%M:%S&quot;&#96;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  echo $current &gt;&gt; log.log</span></pre></td></tr><tr><td class="code"><pre><span class="line">  sleep 1s</span></pre></td></tr><tr><td class="code"><pre><span class="line">done</span></pre></td></tr></table></figure>

<p>使用命令<code>nohup bash log.sh &amp;</code>让这个脚本在后台执行。然后<code>tail -f log.log</code>就可以看到日志文件在不断增加。</p>
<p>回到logstash的目录下bin文件夹，创建一个简单的配置文件，名为logstash.conf:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">input &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  file &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    path &#x3D;&gt; [&quot;&#x2F;home&#x2F;caih&#x2F;docker&#x2F;logstash&#x2F;log&#x2F;log.log&quot;]</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">output &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  stdout&#123;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>这个配置非常简单，就是在追踪刚才写的日志作为输入，然后在命令行输出。<br>执行命令<code>./logstash -f logstash.conf</code>，稍等之后就可以看到日志中打印的时间戳出现啦，同时每一条日志前面会有logstash添加的时间戳和主机名。这时候遇到了一个问题，就是logstash运行之前的那些历史日志，会有乱序。我怀疑是多个线程同时收集日志导致的顺序问题。这时候修改config文件夹里面的logstash.yml，将pipieline.worker改为1，这个情况有了好转，但是仍然偶尔可见顺序问题，尚有待解决。</p>
<p>可以注意到，每次重启logstash之后，日志都是从上次的结束为止开始输出的，那么如何每次都从日志文件的开头开始输出呐？可以修改配置如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">input &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  file &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    path &#x3D;&gt; [&quot;&#x2F;home&#x2F;caih&#x2F;docker&#x2F;logstash&#x2F;log&#x2F;log.log&quot;]</span></pre></td></tr><tr><td class="code"><pre><span class="line">    start_position &#x3D;&gt; &quot;beginning&quot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    sincedb_path &#x3D;&gt; &quot;&#x2F;dev&#x2F;null&quot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">output &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  stdout&#123;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>Logstash跟踪日志的时候，标记追踪位置的数据存储在sincedb中，这里sincedb_path就是指定sincedb文件的位置，然后把它配置为linux中自带的空位置，就实现了每次从头开始的目的。<br>注意，start_position只是说每次从sincedb中标记的起点开始，不是从文件头开始，所以只添加这一项是不行的。</p>
<p>然后同样的，可以把文件位置改为系统日志：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">input &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  file &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    path &#x3D;&gt; [&quot;&#x2F;var&#x2F;log&#x2F;*.log&quot;]</span></pre></td></tr><tr><td class="code"><pre><span class="line">    type &#x3D;&gt; &quot;system&quot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    start_position &#x3D;&gt; &quot;beginning&quot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    sincedb_path &#x3D;&gt; &quot;&#x2F;dev&#x2F;null&quot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">output &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  stdout&#123;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>可以看到系统日志的情况。</p>
<h4 id="借助Filebeat采集日志"><a href="#借助Filebeat采集日志" class="headerlink" title="借助Filebeat采集日志"></a>借助Filebeat采集日志</h4><p>这部分我们创建一个Logstash管道，使用Filebeat将Apache的日志作为输入，解析这些日志，然后从中创建特定的、命名规范的字段，然后把数据输入到Elasticsearch集群中。这里使用配置文件来定义管道，而不是使用命令行参数。</p>
<h5 id="关于Filebeat"><a href="#关于Filebeat" class="headerlink" title="关于Filebeat"></a>关于Filebeat</h5><p>Logstash可以Filebeat配合使用来收集日志，那么Filebeat是个什么东西呐？</p>
<p>Filebeat是一个本地文件的日志信息收集器。安装后可以作为你服务端的代理，Filebeat监控日志目录或者指定的日志文件，不断输出文件然后将他们发送到Elasticsearch和Logstash进行索引。</p>
<p>Filebeat的工作模式是这样的：你启动Filebeat之后，它会开启一个或者多个勘探者（prospector）来跟踪本地路径下你指定的日志文件。对于每一个勘探者定位到的文件，Filebeat会启动一个收割者（harvester）。每个收割者读取单个日志文件，发送到libbeat，libbeat会聚合所有时间，然后发送到你配置好的输出中。  </p>
<p><img src="https://www.elastic.co/guide/en/beats/filebeat/6.1/images/filebeat.png" alt=""></p>
<p>Filebeat的安装很简单，在Ubuntu上只需要执行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -L -O https:&#x2F;&#x2F;artifacts.elastic.co&#x2F;downloads&#x2F;beats&#x2F;filebeat&#x2F;filebeat-6.1.2-amd64.deb</span></pre></td></tr><tr><td class="code"><pre><span class="line">sudo dpkg -i filebeat-6.1.2-amd64.deb</span></pre></td></tr></table></figure>

<p>安装完成之后，可以在/etc/filebeat/filebeat.yml文件中查看和更改配置。在Docker环境中，这个文件的位置是在/usr/share/filebeat/filebeat.yml。</p>
<p>这里以一个简单的配置为例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">filebeat.prospectors:</span></pre></td></tr><tr><td class="code"><pre><span class="line">- type: log</span></pre></td></tr><tr><td class="code"><pre><span class="line">  enabled: true</span></pre></td></tr><tr><td class="code"><pre><span class="line">  paths:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    - &#x2F;var&#x2F;log&#x2F;*.log</span></pre></td></tr><tr><td class="code"><pre><span class="line">    #- c:\programdata\elasticsearch\logs\*</span></pre></td></tr></table></figure>

<p>更详细的文档格式可以参看<a href="http://www.elastic.co/guide/en/beats/libbeat/6.1/config-file-format.html" target="_blank" rel="noopener">官方文档</a>，这里只配置一个简单的栗子。</p>
<h5 id="配置Filebeat来发送日志行到Logstash"><a href="#配置Filebeat来发送日志行到Logstash" class="headerlink" title="配置Filebeat来发送日志行到Logstash"></a>配置Filebeat来发送日志行到Logstash</h5><p>在创建Logstash管道之前，需要配置Filebeat用来发送日志到Logstash。Filebeat客户端是一个轻量级，资源友好型工具，用来从服务端的文件中收集日志，然后发送这些日志到Logstash实例中处理。Filebeat的设计理念是高可用和低延时。Filebeat有一个宿主机上轻量的资源占用，而且<code>Beats input</code>插件将Logstash实例上的资源需求做到了最小化。</p>
<p>创建Filebeat的配置文件名为filebeat.yml，内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">filebeat.prospectors:</span></pre></td></tr><tr><td class="code"><pre><span class="line">- type: log</span></pre></td></tr><tr><td class="code"><pre><span class="line">  paths:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    - &#x2F;home&#x2F;caih&#x2F;docker&#x2F;logstash&#x2F;log&#x2F;log.log</span></pre></td></tr><tr><td class="code"><pre><span class="line">output.logstash:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    hosts: [&quot;127.0.0.1:5044&quot;]</span></pre></td></tr></table></figure>

<p>其中的paths就是需要跟踪的日志地址。</p>
<p>然后修改Logstash的配置文件:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">input &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  beats &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    port &#x3D;&gt; &quot;5044&quot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">output &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    stdout &#123; codec &#x3D;&gt; rubydebug &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>然后分别启动两者就可以了，启动Filebeat：<code>filebeat -e -c /home/caih/docker/filebeat/filebeat.yml -d &quot;publish&quot;</code>；启动Logstash：<code>./logstash -f logstash.conf</code>，随后就可以看到日志源源不断地在命令行出现啦！</p>
<h2 id="Elasticsearch-安装和使用"><a href="#Elasticsearch-安装和使用" class="headerlink" title="Elasticsearch 安装和使用"></a>Elasticsearch 安装和使用</h2><h3 id="安装运行-1"><a href="#安装运行-1" class="headerlink" title="安装运行"></a>安装运行</h3><p>Elasticsearch的安装非常简单，需要依赖只有Java 1.8之后的版本。然后在官网下载文件，解压文件即可。</p>
<p>进入解压后的文件夹，bin目录下有名为Elasticsearch的可执行文件，执行<code>./elasticsearch</code>就可以启动了。</p>
<p><code>./elasticsearch --help</code>查看命令帮助，可以使用<code>./elasticsearch -d</code>在后台执行，不在当前命令行输出日志。</p>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>进入config文件夹可以看到配置文件，其中elasticsearch的配置是在elasticsearch.yml中，另外的jvm.options可以修改Java虚拟机的相关配置，log4j2.properties可以修改el本身的日志配置。</p>
<p>在elasticsearch.yml中，修改netword.host的值为0.0.0.0，然后就可以其他主机访问了。其他常用的配置还包括集群名称，节点名称，日志地址，端口号等等，更多的信息不再赘述。</p>
<p>在浏览器输入ip:9200，可以看到返回:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &quot;name&quot; : &quot;t_ksdEI&quot;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &quot;cluster_name&quot; : &quot;elasticsearch&quot;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &quot;cluster_uuid&quot; : &quot;LdO3LVVyRPGwTARorxrNBA&quot;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &quot;version&quot; : &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &quot;number&quot; : &quot;5.5.3&quot;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &quot;build_hash&quot; : &quot;9305a5e&quot;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &quot;build_date&quot; : &quot;2017-09-07T15:56:59.599Z&quot;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &quot;build_snapshot&quot; : false,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &quot;lucene_version&quot; : &quot;6.6.0&quot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &quot;tagline&quot; : &quot;You Know, for Search&quot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>这样表示Elasticsearch启动成功。</p>
<h3 id="添加一条文档"><a href="#添加一条文档" class="headerlink" title="添加一条文档"></a>添加一条文档</h3><p>在命令行输入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -XPUT &#39;localhost:9200&#x2F;customer&#x2F;doc&#x2F;1?pretty&amp;pretty&#39; -H &#39;Content-Type: application&#x2F;json&#39; -d&#39;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&gt;   &quot;name&quot;: &quot;John Doe&quot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&gt; &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&gt; &#39;</span></pre></td></tr></table></figure>

<p>然后就添加了一条最简单的文档，稍后可以在Kibana中看到。</p>
<h2 id="Kibana-安装和使用"><a href="#Kibana-安装和使用" class="headerlink" title="Kibana 安装和使用"></a>Kibana 安装和使用</h2><p>Kibana的安装同样简单，同样依赖于Java，官网下载tar包解压，然后进入bin目录，使用命令<code>./kibana --help</code>可以查看启动参数。</p>
<p>输入<code>./kibana serve</code>即可启动，这里需要注意与Elasticsearch版本是否匹配。我这里用的都是最新版6.1.2。Kiana默认寻找得是本地9200端口的Elasticsearch，如果要指定别的地方的实例，可以在/config/kiban.yml中修改。还有一点，Kibana默认host是本地，所以要修改为0.0.0.0然后才能在其他机器上访问。</p>
<p>输入ip:5601就可以看到Kibana的ui界面了，刚开始会让你输入一个index pattern，可以先输入*匹配所有索引，然后再Discover中就可以看到Elasticsearch中的数据了。</p>
<h2 id="从日志文件到Kibana"><a href="#从日志文件到Kibana" class="headerlink" title="从日志文件到Kibana"></a>从日志文件到Kibana</h2><p>日志到Logstash已经联通，Elasticsearch和Kibana也连上了，现在只需要把Logstash的output设置为Elasticsearch。</p>
<p>修改logstash.conf如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">input &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  file &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    path &#x3D;&gt; [&quot;&#x2F;home&#x2F;caih&#x2F;docker&#x2F;logstash&#x2F;log&#x2F;log.log&quot;]</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">output &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    elasticsearch &#123; hosts &#x3D;&gt; [&quot;localhost:9200&quot;] &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>然后Logstash默认的索引是以logstash-开头，所以把kibana中的index pattern修改为logstash-*就可以过滤结果了。这时候在discover部分就可以看到每秒钟一条的时间戳。</p>
<p>Kibana默认的配置中，这里的信息是不自动刷新的，所以想要修改刷新频率，在Management -&gt; advance中，把<code>timepicker:refreshIntervalDefaults</code>这一项修改为<code>{ &quot;display&quot;: &quot;5 seconds&quot;, &quot;pause&quot;: false, &quot;value&quot;: 5000 }</code>，然后就可以看到日志五秒刷新一次，不断更新。</p>
<p>以上就是ELK栈收集、处理、展示日志最简单的demo。</p>
]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>运维</tag>
        <tag>容器云</tag>
        <tag>ELK</tag>
        <tag>日志</tag>
      </tags>
  </entry>
  <entry>
    <title>dockerfile指南及最佳实践</title>
    <url>/2018/01/11/dockerfile%E6%8C%87%E5%8D%97%E5%8F%8A%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/</url>
    <content><![CDATA[<p>学习Docker的时候遇到了不少问题，也有同事询问的时候不能回答上来，所以系统的记录一些Docker原理方面的学习过程。先从dockerfile入手，本篇主要是官网文档的翻译。</p>
<a id="more"></a>
<h2 id="Docker的内核基础"><a href="#Docker的内核基础" class="headerlink" title="Docker的内核基础"></a>Docker的内核基础</h2><p>提到Docker，基本都知道其本质是宿主机上面的一个进程，通过namespace实现了资源隔离。通过cgroups实现了资源限制，通过写时复制（copy-on-write）实现了高效的文件操作。从Linux内核3.8版本开始，提供了namespace功能，主要分为以下六项隔离：</p>
<ul>
<li>UTS：主机名与域名</li>
<li>IPC：信号量、消息队列和共享内存</li>
<li>PID：进程编号</li>
<li>Network：网络设备、网络栈、端口等</li>
<li>Mount：挂载点（文件系统）</li>
<li>User：用户和用户组</li>
</ul>
<h3 id="Docker自底向上的结构"><a href="#Docker自底向上的结构" class="headerlink" title="Docker自底向上的结构"></a>Docker自底向上的结构</h3><p>构建一个Docker应用可以分为以下三层：</p>
<ul>
<li>Stack</li>
<li>Service</li>
<li>Container</li>
</ul>
<h3 id="使用Dockerfile定义一个容器"><a href="#使用Dockerfile定义一个容器" class="headerlink" title="使用Dockerfile定义一个容器"></a>使用Dockerfile定义一个容器</h3><p>Dockerfile定义了你的容器内的环境发生了什么。在这个环境里，资源的获取比如网络接口或者磁盘驱动都是虚拟化的，并且与你系统的其他部分是隔离开的，所以你必须将端口映射到外面，而且你必须制定那些文件需要“复制”到这个环境以内。</p>
<p>Docker可以通过Dockerfile的命令构建一个镜像，使用Docker build命令可以创建一个连续的命令行指令进行自动构建。</p>
<h2 id="Dockerfile指南"><a href="#Dockerfile指南" class="headerlink" title="Dockerfile指南"></a>Dockerfile指南</h2><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><p><code>docker build</code>命令从Dockerfile和上下文中构建镜像。构建的上下文是在特定位置的文件的集合，比如PATH和URL，PATH是你本地文件系统的目录，URL是git仓库地址。</p>
<p>上下文是递归处理的，所以PATH包括了子目录，URL也包括了仓库和它的子模块。比如把整个当前路径都作为上下文：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker build .</span></pre></td></tr><tr><td class="code"><pre><span class="line">Sending build context to Docker daemon  6.51 MB</span></pre></td></tr><tr><td class="code"><pre><span class="line">···</span></pre></td></tr></table></figure>

<p>为了在构建上下文的时候使用一个文件，Dockerfile使用一个命令去指定某个文件，比如COPY命令。为了增加构建过程的性能，可以通过添加.dockerignore来排除某些文件。</p>
<p>通常情况下，Dockerfile就叫Dockerfile，你可以使用<code>-f</code>命令指定使用某个Dockerfile,用法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker build -f &#x2F;path&#x2F;to&#x2F;a&#x2F;Dockerfile .</span></pre></td></tr></table></figure>

<p>如果构建成功，你也可以指定一个仓库和标签来说明在哪里存储你的镜像：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker build -t shykes&#x2F;myapp .</span></pre></td></tr></table></figure>

<p>为了在构建完成之后，给镜像标注多个仓库，可以添加多个<code>-t</code>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker build -t shykes&#x2F;myapp:1.0.2 -t shykes&#x2F;myapp:latest .</span></pre></td></tr></table></figure>

<p>在Docker守护进程执行Dockerfile中的命令之前，它会执行一个初步的验证，如果语法不正确会返回错误：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker build -t test&#x2F;myapp .</span></pre></td></tr><tr><td class="code"><pre><span class="line">Sending build context to Docker daemon 2.048 kB</span></pre></td></tr><tr><td class="code"><pre><span class="line">Error response from daemon: Unknown instruction: RUNCMD</span></pre></td></tr></table></figure>

<p>Docker守护进程会依次逐条执行Dockerfile中的命令，在返回最终镜像的ID之前，如果需要，每一条命令的结果都会提交成为一个新的镜像。Docker守护进程会自动清理你发送的上下文。</p>
<p>需要注意，每一条命令都是独立运行的，而且会导致新的镜像被创建，所以<code>RUN cd /tmp</code>不会在对下一条命令产生任何影响。</p>
<p>如果可能，Docker会重新利用中间镜像（缓存），从而让docker build过程显著加快。你可以从控制台输出中看到<code>Using cache</code>的提示。（想要了解更多信息，参照Dockerfile最佳实践中的<a href="https://docs.docker.com/engine/userguide/eng-image/dockerfile_best-practices/#build-cache" target="_blank" rel="noopener">构建缓存</a>部分）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker build -t svendowideit&#x2F;ambassador .</span></pre></td></tr><tr><td class="code"><pre><span class="line">Sending build context to Docker daemon 15.36 kB</span></pre></td></tr><tr><td class="code"><pre><span class="line">Step 1&#x2F;4 : FROM alpine:3.2</span></pre></td></tr><tr><td class="code"><pre><span class="line"> ---&gt; 31f630c65071</span></pre></td></tr><tr><td class="code"><pre><span class="line">Step 2&#x2F;4 : MAINTAINER SvenDowideit@home.org.au</span></pre></td></tr><tr><td class="code"><pre><span class="line"> ---&gt; Using cache</span></pre></td></tr><tr><td class="code"><pre><span class="line"> ---&gt; 2a1c91448f5f</span></pre></td></tr><tr><td class="code"><pre><span class="line">Step 3&#x2F;4 : RUN apk update &amp;&amp;      apk add socat &amp;&amp;        rm -r &#x2F;var&#x2F;cache&#x2F;</span></pre></td></tr><tr><td class="code"><pre><span class="line"> ---&gt; Using cache</span></pre></td></tr><tr><td class="code"><pre><span class="line"> ---&gt; 21ed6e7fbb73</span></pre></td></tr><tr><td class="code"><pre><span class="line">Step 4&#x2F;4 : CMD env | grep _TCP&#x3D; | (sed &#39;s&#x2F;.*_PORT_\([0-9]*\)_TCP&#x3D;tcp:\&#x2F;\&#x2F;\(.*\):\(.*\)&#x2F;socat -t 100000000 TCP4-LISTEN:\1,fork,reuseaddr TCP4:\2:\3 \&amp;&#x2F;&#39; &amp;&amp; echo wait) | sh</span></pre></td></tr><tr><td class="code"><pre><span class="line"> ---&gt; Using cache</span></pre></td></tr><tr><td class="code"><pre><span class="line"> ---&gt; 7ea8aef582cc</span></pre></td></tr><tr><td class="code"><pre><span class="line">Successfully built 7ea8aef582cc</span></pre></td></tr></table></figure>

<p>构建缓存只有在那些拥有本地父母链（local parent chain）的镜像中被使用。这意味着那些镜像是被前一阶段的构建产物所创造，或者被<code>docker load</code>装载的整个镜像链条所创造。如果你想指定某一个镜像使用构建缓存，你可以用<code>--cache-from</code>选项来指定。</p>
<p>完成你的构建过程之后，你就可以准备浏览<a href="https://docs.docker.com/get-started/" target="_blank" rel="noopener">将存储仓库推入注册</a></p>
<h3 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h3><p>Dockerfile的格式是这样的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Comment</span></pre></td></tr><tr><td class="code"><pre><span class="line">INSTRUCTION arguments</span></pre></td></tr></table></figure>

<p>指令是大小写不敏感的，但是惯例是把指令都写成大写，方便与参数区分开。</p>
<p>Docker会按照顺序执行Dockerfile中的指令，一个Dockerfile必须从<code>FROM</code>命令开始，<code>FROM</code>命令指定了一个你要构建的基础镜像。</p>
<p>Docker会把以<code>#</code>为起始的一行视为注释，除非这一行是一个有效的解析指令(parse directives)。一个在其他位置出现的<code>#</code>会被当做是参数的一部分，所以允许这样的语句：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Comment</span></pre></td></tr><tr><td class="code"><pre><span class="line">RUN echo &#39;we are running some # of cool things&#39;</span></pre></td></tr></table></figure>

<h3 id="解析指令-Parse-directives"><a href="#解析指令-Parse-directives" class="headerlink" title="解析指令 Parse directives"></a>解析指令 Parse directives</h3><p>解析指令是可选的，而且会影响Dockerfile中后续指令行的处理方式。解析指令不会增加新的构建层数，也不会被认为是一个构建步骤。它的写法是类似于特殊的注释：<code># directive=value</code>一个解析指令只被使用一次。</p>
<p>每当一个注释、空行或者构建指令被处理之后，Docker不会再去寻找解析指令。取而代之的是它会把解析指令格式的命令行视为一个注释，而且不会尝试去验证这是否是一个解析指令。因此，所有的解析指令都应该在Dockerfile的最上方。</p>
<p>解析指令大小写不敏感，按照惯例我们写成小写格式，而且后面添加一个空行。解析指令不支持行延长符号，所以如下是无效的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># direc \</span></pre></td></tr><tr><td class="code"><pre><span class="line">tive&#x3D;value</span></pre></td></tr></table></figure>

<p>重复出现两次也是无效的:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># directive&#x3D;value1</span></pre></td></tr><tr><td class="code"><pre><span class="line"># directive&#x3D;value2</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">FROM ImageName</span></pre></td></tr></table></figure>

<p>出现在构建指令之后的解析指令会被当做普通注释：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FROM ImageName</span></pre></td></tr><tr><td class="code"><pre><span class="line"># directive&#x3D;value</span></pre></td></tr></table></figure>

<p>出现在普通注释之后的解析指令也会被当做普通注释：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># About my dockerfile</span></pre></td></tr><tr><td class="code"><pre><span class="line"># directive&#x3D;value</span></pre></td></tr><tr><td class="code"><pre><span class="line">FROM ImageName</span></pre></td></tr></table></figure>

<p>非法的解析指令会被当做普通注释，此外，紧随其后的合法解析指令也会被当做注释，因为出现在一条注释之后。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># unknowndirective&#x3D;value</span></pre></td></tr><tr><td class="code"><pre><span class="line"># knowndirective&#x3D;value</span></pre></td></tr></table></figure>

<p>不换行空格允许出现在解析指令之中。因此，下列行被认为已知：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#directive&#x3D;value</span></pre></td></tr><tr><td class="code"><pre><span class="line"># directive &#x3D;value</span></pre></td></tr><tr><td class="code"><pre><span class="line">#	directive&#x3D; value</span></pre></td></tr><tr><td class="code"><pre><span class="line"># directive &#x3D; value</span></pre></td></tr><tr><td class="code"><pre><span class="line">#	  dIrEcTiVe&#x3D;value</span></pre></td></tr></table></figure>

<p>支持以下解析指令：<code>escape</code></p>
<h3 id="escape"><a href="#escape" class="headerlink" title="escape"></a>escape</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># escape&#x3D;\ (backslash)</span></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># escape&#x3D;&#96; (backtick)</span></pre></td></tr></table></figure>

<p><code>escape</code>指令指定Dockerfile中的转义字符，如果没有指定，默认的转义字符是<code>\</code>.</p>
<p>转义字符不仅作用在行中的转义字符，也作用在换行符。这允许一个Dockerfile指令跨越多行。需要注意，无论escape解释语句是否出现在Dockerfile中，转义不会在<code>RUN</code>命令中生效，除非在行尾。</p>
<p>将转义字符设置为`在Windows中尤其有用，因为\是地址分隔符，`与<a href="https://technet.microsoft.com/en-us/library/hh847755.aspx" target="_blank" rel="noopener">Windows PowerShell</a>相一致。</p>
<p>考虑到下面的例子会在Windows中以一个不明显的方式失败。在第二行结束位置的第二个\会被当做换行符，而不是第一个\转义的目标。同样，在第三行末尾位置的\，假设它实际上是作用为一个指令，他被当做一个行延长符。这个Dockerfile的结果是第二行和第三行被当做一个单独的指令。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FROM microsoft&#x2F;nanoserver</span></pre></td></tr><tr><td class="code"><pre><span class="line">COPY testfile.txt c:\\</span></pre></td></tr><tr><td class="code"><pre><span class="line">RUN dir c:\</span></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PS C:\John&gt; docker build -t cmd .</span></pre></td></tr><tr><td class="code"><pre><span class="line">Sending build context to Docker daemon 3.072 kB</span></pre></td></tr><tr><td class="code"><pre><span class="line">Step 1&#x2F;2 : FROM microsoft&#x2F;nanoserver</span></pre></td></tr><tr><td class="code"><pre><span class="line"> ---&gt; 22738ff49c6d</span></pre></td></tr><tr><td class="code"><pre><span class="line">Step 2&#x2F;2 : COPY testfile.txt c:\RUN dir c:</span></pre></td></tr><tr><td class="code"><pre><span class="line">GetFileAttributesEx c:RUN: The system cannot find the file specified.</span></pre></td></tr><tr><td class="code"><pre><span class="line">PS C:\John&gt;</span></pre></td></tr></table></figure>

<p>一个解决方案是使用<code>/</code>作为<code>COPY</code>指令和<code>dir</code>指令的目标。然而最好的情况下，这个语法在Windows上也并不自然，令人困惑，在比较坏的情况下，在Windows上使用<code>/</code>作为地址分隔符有可能出现错误。</p>
<p>通过添加escape解析指令，下面的Dockerfile成功的使用原生的系统地址分割语法如期执行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># escape&#x3D;&#96;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">FROM microsoft&#x2F;nanoserver</span></pre></td></tr><tr><td class="code"><pre><span class="line">COPY testfile.txt c:\</span></pre></td></tr><tr><td class="code"><pre><span class="line">RUN dir c:\</span></pre></td></tr></table></figure>
<p>结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PS C:\John&gt; docker build -t succeeds --no-cache&#x3D;true .</span></pre></td></tr><tr><td class="code"><pre><span class="line">Sending build context to Docker daemon 3.072 kB</span></pre></td></tr><tr><td class="code"><pre><span class="line">Step 1&#x2F;3 : FROM microsoft&#x2F;nanoserver</span></pre></td></tr><tr><td class="code"><pre><span class="line"> ---&gt; 22738ff49c6d</span></pre></td></tr><tr><td class="code"><pre><span class="line">Step 2&#x2F;3 : COPY testfile.txt c:\</span></pre></td></tr><tr><td class="code"><pre><span class="line"> ---&gt; 96655de338de</span></pre></td></tr><tr><td class="code"><pre><span class="line">Removing intermediate container 4db9acbb1682</span></pre></td></tr><tr><td class="code"><pre><span class="line">Step 3&#x2F;3 : RUN dir c:\</span></pre></td></tr><tr><td class="code"><pre><span class="line"> ---&gt; Running in a2c157f842f5</span></pre></td></tr><tr><td class="code"><pre><span class="line"> Volume in drive C has no label.</span></pre></td></tr><tr><td class="code"><pre><span class="line"> Volume Serial Number is 7E6D-E0F7</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"> Directory of c:\</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">10&#x2F;05&#x2F;2016  05:04 PM             1,894 License.txt</span></pre></td></tr><tr><td class="code"><pre><span class="line">10&#x2F;05&#x2F;2016  02:22 PM    &lt;DIR&gt;          Program Files</span></pre></td></tr><tr><td class="code"><pre><span class="line">10&#x2F;05&#x2F;2016  02:14 PM    &lt;DIR&gt;          Program Files (x86)</span></pre></td></tr><tr><td class="code"><pre><span class="line">10&#x2F;28&#x2F;2016  11:18 AM                62 testfile.txt</span></pre></td></tr><tr><td class="code"><pre><span class="line">10&#x2F;28&#x2F;2016  11:20 AM    &lt;DIR&gt;          Users</span></pre></td></tr><tr><td class="code"><pre><span class="line">10&#x2F;28&#x2F;2016  11:20 AM    &lt;DIR&gt;          Windows</span></pre></td></tr><tr><td class="code"><pre><span class="line">           2 File(s)          1,956 bytes</span></pre></td></tr><tr><td class="code"><pre><span class="line">           4 Dir(s)  21,259,096,064 bytes free</span></pre></td></tr><tr><td class="code"><pre><span class="line"> ---&gt; 01c7f3bef04f</span></pre></td></tr><tr><td class="code"><pre><span class="line">Removing intermediate container a2c157f842f5</span></pre></td></tr><tr><td class="code"><pre><span class="line">Successfully built 01c7f3bef04f</span></pre></td></tr><tr><td class="code"><pre><span class="line">PS C:\John&gt;</span></pre></td></tr></table></figure>

<h3 id="环境替换"><a href="#环境替换" class="headerlink" title="环境替换"></a>环境替换</h3><p>环境变量（通过<code>ENV</code>命令声明的）也可以在用在某一指令中，像一个变量一样被Dockerfile解释。转义也被用作将类变量语法逐字逐句的包含到声明中。（Environment variables (declared with the ENV statement) can also be used in certain instructions as variables to be interpreted by the Dockerfile. Escapes are also handled for including variable-like syntax into a statement literally.）</p>
<p>环境变量在Dockerfile中会表示为<code>$variable_name</code>或者<code>${variable_name}</code>。这两种表述方式等价，其中大括号方式通常被用作表述没有空格的变量名字，像<code>${foo}_bar</code>。</p>
<p><code>${variable_name}</code>这种语法同样支持几种标准的bash编辑方式如下：</p>
<ul>
<li><code>${variable:-word}</code>表示如果变量是一个集合，那么结果就是集合的值，否则结果是word。</li>
<li><code>${variable:+word}</code>表示如果变量是一个集合，那么结果是word，否则是空字符串。</li>
</ul>
<p>在所有情况下，<code>word</code>可以使任何字符串，包括额外的环境变量。</p>
<p>可以通过在变量前添加<code>\</code>进行转义：<code>\$foo</code>或者<code>\${foo}</code>。比如下面的例子，将会对<code>$foo</code>和<code>${foo}</code>逐字严格各自转换。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FROM busybox</span></pre></td></tr><tr><td class="code"><pre><span class="line">ENV foo &#x2F;bar</span></pre></td></tr><tr><td class="code"><pre><span class="line">WORKDIR $&#123;foo&#125;   # WORKDIR &#x2F;bar</span></pre></td></tr><tr><td class="code"><pre><span class="line">ADD . $foo       # ADD . &#x2F;bar</span></pre></td></tr><tr><td class="code"><pre><span class="line">COPY \$foo &#x2F;quux # COPY $foo &#x2F;quux</span></pre></td></tr></table></figure>

<p>环境变量在所有下列指令中被支持：</p>
<ul>
<li><code>ADD</code></li>
<li><code>COPY</code></li>
<li><code>ENV</code></li>
<li><code>EXPOSE</code></li>
<li><code>FROM</code></li>
<li><code>LABEL</code></li>
<li><code>STOPSIGNAL</code></li>
<li><code>USER</code></li>
<li><code>VOLUMN</code></li>
<li><code>WORKDIR</code></li>
</ul>
<p>同样的：</p>
<ul>
<li><code>ONBUILD</code>（与其他上述指令一同使用的时候）</li>
</ul>
<p>在整个指令中，环境变量替代物会为每一个变量使用同一个值。如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ENV abc&#x3D;hello</span></pre></td></tr><tr><td class="code"><pre><span class="line">ENV abc&#x3D;bye def&#x3D;$abc</span></pre></td></tr><tr><td class="code"><pre><span class="line">ENV ghi&#x3D;$abc</span></pre></td></tr></table></figure>

<p>结果是def的值为hello，而不是bye。然而，ghi的值是bye因为这不是将abc设置为bye的那条语句。</p>
<h3 id="dockerignore-file"><a href="#dockerignore-file" class="headerlink" title=".dockerignore file"></a>.dockerignore file</h3><p>在docker命令行把上下文发送给docker守护进程之前，它会在上下文路径的根目录下搜索文件名为.dockerignore的文件。如果文件存在，命令行就会把符合的文件从上下文中排除出去。</p>
<p>.dockerignore文件的示例如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># comment</span></pre></td></tr><tr><td class="code"><pre><span class="line">*&#x2F;temp*</span></pre></td></tr><tr><td class="code"><pre><span class="line">*&#x2F;*&#x2F;temp*</span></pre></td></tr><tr><td class="code"><pre><span class="line">temp?</span></pre></td></tr></table></figure>

<p>这个文件会产生如下构建行为：<br>命令|行为<br>—|—<br><code>#comment</code>|忽略<br><code>*/temp*</code>|排除根路径下所有直接子目录内文件名或者目录名以<code>temp</code>为开头的文件或文件夹。比如：<code>/somedir/temporary.txt</code>就被排除了,或者路径<code>/somedir/temp</code>。<br><code>*/*/temp*</code>|排除所有根路径下二级子目录中以<code>temp</code>为起始文件名的文件或文件夹。比如：<code>/somedir/subdir/temporary.txt</code>。<br><code>temp?</code>|排除根目录下文件名或目录名是<code>temp</code>后面加一个字符。比如：<code>/tempa</code>和<code>tempb</code>。</p>
<p>具体用法和.gitignore类似，不再赘述。</p>
<h3 id="FROM"><a href="#FROM" class="headerlink" title="FROM"></a>FROM</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FROM &lt;image&gt; [AS &lt;name&gt;]</span></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FROM &lt;image&gt;[:&lt;tag&gt;] [AS &lt;name&gt;]</span></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FROM &lt;image&gt;[@&lt;digest&gt;] [AS &lt;name&gt;]</span></pre></td></tr></table></figure>

<p><code>FROM</code>指令初始化了一个新的构建阶段，而且为后续的指令准备了基础镜像。所以，一个有效的Dockerfile应该以<code>FROM</code>指令起始。镜像可以是任何有效的镜像，尤其简单的是可以从公共仓库下载镜像作为开始。</p>
<ul>
<li><code>ARG</code>是唯一可以出现在<code>FROM</code>之前的指令。</li>
<li>在一个Dockerfile中，<code>FROM</code>可以出现多次，创建多个镜像，或者把一个构建阶段作为另一个的依赖。只需要注意，在一条新的<code>FROM</code>指令提交之前把上一个的镜像ID记录下来。每一个<code>FROM</code>指令会清除之前指令创造的所有状态。</li>
<li>可选的，使用<code>AS name</code>语句可以赋予新的构建阶段可以一个名称。这个名称还可以在随后的<code>FROM</code>和<code>COPY --from=&lt;name|index&gt;</code>中使用以指定某个镜像。</li>
<li><code>tag</code>或者<code>digest</code>选项是可选的。如果你都省略了，系统会缺省设置<code>latest</code>标签。如果找不到任何<code>tag</code>的值，构建器会返回一个错误。</li>
</ul>
<h3 id="理解ARG和FROM是如何相互需作用的"><a href="#理解ARG和FROM是如何相互需作用的" class="headerlink" title="理解ARG和FROM是如何相互需作用的"></a>理解ARG和FROM是如何相互需作用的</h3><p><code>FROM</code>指令支持那些由<code>ARG</code>声明的，出现在自身之前的变量。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ARG  CODE_VERSION&#x3D;latest</span></pre></td></tr><tr><td class="code"><pre><span class="line">FROM base:$&#123;CODE_VERSION&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">CMD  &#x2F;code&#x2F;run-app</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">FROM extras:$&#123;CODE_VERSION&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">CMD  &#x2F;code&#x2F;run-extras</span></pre></td></tr></table></figure>

<p>一个<code>FROM</code>指令之前的<code>ARG</code>声明是独立于构建阶段之外的，所以不能在<code>FROM</code>之后的任何指令中使用。想要使用<code>FROM</code>指令之前的<code>ARG</code>指令的默认属性，你需要在构建阶段之内再使用一次不带赋值的<code>ARG</code>指令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ARG VERSION&#x3D;latest</span></pre></td></tr><tr><td class="code"><pre><span class="line">FROM busybox:$VERSION</span></pre></td></tr><tr><td class="code"><pre><span class="line">ARG VERSION</span></pre></td></tr><tr><td class="code"><pre><span class="line">RUN echo $VERSION &gt; image_version</span></pre></td></tr></table></figure>

<h3 id="RUN"><a href="#RUN" class="headerlink" title="RUN"></a>RUN</h3><p>RUN命令有两种格式;</p>
<ul>
<li><code>RUN &lt;command&gt;</code>（shell格式，命令在shell中执行，默认是Linux中的<code>/bin/sh -c</code>后者Windows中的<code>cmd /s /c</code>）</li>
<li><code>RUN [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]</code>（执行格式）</li>
</ul>
<p><code>RUN</code>指令会在当前镜像之上的新分层中执行任何命令，然后提交结果。产生的被提交镜像会在Dockerfile中的后续步骤中使用。</p>
<p>分层的<code>RUN</code>指令和不断产生的提交符合Docker的核心思想：提交应当是简易的，容器可以从镜像的历史中的任何一个时间点创建，这点很像代码控制。</p>
<p>执行格式避免了shell字符歧义，而且你可以不指定使用特定的shell可执行文件（bash or sh or ?）的情况下使用<code>RUN</code>指令。</p>
<p>你可以在shell格式中使用<code>SEHLL</code>命令指定使用特定的shell。</p>
<p>在shell格式中你可以使用<code>\</code>（反斜杠）来在多行中延续一条RUN指令，比如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">RUN &#x2F;bin&#x2F;bash -c &#39;source $HOME&#x2F;.bashrc; \</span></pre></td></tr><tr><td class="code"><pre><span class="line">echo $HOME&#39;</span></pre></td></tr></table></figure>
<p>等价于：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">RUN &#x2F;bin&#x2F;bash -c &#39;source $HOME&#x2F;.bashrc; echo $HOME&#39;</span></pre></td></tr></table></figure>

<blockquote>
<p><strong>注意：</strong> 要使用不同的shell，而不是’/bin/sh’，请使用在所需shell中传递的exec形式。例如：<code>RUN [&quot;/bin/bash&quot;,&quot;-c&quot;,&quot;echo hello&quot;]</code></p>
</blockquote>
<blockquote>
<p><strong>注意：</strong> exec形式作为JSON数组解析，这意味着您必须在单词之外使用双引号（”）而不是单引号（’）。</p>
</blockquote>
<blockquote>
<p><strong>注意：</strong> 与shell格式不同，exec格式不调用命令shell。这意味着正常的shell处理不会发生。例如，RUN [“echo”,”$HOME”]不会在$HOME上进行可变替换。如果你想要shell处理，那么使用shell形式或直接执行一个shell，例如：RUN [“sh”,”-c”,”echo $HOME”]。当使用exec形式并直接执行shell时，正如shell形式的情况，它是做环境变量扩展的shell，而不是docker。</p>
</blockquote>
<blockquote>
<p><strong>注意：</strong> 在JSON形式中，有必要转义反斜杠。这在Windows上特别相关，其中反斜杠是路径分隔符。因为不是有效的JSON，并且以意外的方式失败，以下行将被视为shell形式：<code>RUN [&quot;c:\windows\system32\tasklist.exe&quot;]</code>此示例的正确语法为：<code>RUN [&quot;c:\\windows\\system32\\tasklist.exe&quot;]</code></p>
</blockquote>
<p><code>RUN</code>指令的缓存不会在下一次构建期间自动失效。一条指令的缓存类似<code>RUN apt-get dist-upgrade -y</code>会在下一个次构建的时候重用。<code>RUN</code>指令的缓存可以使用<code>--no-cache</code>标志取消，比如<code>docker build --no-cache</code>。</p>
<p>在Dockerfile最佳实践中看到更多的信息。</p>
<p><code>ADD</code>指令也会使<code>RUN</code>指令的缓存失效，详情见下。</p>
<h3 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h3><p><code>CMD</code>指令有三种格式：</p>
<ul>
<li>CMD [“executable”,”param1”,”param2”]（执行格式，这也是首选的格式）</li>
<li>CMD [“param1”,”param2”]（作为ENTRYPOINT的默认参数）</li>
<li>CMD command param1 param2（shell格式）</li>
</ul>
<p>Dockerfile中只能有一条CMD命令，如果有多条，那么只有最后一条生效。</p>
<p>CMD指令的主要用意是提供一个执行容器的默认值。这些默认值可以包括一个可执行文件，或者他们可以省略可执行文件。在这种情况下你必须指定一个ENTRTPOINT指令。</p>
<blockquote>
<p><strong>注意：</strong> 如果使用CMD为ENTRYPOINT指令提供默认参数，CMD和ENTRYPOINT指令都应以JSON数组格式指定。</p>
</blockquote>
<blockquote>
<p><strong>注意：</strong> exec形式作为JSON数组解析，这意味着您必须在单词之外使用双引号（”）而不是单引号（’）。</p>
</blockquote>
<blockquote>
<p><strong>注意：</strong> 与shell表单不同，exec表单不调用命令shell。这意味着正常的shell处理不会发生。例如，<code>CMD [&quot;echo&quot;，&quot;$HOME&quot;]</code>不会在$HOME上进行可变替换。如果你想要shell处理，那么使用shell形式或直接执行一个shell，例如：<code>CMD [&quot;sh&quot;,&quot;-c&quot;,&quot;echo $HOME&quot;]</code>。当使用exec形式并直接执行shell时，正如shell形式的情况，它是做环境变量扩展的shell，而不是docker。</p>
</blockquote>
<p>当你使用shell或者exec格式的时候，CMD指令会在容器启动的时候执行你输入的命令。</p>
<p>如果你使用CMD的shell格式，那么命令会以<code>/bin/sh -c</code>的形式执行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FROM ubuntu</span></pre></td></tr><tr><td class="code"><pre><span class="line">CMD echo &quot;This is a test.&quot; | wc -</span></pre></td></tr></table></figure>

<p>如果你想执行你的命令但是不指定某个shell，你必须用JSON形式表述你的命令，而且给出一个可执行文件的完整地址。这种数组形式是CMD的首选格式。任何附加的参数必须单独表述为数组中的字符串：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FROM ubuntu</span></pre></td></tr><tr><td class="code"><pre><span class="line">CMD [&quot;&#x2F;usr&#x2F;bin&#x2F;wc&quot;,&quot;--help&quot;]</span></pre></td></tr></table></figure>

<p>如果你想要你的容器每次都运行相同的可执行文件，那你应该考虑将ENTRYPOINT指令和CMD一起使用。  </p>
<p>如果用户指定了<code>docker run</code>的参数，那么这些参数就会覆盖掉CMD中指定的命令。</p>
<blockquote>
<p><strong>注意：</strong> 不用疑惑RUN和CMD的区别。RUN其实是运行了一条指令然后提交结果；CMD不在构建阶段执行任何指令，但是为镜像准备好指令（意思是说在docker run的时候执行）。</p>
</blockquote>
<h3 id="LABEL"><a href="#LABEL" class="headerlink" title="LABEL"></a>LABEL</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LABEL &lt;key&gt;&#x3D;&lt;value&gt; &lt;key&gt;&#x3D;&lt;value&gt; &lt;key&gt;&#x3D;&lt;value&gt; ...</span></pre></td></tr></table></figure>

<p>LABEL指令添加镜像的元数据。一个LABEL就是一组键值对。想要在LABEL的值中添加空格，要像命令行中的转义那样使用引号和反斜杠，例子如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LABEL &quot;com.example.vendor&quot;&#x3D;&quot;ACME Incorporated&quot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">LABEL com.example.label-with-value&#x3D;&quot;foo&quot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">LABEL version&#x3D;&quot;1.0&quot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">LABEL description&#x3D;&quot;This text illustrates \</span></pre></td></tr><tr><td class="code"><pre><span class="line">that label-values can span multiple lines.&quot;</span></pre></td></tr></table></figure>

<p>一个镜像可以有多个标签，你可以在一行内指定多个标签。在Docker 1.10之前，这么做会减小最终镜像的大小，但是现在不再如此。你仍然可以选择在一条指令内指定多个标签，如下两个例子所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LABEL multi.label1&#x3D;&quot;value1&quot; multi.label2&#x3D;&quot;value2&quot; other&#x3D;&quot;value3&quot;</span></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LABEL multi.label1&#x3D;&quot;value1&quot; \</span></pre></td></tr><tr><td class="code"><pre><span class="line">      multi.label2&#x3D;&quot;value2&quot; \</span></pre></td></tr><tr><td class="code"><pre><span class="line">      other&#x3D;&quot;value3&quot;</span></pre></td></tr></table></figure>

<p>基础镜像或者双亲镜像（FROM中指定的镜像）中包含的标签会被你的镜像继承。如果一个标签已经存在但是有不同的值，会以最近设置的值为准，之前的会被覆盖。想要查看一个镜像的所有标签，可以使用<code>docker inspect</code>命令。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;Labels&quot;: &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &quot;com.example.vendor&quot;: &quot;ACME Incorporated&quot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &quot;com.example.label-with-value&quot;: &quot;foo&quot;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &quot;version&quot;: &quot;1.0&quot;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &quot;description&quot;: &quot;This text illustrates that label-values can span multiple lines.&quot;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &quot;multi.label1&quot;: &quot;value1&quot;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &quot;multi.label2&quot;: &quot;value2&quot;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &quot;other&quot;: &quot;value3&quot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;,</span></pre></td></tr></table></figure>

<h3 id="MAINTAINER-弃用"><a href="#MAINTAINER-弃用" class="headerlink" title="MAINTAINER(弃用)"></a>MAINTAINER(弃用)</h3><p>标注作者名，已经弃用，推荐使用LABEL代替。</p>
<h3 id="EXPOSE"><a href="#EXPOSE" class="headerlink" title="EXPOSE"></a>EXPOSE</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">EXPOSE &lt;port&gt; [&lt;port&gt;&#x2F;&lt;protocol&gt;...]</span></pre></td></tr></table></figure>

<p>EXPOSE指令提示Docker，容器会在运行时监听特定的网络端口。你可以指定端口是监听TCP还是UDP，而且如果没有指定，那么默认为TCP。</p>
<p>EXPOSE指令实际上不发布端口。它的作用是作为一个镜像构建者和容器使用者之间的文档，告知哪一个端口应当被发布。实际上想要在运行容器的时候发布端口，应当在<code>docker run</code>命令中使用<code>-p</code>参数以发布或者映射一个或者多个端口，或者用<code>-P</code>参数发布所有暴露的端口并且映射它们到高优先级（high-order）的端口上。</p>
<p>想要建立宿主机的端口重定向，你需要看文档中的using -P flag。<code>docker netword</code>命令支持在免于暴露特定端口的情况下建立容器之间的网络通信，因为容器可以通过任意的端口连接到网络。</p>
<h3 id="ENV"><a href="#ENV" class="headerlink" title="ENV"></a>ENV</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ENV &lt;key&gt; &lt;value&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">ENV &lt;key&gt;&#x3D;&lt;value&gt; ...</span></pre></td></tr></table></figure>

<p>ENV指令把环境变量的key设为value。这个值会在所有Dockerfile的后续命令中存在，而且支持上面提到的环境变量替换。</p>
<p>ENV指令有两种格式，第一种格式，<code>ENV &lt;key&gt; &lt;value&gt;</code>，会把一个单一的键设为某一值，在空格后面出现的整个字符串会被认为是值，包括空格和引号等字符。</p>
<p>第二种格式，<code>ENV &lt;key&gt;=&lt;value&gt; ...</code>，允许一次性设置多个值。需要注意第二种方式的语法中使用等号，而第一种没有使用。就像命令行转义，引号和反斜杠可以用来包含值中的空格。<br>如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ENV myName&#x3D;&quot;John Doe&quot; myDog&#x3D;Rex\ The\ Dog \</span></pre></td></tr><tr><td class="code"><pre><span class="line">    myCat&#x3D;fluffy</span></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ENV myName John Doe</span></pre></td></tr><tr><td class="code"><pre><span class="line">ENV myDog Rex The Dog</span></pre></td></tr><tr><td class="code"><pre><span class="line">ENV myCat fluffy</span></pre></td></tr></table></figure>

<p>两者作用相同，但是推荐使用第一种，因为只会产生一层缓存层。</p>
<p>ENV命令设置的环境变量会一直存在，包括容器从最终镜像运行后。你可以使用<code>docker inspect</code>查看它们的状态，也可以使用<code>docker run --env &lt;key&gt;=&lt;value&gt;</code>改变它们的状态。</p>
<blockquote>
<p><strong>注意：</strong> 环境变量的持续存留有可能产生不可预期的副作用。比如设置<code>ENV DEBIAN_FRONTEND noninteractive</code>有可能让基于Debian镜像的apt-get用户产生困惑。想要为单条命令设置一个值，使用<code>RUN &lt;key&gt;=&lt;value&gt; &lt;command&gt;</code>。</p>
</blockquote>
<h3 id="ADD"><a href="#ADD" class="headerlink" title="ADD"></a>ADD</h3><p>ADD有两种格式：</p>
<ul>
<li><code>ADD [--chown=&lt;user&gt;:&lt;group&gt;] &lt;src&gt;... &lt;dest&gt;</code></li>
<li><code>ADD [--chown=&lt;user&gt;:&lt;group&gt;] [&quot;&lt;src&gt;&quot;,... &quot;&lt;dest&gt;&quot;]</code>(包含空格的路径需要使用这种格式)</li>
</ul>
<blockquote>
<p><strong>注意：</strong> <code>--chown</code>特性只支持构建Linux容器的Dockerfile，而且不会在Windows容器中生效。由于用户和用户组概念不能再Linux和Windows之间转化，所以使用<code>/etc/passwd</code>和<code>/etc/group</code>把用户和用户组转化为ID这种特性只在基于Linux的容器下可行。</p>
</blockquote>
<p>ADD指令从<code>&lt;src&gt;</code>复制新的文件、路径或者远程文件URL到镜像的文件系统中的<code>&lt;dest&gt;</code>位置。</p>
<p>可以指定多个<code>&lt;src&gt;</code>资源，但是如果他们是文件或者目录的话，他们的路径应该是相对于构建上下文的。</p>
<p>每一个<code>&lt;src&gt;</code>可以包括通配符，适配规则将按照Go语言的<a href="https://golang.org/pkg/path/filepath/#Match" target="_blank" rel="noopener">filepath.Match</a>规则。比如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ADD hom* &#x2F;mydir&#x2F;        # 添加所有文件名以 &quot;hom&quot; 开头的文件</span></pre></td></tr><tr><td class="code"><pre><span class="line">ADD hom?.txt &#x2F;mydir&#x2F;    # ? 可以替代一个单个字符，比如， &quot;home.txt&quot;</span></pre></td></tr></table></figure>

<p><code>&lt;dest&gt;</code>是一个绝对路径，或者相对于<code>WORKDIR</code>的路径，在其中，资源将被复制到目标容器。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ADD test relativeDir&#x2F;          # adds &quot;test&quot; to &#96;WORKDIR&#96;&#x2F;relativeDir&#x2F;</span></pre></td></tr><tr><td class="code"><pre><span class="line">ADD test &#x2F;absoluteDir&#x2F;         # adds &quot;test&quot; to &#x2F;absoluteDir&#x2F;</span></pre></td></tr></table></figure>

<p>当添加一个包含特殊符号(比如<code>[</code>和<code>]</code>)的文件或者目录，你需要对这些字符进行符合Golang规则的转义，防止它们被视为一个统配规则。比如，想要添加一个文件名为<code>arr[0].txt</code>的文件，你需要：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ADD arr[[]0].txt &#x2F;mydir&#x2F;    # 复制一个名为 &quot;arr[0].txt&quot; 的文件到 &#x2F;mydir&#x2F;</span></pre></td></tr></table></figure>

<p>一个新的文件或者目录被创造的时候，它的UID和GID将为0，除非用选项<code>--chown</code>指定了用户和用户组或者UID/GID组合请求指定的内容添加所有权。<code>--chown</code>选线的格式允许用户名或者用户组名以字符串或者整形形式的UID或GID组合。提供一个不带用户组的用户名或者不带GID的UID的话，会使用同样的UID作为GID。如果提供了一个用户名或者用户组名，容器的根目录文件系统<code>/etc/passwd</code>和<code>/etc/group</code>文件会被使用，来执行从名称到UID或GID的转换。下列栗子展示了合法的<code>--chown</code>选项的定义：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ADD --chown&#x3D;55:mygroup files* &#x2F;somedir&#x2F;</span></pre></td></tr><tr><td class="code"><pre><span class="line">ADD --chown&#x3D;bin files* &#x2F;somedir&#x2F;</span></pre></td></tr><tr><td class="code"><pre><span class="line">ADD --chown&#x3D;1 files* &#x2F;somedir&#x2F;</span></pre></td></tr><tr><td class="code"><pre><span class="line">ADD --chown&#x3D;10:11 files* &#x2F;somedir&#x2F;</span></pre></td></tr></table></figure>

<p>如果容器的根目录文件系统不包含<code>/etc/passwd</code>或者<code>/etc/group</code>文件并且用户名和用户组名都没有使用<code>--chown</code>选项，那么进行ADD操作的时候构建将会失败。使用数字的IDs不需要查找，而且对根文件系统的内容没有要求。</p>
<p>在<code>&lt;src&gt;</code>是远程文件URL的情况下，目标将具有600的权限。如果正在检索的远程文件具有HTTP Last-Modified标头，则来自该标头的时间戳将用于设置目的地上的mtime文件。然而，像在ADD期间处理的任何其它文件一样，在决定文件是否被更改或者缓存是否被更新的时候，mtime不会被考虑进去。</p>
<blockquote>
<p><strong>注意：</strong> 如果通过传递一个Dockerfile通过STDIN（<code>docker build - &lt;somefile</code>）构建，没有构建上下文，所以Dockerfile只能包含一个基于URL的ADD指令。您还可以通过STDIN传递压缩归档文件：（<code>docker build - &lt;archive.tar.gz</code>），归档根目录下的Dockerfile和归档的其余部分将在构建的上下文中使用。</p>
</blockquote>
<blockquote>
<p><strong>注意：</strong> 如果您的URL文件使用身份验证保护，则您需要使用<code>RUN wget</code>，<code>RUN curl</code>或从容器内使用其他工具，因为ADD指令不支持身份验证。</p>
</blockquote>
<blockquote>
<p><strong>注意：</strong> 如果<code>&lt;src&gt;</code>的内容已更改，第一个遇到的ADD指令将使来自Dockerfile的所有后续指令的高速缓存无效。这包括使用于RUN指令的高速缓存无效。有关详细信息，请参阅<a href="https://docs.docker.com/engine/userguide/eng-image/dockerfile_best-practices/#/build-cache" target="_blank" rel="noopener">Dockerfile最佳实践指南</a>。</p>
</blockquote>
<p>ADD遵循以下规则：</p>
<ul>
<li><code>&lt;src&gt;</code>路径必须在构建的上下文中;你不能<code>ADD ../something /something</code>，因为docker构建的第一步是发送上下文目录（和子目录）到docker守护进程。如果<code>&lt;src&gt;</code>是URL并且<code>&lt;dest&gt;</code>不以尾部斜杠结尾，则从URL下载文件并将其复制到<code>&lt;dest&gt;</code>。</li>
<li>如果<code>&lt;src&gt;</code>是URL并且<code>&lt;dest&gt;</code>以尾部斜杠结尾，则从URL中推断文件名，并将文件下载到<code>&lt;dest&gt;/&lt;filename&gt;</code>。例如，<code>ADD http://example.com/foobar /</code>会创建文件<code>/foobar</code>。网址必须有一个非平凡的路径，以便在这种情况下可以发现一个适当的文件名（<code>http://example.com</code>不会工作）。</li>
<li>如果<code>&lt;src&gt;</code>是目录，则复制目录的整个内容，包括文件系统元数据。</li>
</ul>
<blockquote>
<p><strong>注意：</strong> 目录本身不被复制，只是其内容。</p>
</blockquote>
<ul>
<li>如果<code>&lt;src&gt;</code>是识别的压缩格式（identity，gzip，bzip2或xz）的本地tar存档，则将其解包为目录。来自远程URL的资源不会解压缩。当目录被复制或解压缩时，它具有与<code>tar -x</code>相同的行为：结果是以下的联合：<ol>
<li>无论目的地路径上存在什么，而且</li>
<li>原目标树的内容，冲突以逐个文件为基础解析为“2.”。<blockquote>
<p><strong>注意：</strong> 文件是否被识别为识别的压缩格式，仅基于文件的内容，而不是文件的名称。例如，如果一个空文件以.tar.gz结尾，则不会被识别为压缩文件，并且不会生成任何解压缩错误消息，而是将该文件简单地复制到目的地。</p>
</blockquote>
</li>
</ol>
</li>
<li>如果<code>&lt;src&gt;</code>是任何其他类型的文件，它会与其元数据一起单独复制。在这种情况下，如果<code>&lt;dest&gt;</code>以尾部斜杠<code>/</code>结尾，它将被认为是一个目录，并且<code>&lt;src&gt;</code>的内容将被写在<code>&lt;dest&gt;/base(&lt;src&gt;)</code>。</li>
<li>如果直接或由于使用通配符指定了多个<code>&lt;src&gt;</code>资源，则<code>&lt;dest&gt;</code>必须是目录，并且必须以斜杠<code>/</code>结尾。</li>
<li>如果<code>&lt;dest&gt;</code>不以尾部斜杠结尾，它将被视为常规文件，<code>&lt;src&gt;</code>的内容将写在<code>&lt;dest&gt;</code>。</li>
<li>如果<code>&lt;dest&gt;</code>不存在，则会与其路径中的所有缺少的目录一起创建。</li>
</ul>
<h3 id="COPY"><a href="#COPY" class="headerlink" title="COPY"></a>COPY</h3><p>COPY有两种格式：</p>
<ul>
<li><code>COPY [--chown=&lt;user&gt;:&lt;group&gt;] &lt;src&gt;... &lt;dest&gt;</code></li>
<li><code>COPY [--chown=&lt;user&gt;:&lt;group&gt;] [&quot;&lt;src&gt;&quot;,... &quot;&lt;dest&gt;&quot;]</code>(带空格的路径需要使用这种格式)</li>
</ul>
<blockquote>
<p><strong>注意：</strong> <code>--chown</code>特性只支持构建Linux容器的Dockerfile，而且不会在Windows容器中生效。由于用户和用户组概念不能再Linux和Windows之间转化，所以使用<code>/etc/passwd</code>和<code>/etc/group</code>把用户和用户组转化为ID这种特性只在基于Linux的容器下可行。</p>
</blockquote>
<p>COPY指令从<code>&lt;src&gt;</code>复制新的文件、路径或者远程文件URL到容器的文件系统中的<code>&lt;dest&gt;</code>位置。</p>
<p>可以指定多个<code>&lt;src&gt;</code>资源，但是如果他们是文件或者目录的话，他们的路径应该是相对于构建上下文的。</p>
<p>每一个<code>&lt;src&gt;</code>可以包括通配符，适配规则将按照Go语言的<a href="https://golang.org/pkg/path/filepath/#Match" target="_blank" rel="noopener">filepath.Match</a>规则。比如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">COPY hom* &#x2F;mydir&#x2F;        # 添加所有文件名以 &quot;hom&quot; 开头的文件</span></pre></td></tr><tr><td class="code"><pre><span class="line">COPY hom?.txt &#x2F;mydir&#x2F;    # ? 可以替代一个单个字符，比如， &quot;home.txt&quot;</span></pre></td></tr></table></figure>

<p><code>&lt;dest&gt;</code>是一个绝对路径，或者相对于<code>WORKDIR</code>的路径，在其中，资源将被复制到目标容器。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">COPY test relativeDir&#x2F;          # adds &quot;test&quot; to &#96;WORKDIR&#96;&#x2F;relativeDir&#x2F;</span></pre></td></tr><tr><td class="code"><pre><span class="line">COPY test &#x2F;absoluteDir&#x2F;         # adds &quot;test&quot; to &#x2F;absoluteDir&#x2F;</span></pre></td></tr></table></figure>

<p>当添加一个包含特殊符号(比如<code>[</code>和<code>]</code>)的文件或者目录，你需要对这些字符进行符合Golang规则的转义，防止它们被视为一个统配规则。比如，想要添加一个文件名为<code>arr[0].txt</code>的文件，你需要：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">COPY arr[[]0].txt &#x2F;mydir&#x2F;    # 复制一个名为 &quot;arr[0].txt&quot; 的文件到 &#x2F;mydir&#x2F;</span></pre></td></tr></table></figure>

<p>一个新的文件或者目录被创造的时候，它的UID和GID将为0，除非用选项<code>--chown</code>指定了用户和用户组或者UID/GID组合请求指定的内容添加所有权。<code>--chown</code>选线的格式允许用户名或者用户组名以字符串或者整形形式的UID或GID组合。提供一个不带用户组的用户名或者不带GID的UID的话，会使用同样的UID作为GID。如果提供了一个用户名或者用户组名，容器的根目录文件系统<code>/etc/passwd</code>和<code>/etc/group</code>文件会被使用，来执行从名称到UID或GID的转换。下列栗子展示了合法的<code>--chown</code>选项的定义：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">COPY --chown&#x3D;55:mygroup files* &#x2F;somedir&#x2F;</span></pre></td></tr><tr><td class="code"><pre><span class="line">COPY --chown&#x3D;bin files* &#x2F;somedir&#x2F;</span></pre></td></tr><tr><td class="code"><pre><span class="line">COPY --chown&#x3D;1 files* &#x2F;somedir&#x2F;</span></pre></td></tr><tr><td class="code"><pre><span class="line">COPY --chown&#x3D;10:11 files* &#x2F;somedir&#x2F;</span></pre></td></tr></table></figure>

<p>如果容器的根目录文件系统不包含<code>/etc/passwd</code>或者<code>/etc/group</code>文件并且用户名和用户组名都没有使用<code>--chown</code>选项，那么进行COPY操作的时候构建将会失败。使用数字的IDs不需要查找，而且对根文件系统的内容没有要求。</p>
<blockquote>
<p><strong>注意：</strong> 如果你构建的时候使用STDIN(<code>docker build - &lt; somefile</code>)，那么就没有构建上下文，所以COPY不能使用。</p>
</blockquote>
<p>COPY可以选择添加<code>--from=&lt;name|index&gt;</code>选项，用来设置源目标位置为前一个构建阶段（用<code>FROM .. AS &lt;name&gt;创建</code>）从而用来代替用户发送的构建上下文。这个选项会接受一个数字索引，这个索引是从FROM指令开始所有之前的构建阶段分配的。</p>
<p>COPY遵循以下规则：</p>
<ul>
<li><code>&lt;src&gt;</code>路径必须在构建的上下文中;你不能<code>COPY ../something /something</code>，因为docker构建的第一步是发送上下文目录（和子目录）到docker守护进程。</li>
<li>如果<code>&lt;src&gt;</code>是目录，则复制目录的整个内容，包括文件系统元数据。</li>
</ul>
<blockquote>
<p><strong>注意：</strong> 目录本身不被复制，只是其内容。</p>
</blockquote>
<ul>
<li>如果<code>&lt;src&gt;</code>是任何其他类型的文件，它会与其元数据一起单独复制。在这种情况下，如果<code>&lt;dest&gt;</code>以尾部斜杠<code>/</code>结尾，它将被认为是一个目录，并且<code>&lt;src&gt;</code>的内容将被写在<code>&lt;dest&gt;/base(&lt;src&gt;)</code>。</li>
<li>如果直接或由于使用通配符指定了多个<code>&lt;src&gt;</code>资源，则<code>&lt;dest&gt;</code>必须是目录，并且必须以斜杠<code>/</code>结尾。</li>
<li>如果<code>&lt;dest&gt;</code>不以尾部斜杠结尾，它将被视为常规文件，<code>&lt;src&gt;</code>的内容将写在<code>&lt;dest&gt;</code>。</li>
<li>如果<code>&lt;dest&gt;</code>不存在，则会与其路径中的所有缺少的目录一起创建。</li>
</ul>
<h3 id="ENTRYPOPTINT"><a href="#ENTRYPOPTINT" class="headerlink" title="ENTRYPOPTINT"></a>ENTRYPOPTINT</h3><p>ENTRYPOINT有两种形式：</p>
<ul>
<li><code>ENTRYPOINT [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]</code>(exec形式，推荐)</li>
<li><code>ENTRYPOINT command param1 param2</code>(shell形式)</li>
</ul>
<p>一个ENTRYPOINT允许你配置一个将作为可执行文件的容器。</p>
<p>比如，下例将会启动一个默认内容的nginx，监听80端口：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -i -t --rm -p 80:80 nginx</span></pre></td></tr></table></figure>

<p><code>docker run &lt;image&gt;</code>的命令行参数将会在添加在exec格式的ENTRYPOINT的所有参数后面，而且会覆盖所有CMD指令所指定的参数。这允许参数通过，进入到入口点。比如<code>docker run &lt;image&gt; -d</code>会传递<code>-d</code>参数到入口点。你可以通过使用<code>docker run --entrypoint</code>重写ENTRYPOINT指令。</p>
<p>shell格式阻止使用任何CMD或者run命令行参数，但是有缺点就是你的ENTRYPOINT将会从作为<code>/bin/bash -c</code>的子命令开始，这就不会传递信号了。这意味着可执行文件不会成为容器的<code>PID 1</code>，而且不会接受Unix信号，所以你的可执行文件不会收到<code>docker stop &lt;container&gt;</code>的<code>SIGTERM</code>。</p>
<p>只有Dockerfile中最后的ENTRYPOINT指令会生效。</p>
<h4 id="Exec格式的ENTRYPOINT示例"><a href="#Exec格式的ENTRYPOINT示例" class="headerlink" title="Exec格式的ENTRYPOINT示例"></a>Exec格式的ENTRYPOINT示例</h4><p>你可以使用exec形式的ENTRYPOINT用于设置相当稳定的默认命令行和参数，然后使用任意形式的CMD指令设置额外的、可能被修改的默认命令。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FROM ubuntu</span></pre></td></tr><tr><td class="code"><pre><span class="line">ENTRYPOINT [&quot;top&quot;, &quot;-b&quot;]</span></pre></td></tr><tr><td class="code"><pre><span class="line">CMD [&quot;-c&quot;]</span></pre></td></tr></table></figure>

<p>当你运行一个容器，你可以看到<code>top</code>是唯一的进程：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker run -it --rm --name test  top -H</span></pre></td></tr><tr><td class="code"><pre><span class="line">top - 08:25:00 up  7:27,  0 users,  load average: 0.00, 0.01, 0.05</span></pre></td></tr><tr><td class="code"><pre><span class="line">Threads:   1 total,   1 running,   0 sleeping,   0 stopped,   0 zombie</span></pre></td></tr><tr><td class="code"><pre><span class="line">%Cpu(s):  0.1 us,  0.1 sy,  0.0 ni, 99.7 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st</span></pre></td></tr><tr><td class="code"><pre><span class="line">KiB Mem:   2056668 total,  1616832 used,   439836 free,    99352 buffers</span></pre></td></tr><tr><td class="code"><pre><span class="line">KiB Swap:  1441840 total,        0 used,  1441840 free.  1324440 cached Mem</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  PID USER      PR  NI    VIRT    RES    SHR S %CPU %MEM     TIME+ COMMAND</span></pre></td></tr><tr><td class="code"><pre><span class="line">    1 root      20   0   19744   2336   2080 R  0.0  0.1   0:00.04 top</span></pre></td></tr></table></figure>

<p>想要检查更多的结果，可以使用<code>docker exec</code>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker exec -it test ps aux</span></pre></td></tr><tr><td class="code"><pre><span class="line">USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND</span></pre></td></tr><tr><td class="code"><pre><span class="line">root         1  2.6  0.1  19752  2352 ?        Ss+  08:24   0:00 top -b -H</span></pre></td></tr><tr><td class="code"><pre><span class="line">root         7  0.0  0.1  15572  2164 ?        R+   08:25   0:00 ps aux</span></pre></td></tr></table></figure>

<p>而且你可以优雅的使用<code>docker stop test</code>请求关闭<code>top</code>。</p>
<p>下例Dockerfile展示了使用ENTRYPOINT在前台运行Apache（作为<code>PID 1</code>）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FROM debian:stable</span></pre></td></tr><tr><td class="code"><pre><span class="line">RUN apt-get update &amp;&amp; apt-get install -y --force-yes apache2</span></pre></td></tr><tr><td class="code"><pre><span class="line">EXPOSE 80 443</span></pre></td></tr><tr><td class="code"><pre><span class="line">VOLUME [&quot;&#x2F;var&#x2F;www&quot;, &quot;&#x2F;var&#x2F;log&#x2F;apache2&quot;, &quot;&#x2F;etc&#x2F;apache2&quot;]</span></pre></td></tr><tr><td class="code"><pre><span class="line">ENTRYPOINT [&quot;&#x2F;usr&#x2F;sbin&#x2F;apache2ctl&quot;, &quot;-D&quot;, &quot;FOREGROUND&quot;]</span></pre></td></tr></table></figure>

<p>如果你需要写一个开始脚本作为单独可执行文件，你可以保证最终的可执行文件通过<code>exec</code>和<code>gosu</code>命令接受到Unix信号：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;usr&#x2F;bin&#x2F;env bash</span></pre></td></tr><tr><td class="code"><pre><span class="line">set -e</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">if [ &quot;$1&quot; &#x3D; &#39;postgres&#39; ]; then</span></pre></td></tr><tr><td class="code"><pre><span class="line">    chown -R postgres &quot;$PGDATA&quot;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    if [ -z &quot;$(ls -A &quot;$PGDATA&quot;)&quot; ]; then</span></pre></td></tr><tr><td class="code"><pre><span class="line">        gosu postgres initdb</span></pre></td></tr><tr><td class="code"><pre><span class="line">    fi</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    exec gosu postgres &quot;$@&quot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">fi</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">exec &quot;$@&quot;</span></pre></td></tr></table></figure>

<p>最终，如果你需要在关闭的时候做一些额外的清理工作（或是与其他容器进行通讯），或者联合多个可执行文件，你可能需要确认ENTRYPOINT脚本能够接受到Unix信号并且传递他们，然后做更多工作：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;sh</span></pre></td></tr><tr><td class="code"><pre><span class="line"># Note: I&#39;ve written this using sh so it works in the busybox container too</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"># USE the trap if you need to also do manual cleanup after the service is stopped,</span></pre></td></tr><tr><td class="code"><pre><span class="line">#     or need to start multiple services in the one container</span></pre></td></tr><tr><td class="code"><pre><span class="line">trap &quot;echo TRAPed signal&quot; HUP INT QUIT TERM</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"># start service in background here</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;usr&#x2F;sbin&#x2F;apachectl start</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">echo &quot;[hit enter key to exit] or run &#39;docker stop &lt;container&gt;&#39;&quot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">read</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"># stop service and clean up here</span></pre></td></tr><tr><td class="code"><pre><span class="line">echo &quot;stopping apache&quot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;usr&#x2F;sbin&#x2F;apachectl stop</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">echo &quot;exited $0&quot;</span></pre></td></tr></table></figure>

<p>如果你用<code>docker run -it --rm -p 80:80 --name test apache</code>命令运行这个镜像，你可以通过<code>docker exec</code>检查容器的进程，或者用<code>docker top</code>，然后请求脚本来停止Apache：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker exec -it test ps aux</span></pre></td></tr><tr><td class="code"><pre><span class="line">USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND</span></pre></td></tr><tr><td class="code"><pre><span class="line">root         1  0.1  0.0   4448   692 ?        Ss+  00:42   0:00 &#x2F;bin&#x2F;sh &#x2F;run.sh 123 cmd cmd2</span></pre></td></tr><tr><td class="code"><pre><span class="line">root        19  0.0  0.2  71304  4440 ?        Ss   00:42   0:00 &#x2F;usr&#x2F;sbin&#x2F;apache2 -k start</span></pre></td></tr><tr><td class="code"><pre><span class="line">www-data    20  0.2  0.2 360468  6004 ?        Sl   00:42   0:00 &#x2F;usr&#x2F;sbin&#x2F;apache2 -k start</span></pre></td></tr><tr><td class="code"><pre><span class="line">www-data    21  0.2  0.2 360468  6000 ?        Sl   00:42   0:00 &#x2F;usr&#x2F;sbin&#x2F;apache2 -k start</span></pre></td></tr><tr><td class="code"><pre><span class="line">root        81  0.0  0.1  15572  2140 ?        R+   00:44   0:00 ps aux</span></pre></td></tr><tr><td class="code"><pre><span class="line">$ docker top test</span></pre></td></tr><tr><td class="code"><pre><span class="line">PID                 USER                COMMAND</span></pre></td></tr><tr><td class="code"><pre><span class="line">10035               root                &#123;run.sh&#125; &#x2F;bin&#x2F;sh &#x2F;run.sh 123 cmd cmd2</span></pre></td></tr><tr><td class="code"><pre><span class="line">10054               root                &#x2F;usr&#x2F;sbin&#x2F;apache2 -k start</span></pre></td></tr><tr><td class="code"><pre><span class="line">10055               33                  &#x2F;usr&#x2F;sbin&#x2F;apache2 -k start</span></pre></td></tr><tr><td class="code"><pre><span class="line">10056               33                  &#x2F;usr&#x2F;sbin&#x2F;apache2 -k start</span></pre></td></tr><tr><td class="code"><pre><span class="line">$ &#x2F;usr&#x2F;bin&#x2F;time docker stop test</span></pre></td></tr><tr><td class="code"><pre><span class="line">test</span></pre></td></tr><tr><td class="code"><pre><span class="line">real	0m 0.27s</span></pre></td></tr><tr><td class="code"><pre><span class="line">user	0m 0.03s</span></pre></td></tr><tr><td class="code"><pre><span class="line">sys	0m 0.03s</span></pre></td></tr></table></figure>

<blockquote>
<p><strong>注意：</strong> 你可以使用<code>--entrypoint</code>来重写ENTRYPOINT，但是这只会设置二进制到exec(不会使用<code>sh -c</code>)。</p>
</blockquote>
<blockquote>
<p><strong>注意：</strong> exec格式是解析成JSON数组的格式，这意味着你必须使用双引号(“)包围文字，而不是用单引号(‘)。</p>
</blockquote>
<blockquote>
<p><strong>注意：</strong> 与shell格式不同，exec格式不会调用shell命令，这意味着shell处理不会进行。比如，<code>ENTRYPOINT [&quot;echo&quot;,&quot;$HOME&quot;]</code>不会对<code>$HOME</code>进行变量替换。如果你想要使用shell处理，那么就用shell格式或者直接执行shell，比如：<code>ENTRYPOINT [ &quot;sh&quot;, &quot;-c&quot;, &quot;echo $HOME&quot; ]</code>。当使用exec形式并直接执行shell时，正如shell形式的情况，它是做环境变量扩展的shell，而不是docker。</p>
</blockquote>
<h4 id="Shell形式ENTRYPOINT的示例"><a href="#Shell形式ENTRYPOINT的示例" class="headerlink" title="Shell形式ENTRYPOINT的示例"></a>Shell形式ENTRYPOINT的示例</h4><p>您可以为ENTRYPOINT指定一个纯字符串，它将在<code>/bin/sh -c</code>中执行。这中形式将使用shell处理来替换shell环境变量，并且将忽略任何CMD或<code>docker run</code>命令行参数。要确保<code>docker stop</code>将正确地发出任何长时间运行的ENTRYPOINT可执行文件，您需要记住用exec启动它：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FROM ubuntu</span></pre></td></tr><tr><td class="code"><pre><span class="line">ENTRYPOINT exec top -b</span></pre></td></tr></table></figure>

<p>当你运行这个景象，你会看到单独一个<code>PID 1</code>进程：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker run -it --rm --name test top</span></pre></td></tr><tr><td class="code"><pre><span class="line">Mem: 1704520K used, 352148K free, 0K shrd, 0K buff, 140368121167873K cached</span></pre></td></tr><tr><td class="code"><pre><span class="line">CPU:   5% usr   0% sys   0% nic  94% idle   0% io   0% irq   0% sirq</span></pre></td></tr><tr><td class="code"><pre><span class="line">Load average: 0.08 0.03 0.05 2&#x2F;98 6</span></pre></td></tr><tr><td class="code"><pre><span class="line">  PID  PPID USER     STAT   VSZ %VSZ %CPU COMMAND</span></pre></td></tr><tr><td class="code"><pre><span class="line">    1     0 root     R     3164   0%   0% top -b</span></pre></td></tr></table></figure>

<p>这些会在<code>docker stop</code>的时候干净利落的退出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ &#x2F;usr&#x2F;bin&#x2F;time docker stop test</span></pre></td></tr><tr><td class="code"><pre><span class="line">test</span></pre></td></tr><tr><td class="code"><pre><span class="line">real	0m 0.20s</span></pre></td></tr><tr><td class="code"><pre><span class="line">user	0m 0.02s</span></pre></td></tr><tr><td class="code"><pre><span class="line">sys	0m 0.04s</span></pre></td></tr></table></figure>

<p>如果你忘记在ENTRYPOINT的开头加上<code>exec</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FROM ubuntu</span></pre></td></tr><tr><td class="code"><pre><span class="line">ENTRYPOINT top -b</span></pre></td></tr><tr><td class="code"><pre><span class="line">CMD --ignored-param1</span></pre></td></tr></table></figure>

<p>你可以运行它（为了下一步的运行，需要给它个名字）:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker run -it --name test top --ignored-param2</span></pre></td></tr><tr><td class="code"><pre><span class="line">Mem: 1704184K used, 352484K free, 0K shrd, 0K buff, 140621524238337K cached</span></pre></td></tr><tr><td class="code"><pre><span class="line">CPU:   9% usr   2% sys   0% nic  88% idle   0% io   0% irq   0% sirq</span></pre></td></tr><tr><td class="code"><pre><span class="line">Load average: 0.01 0.02 0.05 2&#x2F;101 7</span></pre></td></tr><tr><td class="code"><pre><span class="line">  PID  PPID USER     STAT   VSZ %VSZ %CPU COMMAND</span></pre></td></tr><tr><td class="code"><pre><span class="line">    1     0 root     S     3168   0%   0% &#x2F;bin&#x2F;sh -c top -b cmd cmd2</span></pre></td></tr><tr><td class="code"><pre><span class="line">    7     1 root     R     3164   0%   0% top -b</span></pre></td></tr></table></figure>

<p>你可以看到<code>top</code>的输出信息中指定的ENTRYPOINT不是<code>PID 1</code>。</p>
<p>如果你运行了<code>docker stop test</code>，容器不会退出的很干净，<code>stop</code>命令会在超时之后强制发送一个<code>SIGKILL</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker exec -it test ps aux</span></pre></td></tr><tr><td class="code"><pre><span class="line">PID   USER     COMMAND</span></pre></td></tr><tr><td class="code"><pre><span class="line">    1 root     &#x2F;bin&#x2F;sh -c top -b cmd cmd2</span></pre></td></tr><tr><td class="code"><pre><span class="line">    7 root     top -b</span></pre></td></tr><tr><td class="code"><pre><span class="line">    8 root     ps aux</span></pre></td></tr><tr><td class="code"><pre><span class="line">$ &#x2F;usr&#x2F;bin&#x2F;time docker stop test</span></pre></td></tr><tr><td class="code"><pre><span class="line">test</span></pre></td></tr><tr><td class="code"><pre><span class="line">real	0m 10.19s</span></pre></td></tr><tr><td class="code"><pre><span class="line">user	0m 0.04s</span></pre></td></tr><tr><td class="code"><pre><span class="line">sys	0m 0.03s</span></pre></td></tr></table></figure>

<h4 id="理解CMD和ENTRYPOINT是如何交互的"><a href="#理解CMD和ENTRYPOINT是如何交互的" class="headerlink" title="理解CMD和ENTRYPOINT是如何交互的"></a>理解CMD和ENTRYPOINT是如何交互的</h4><p>CMD和ENTRYPOINT指令都定义了容器运行的时候命令是如何执行的，下面有几条规则描述了他们的关系：</p>
<ol>
<li>Dockerfile应当是定至少一条CMD或者ENTRYPOINT命令。</li>
<li>使用容器作为一个可执行文件的时候，ENTRYPOINT应当被定义。</li>
<li>CMD应该作为一种为ENTRYPOINT命令定义默认参数的方法，或者作为容器中执行临时命令的方式。</li>
<li>在使用交互式参数运行容器的时候，CMD将会被重写。</li>
</ol>
<p>下表展示了不同的ENTRYPOINT/CMD组合是如何执行的：<br>||No ENTRYPOINT|ENTRYPOINT exec_entry p1_entry|ENTRYPOINT [“exec_entry”, “p1_entry”]<br>-|-|-|-<br>No CMD|error,not allowed|/bin/sh -c exec_entry p1_entry|exec_entry p1_entry<br>CMD [“exec_cmd”, “p1_cmd”]|exec_cmd p1_cmd|/bin/sh -c exec_entry p1_entry|exec_entry p1_entry exec_cmd p1_cmd<br>CMD [“p1_cmd”, “p2_cmd”]|p1_cmd p2_cmd|/bin/sh -c exec_entry p1_entry|exec_entry p1_entry p1_cmd p2_cmd<br>CMD exec_cmd p1_cmd|/bin/sh -c exec_cmd p1_cmd|/bin/sh -c exec_entry p1_entry|exec_entry p1_entry /bin/sh -c exec_cmd p1_cmd</p>
<h3 id="VOLUME"><a href="#VOLUME" class="headerlink" title="VOLUME"></a>VOLUME</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">VOLUME [&quot;&#x2F;data&quot;]</span></pre></td></tr></table></figure>

<p>VOLUME指令创建了一个挂载点，并且指定了一个名字，然后标记这个挂载点来承载来自原生宿主机或者其他容器的额外被挂载数据卷。它的值可以使一个JSON数组，<code>VOLUME [&quot;/var/log/&quot;]</code>，或者一个普通的有多个参数的字符串，比如<code>VOLUME /var/log</code>或<code>VOLUME /var/log /var/db</code>。想看更多的信息/举例和通过Docker客户端进行挂载的指令，可以参考<a href="https://docs.docker.com/engine/admin/volumes/volumes/" target="_blank" rel="noopener">Share Directories via Volumes</a>文档。</p>
<p><code>docker run</code>命令用基础映像中指定位置存在的任何数据初始化新创建的卷。比如，思考下例Dockerfile片段：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FROM ubuntu</span></pre></td></tr><tr><td class="code"><pre><span class="line">RUN mkdir &#x2F;myvol</span></pre></td></tr><tr><td class="code"><pre><span class="line">RUN echo &quot;hello world&quot; &gt; &#x2F;myvol&#x2F;greeting</span></pre></td></tr><tr><td class="code"><pre><span class="line">VOLUME &#x2F;myvol</span></pre></td></tr></table></figure>

<p>这个Dockerfile产生了一个镜像使<code>docker run</code>创建了一个新的在<code>/myvol</code>的挂载点而且复制<code>greeting</code>文件到新创建的数据卷上。</p>
<h4 id="注意指定数据卷"><a href="#注意指定数据卷" class="headerlink" title="注意指定数据卷"></a>注意指定数据卷</h4><p>记住下列关于Dockerfile中关于数据卷的内容：</p>
<ul>
<li>基于Windows的容器的数据卷：当你使用基于Windows的容器的时候，容器的数据卷的目标地址必须是下列之一：<ul>
<li>一个不存在的或者是空的目录</li>
<li>除了<code>C:</code>的驱动</li>
</ul>
</li>
<li>改变Dockerfile内的数据卷：如果任何构建步骤在被声明之前修改了数据卷内的数据，那么这些改变将被抛弃。</li>
<li>JSON格式化：这个列表会被解析为一个JSON数组，所以你必须用双引号(“)包含字符，而不是用单引号(“)。</li>
<li>宿主目录是在docker运行时声明：宿主路径(挂载点)，源于它自身的特性，依赖于宿主。这是为了保护镜像的可移植性，因为一个指定的宿主路径不能保证在所有主机上可得。基于这个原因，你不能在Dockerfile中挂载主机目录。VOLUMN指令不支持制定一个<code>host-dir</code>参数。你必须在创建或者运行容器的时候指定一个挂载点。</li>
</ul>
<h3 id="USER"><a href="#USER" class="headerlink" title="USER"></a>USER</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">USER &lt;user&gt;[:&lt;group&gt;] or</span></pre></td></tr><tr><td class="code"><pre><span class="line">USER &lt;UID&gt;[:&lt;GID&gt;]</span></pre></td></tr></table></figure>

<p>USER指令在使用CMD、RUN或者ENTRYPOINT命令启动一个镜像的时候，设置用户名(或者UID)并且可选择指定用户组(或者GID)。</p>
<blockquote>
<p><strong>注意：</strong> 当一个用户没有一个首选用户组的时候，镜像（或者下一个指令）将会用<code>root</code>用户组来运行。</p>
</blockquote>
<blockquote>
<p>在Windows下，必须先创建用户，如果不是內建用户的情况。这可以通过作为Dockerfile的一部分调用的net user命令来完成。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FROM microsoft&#x2F;windowsservercore</span></pre></td></tr><tr><td class="code"><pre><span class="line"># Create Windows user in the container</span></pre></td></tr><tr><td class="code"><pre><span class="line">RUN net user &#x2F;add patrick</span></pre></td></tr><tr><td class="code"><pre><span class="line"># Set it for subsequent commands</span></pre></td></tr><tr><td class="code"><pre><span class="line">USER patrick</span></pre></td></tr></table></figure>
<h3 id="WORKDIR"><a href="#WORKDIR" class="headerlink" title="WORKDIR"></a>WORKDIR</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">WORKDIR &#x2F;path&#x2F;to&#x2F;workdir</span></pre></td></tr></table></figure>

<p>WORKDIR指令为Dockerfile中后续的RUN、CMD、ENTRYPOINT、COPY和ADD指令设置工作路径。如果WORKDIR不存在，那么即便没使用Dockerfile中的任何指令，也会被创建。</p>
<p>WORKDIR指令会在Dockerfile中被多次使用。如果提供了一个相关的路径，那么它就会与前面的WORKDIR指令的路径相关联。比如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">WORKDIR &#x2F;a</span></pre></td></tr><tr><td class="code"><pre><span class="line">WORKDIR b</span></pre></td></tr><tr><td class="code"><pre><span class="line">WORKDIR c</span></pre></td></tr><tr><td class="code"><pre><span class="line">RUN pwd</span></pre></td></tr></table></figure>

<p>最终<code>pwd</code>命令的输出结果会是<code>/a/b/c</code>。</p>
<p>WORKDIR指令可以处理之前使用ENV命令设置的环境变量。你可以只使用Dockerfile中明确设置的环境变量。比如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ENV DIRPATH &#x2F;path</span></pre></td></tr><tr><td class="code"><pre><span class="line">WORKDIR $DIRPATH&#x2F;$DIRNAME</span></pre></td></tr><tr><td class="code"><pre><span class="line">RUN pwd</span></pre></td></tr></table></figure>

<p>最终<code>pwd</code>命令的输出结果会是<code>/path/$DIRNAME</code></p>
<h3 id="ARG"><a href="#ARG" class="headerlink" title="ARG"></a>ARG</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ARG &lt;name&gt;[&#x3D;&lt;default value&gt;]</span></pre></td></tr></table></figure>

<p>ARG指令定义了一个变量，用户可以使用<code>--build-arg &lt;varname&gt; = &lt;value&gt;</code>标志在构建器中通过<code>docker build</code>命令将其传递给构建器。如果用户指定了一个在Dockerfile中没有定义的构建参数，那么构建器会输出一个警告。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[Warning] One or more build-args [foo] were not consumed.</span></pre></td></tr></table></figure>

<p>一个Dockerfile可以包含一个或者多个ARG指令，比如，下面是一个合法的Dockerfile:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FROM busybox</span></pre></td></tr><tr><td class="code"><pre><span class="line">ARG user1</span></pre></td></tr><tr><td class="code"><pre><span class="line">ARG buildno</span></pre></td></tr><tr><td class="code"><pre><span class="line">...</span></pre></td></tr></table></figure>

<blockquote>
<p><strong>注意：</strong> 不推荐使用构建阶段的变量传递密钥比如github的keys，用户证书等，构建阶段变量对任何用户都是可见的，只要使用<code>docker history</code>命令。</p>
</blockquote>
<h4 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h4><p>一个ARG指令可以选择包含一个默认值：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FROM busybox</span></pre></td></tr><tr><td class="code"><pre><span class="line">ARG user1&#x3D;someuser</span></pre></td></tr><tr><td class="code"><pre><span class="line">ARG buildno&#x3D;1</span></pre></td></tr><tr><td class="code"><pre><span class="line">...</span></pre></td></tr></table></figure>

<p>如果一个ARG指令有一个默认值，而且没有其他值在构建阶段传递，那么构建器就会使用默认值。</p>
<h4 id="作用范围"><a href="#作用范围" class="headerlink" title="作用范围"></a>作用范围</h4><p>一个ARG变量的定义从它被定义的哪一行开始生效，而不是从命令行或其他地方使用参数的时候开始。比如，考虑下面这个Dockerfile:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 FROM busybox</span></pre></td></tr><tr><td class="code"><pre><span class="line">2 USER $&#123;user:-some_user&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">3 ARG user</span></pre></td></tr><tr><td class="code"><pre><span class="line">4 USER $user</span></pre></td></tr><tr><td class="code"><pre><span class="line">...</span></pre></td></tr></table></figure>

<p>一个用户用下面的命令构建了这个文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker build --build-arg user&#x3D;what_user .</span></pre></td></tr></table></figure>

<p>在这种情况下，RUN指令使用<code>v1.0.0</code>而不是用户传递的ARG设置：<code>v2.0.1</code>这种行为类似于一个shell脚本，其中一个本地作用域变量覆盖作为参数传递的变量或从环境继承的变量，定义点。</p>
<p>使用上面的示例，但使用不同的ENV规范，您可以在ARG和ENV指令之间创建更有用的交互：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 FROM ubuntu</span></pre></td></tr><tr><td class="code"><pre><span class="line">2 ARG CONT_IMG_VER</span></pre></td></tr><tr><td class="code"><pre><span class="line">3 ENV CONT_IMG_VER $&#123;CONT_IMG_VER:-v1.0.0&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">4 RUN echo $CONT_IMG_VER</span></pre></td></tr></table></figure>

<p>与ARG指令不通，ENV的值会在构建镜像的阶段一直存在。考虑一个docker不使用<code>--build-arg</code>参数的构建：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker build .</span></pre></td></tr></table></figure>

<p>使用这个Dockerfile为例，<code>CONT_IMG_VER</code>仍然在镜像中持续存在，但是它的值会是<code>v1.0.0</code>，如同第三行中ENV指令设定的那样。</p>
<p>这个例子中的变量扩展技术允许你从命令行中传递一个参数，并通过利用ENV指令将其保存在最终镜像中。变量扩展只支持<a href="https://docs.docker.com/engine/reference/builder/#environment-replacement" target="_blank" rel="noopener">有限的Dockerfile指令</a>。</p>
<h4 id="预定义的ARGs"><a href="#预定义的ARGs" class="headerlink" title="预定义的ARGs"></a>预定义的ARGs</h4><p>Docker 有一组预定义的ARG变量，您可以在Dockerfile中使用没有相应的ARG指令的变量。</p>
<ul>
<li><code>HTTP_PROXY</code></li>
<li><code>http_proxy</code></li>
<li><code>HTTPS_PROXY</code></li>
<li><code>https_proxy</code></li>
<li><code>FTP_PROXY</code></li>
<li><code>ftp_proxy</code></li>
<li><code>NO_PROXY</code></li>
<li><code>no_proxy</code></li>
</ul>
<p>想要使用它们，只需要使用命令行传递它们：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--build-arg &lt;varname&gt;&#x3D;&lt;value&gt;</span></pre></td></tr></table></figure>

<p>默认的，这些预定义变量会被<code>docker history</code>的输出结果排除。将它们排除在外可以减少在HTTP_PROXY变量中意外泄漏敏感身份验证信息的风险。</p>
<p>举个栗子，考虑使用下面的语句构建Dockerfile：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--build-arg HTTP_PROXY&#x3D;http:&#x2F;&#x2F;user:pass@proxy.lon.example.com</span></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FROM ubuntu</span></pre></td></tr><tr><td class="code"><pre><span class="line">RUN echo &quot;Hello World&quot;</span></pre></td></tr></table></figure>

<p>在这种情况下，<code>HTTP_PROXY</code>变量的值在<code>docker history</code>中不可见，而且没有被缓存。如果你本地作了修改，而且你的代理服务器设置成了<code>http://user:pass@proxy.sfo.example.com</code>，后续的构建不会导致缓存未命中。</p>
<p>如果你需要重写这种状况，你可能需要在Dockerfile中添加一个ARG声明，如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FROM ubuntu</span></pre></td></tr><tr><td class="code"><pre><span class="line">ARG HTTP_PROXY</span></pre></td></tr><tr><td class="code"><pre><span class="line">RUN echo &quot;Hello World&quot;</span></pre></td></tr></table></figure>

<p>当构建这个Dockerfile的时候，<code>HTTP_PROXY</code>被保存在了<code>docker history</code>中，而且改变了它的值使构建缓存失效。</p>
<h4 id="对构建缓存的影响"><a href="#对构建缓存的影响" class="headerlink" title="对构建缓存的影响"></a>对构建缓存的影响</h4><p>作为ENV变量，ARG变量不会保留在构建的镜像中。但是，ARG变量确实会以类似的方式影响构建缓存。如果Dockerfile定义了一个ARG变量，其值与以前的版本不同，那么在第一次使用时会发生“缓存未命中”，而不是其定义。尤其是，ARG指令之后的所有RUN指令隐式使用ARG变量（作为环境变量），因此可能导致缓存未命中。除非在Dockerfile中存在匹配的ARG语句，否则所有预定义的ARG变量都可以免于缓存。</p>
<p>举个栗子，考虑下面两个Dockerfile：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 FROM ubuntu</span></pre></td></tr><tr><td class="code"><pre><span class="line">2 ARG CONT_IMG_VER</span></pre></td></tr><tr><td class="code"><pre><span class="line">3 RUN echo $CONT_IMG_VER</span></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 FROM ubuntu</span></pre></td></tr><tr><td class="code"><pre><span class="line">2 ARG CONT_IMG_VER</span></pre></td></tr><tr><td class="code"><pre><span class="line">3 RUN echo hello</span></pre></td></tr></table></figure>

<p>如果在命令行中指定<code>--build-arg CONT_IMG_VER = &lt;value&gt;</code>，则在这两种情况下，第2行的规范不会导致缓存未命中;第3行确实导致缓存未命中.<code>ARG CONT_IMG_VER</code>导致RUN行被识别为与运行<code>CONT_IMG_VER = &lt;value&gt;</code>echo hello相同，因此如果<code>&lt;value&gt;</code>发生更改，则会导致缓存未命中。</p>
<p>考虑同一个命令行下的另一个例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 FROM ubuntu</span></pre></td></tr><tr><td class="code"><pre><span class="line">2 ARG CONT_IMG_VER</span></pre></td></tr><tr><td class="code"><pre><span class="line">3 ENV CONT_IMG_VER $CONT_IMG_VER</span></pre></td></tr><tr><td class="code"><pre><span class="line">4 RUN echo $CONT_IMG_VER</span></pre></td></tr></table></figure>

<p>在这个例子中，高速缓存未命中发生在第3行。发生未命中是因为ENV中的变量值引用了ARG变量，并且该变量通过命令行进行了更改。在这个例子中，ENV命令会使镜像包含该值。</p>
<p>如果ENV指令覆盖同名的ARG指令，就像这个Dockerfile：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 FROM ubuntu</span></pre></td></tr><tr><td class="code"><pre><span class="line">2 ARG CONT_IMG_VER</span></pre></td></tr><tr><td class="code"><pre><span class="line">3 ENV CONT_IMG_VER hello</span></pre></td></tr><tr><td class="code"><pre><span class="line">4 RUN echo $CONT_IMG_VER</span></pre></td></tr></table></figure>

<p>第3行不会导致缓存未命中，因为<code>CONT_IMG_VER</code>的值是常量（<code>hello</code>）。因此，RUN（第4行）上使用的环境变量和值在构建之间不会改变。</p>
<h3 id="ONBUILD"><a href="#ONBUILD" class="headerlink" title="ONBUILD"></a>ONBUILD</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ONBUILD [INSTRUCTION]</span></pre></td></tr></table></figure>

<p>ONBUILD指令为镜像添加一个触发器指令，稍后将该镜像用作另一个构建的基础。触发器将在下游构建的上下文中执行，就像它已经在下游Dockerfile中的FROM指令之后立即插入一样。</p>
<p>任何构建指令都可以注册为触发器。</p>
<p>如果您正在构建将用作构建其他映像的基础的映像，那么这非常有用，例如可以使用用户特定配置自定义的应用程序构建环境或守护程序。</p>
<p>例如，如果您的映像是可重用的Python应用程序构建器，则需要将应用程序源代码添加到特定目录中，并且可能需要在此之后调用构建脚本。你现在不能只调用ADD和RUN，因为你还没有访问应用程序的源代码，每个应用程序的版本都不一样。您可以简单地向应用程序开发人员提供样板化的Dockerfile以复制粘贴到他们的应用程序中，但效率低下，容易出错，难以更新，因为它与特定于应用程序的代码混合在一起。</p>
<p>解决方案是使用ONBUILD注册先行指令，以便在以后的构建阶段运行。</p>
<p>这是它如何工作的：</p>
<ol>
<li>当遇到ONBUILD指令时，构建器会为正在构建的映像的元数据添加一个触发器。该指令不会影响当前的构建。</li>
<li>在构建结束时，所有触发器的列表都存储在图像清单中的OnBuild键下。可以使用<code>docker inspect</code>命令检查它们。</li>
<li>稍后，可以使用FROM指令将镜像用作新构建的基础。作为处理FROM指令的一部分，下游构建器会查找ONBUILD触发器，并按照它们所注册的相同顺序执行它们。如果任何触发器失败，则FROM指令将被中止，从而导致构建失败。如果所有触发器都成功，则FROM指令完成，构建将像往常一样继续。</li>
<li>触发器在执行后从最终图像中清除。换句话说，他们不是由“大孩子”构建的遗传。</li>
</ol>
<p>例如，你可能会添加这样的东西：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[...]</span></pre></td></tr><tr><td class="code"><pre><span class="line">ONBUILD ADD . &#x2F;app&#x2F;src</span></pre></td></tr><tr><td class="code"><pre><span class="line">ONBUILD RUN &#x2F;usr&#x2F;local&#x2F;bin&#x2F;python-build --dir &#x2F;app&#x2F;src</span></pre></td></tr><tr><td class="code"><pre><span class="line">[...]</span></pre></td></tr></table></figure>

<blockquote>
<p><strong>注意：</strong> 不允许使用<code>ONBUILD ONBUILD</code>链接<code>ONBUILD</code>。</p>
</blockquote>
<blockquote>
<p><strong>注意：</strong> <code>ONBUILD</code>指令可能不会触发<code>FROM</code>或者<code>MAINTAINER</code>指令。</p>
</blockquote>
<h3 id="STOPSIGNAL"><a href="#STOPSIGNAL" class="headerlink" title="STOPSIGNAL"></a>STOPSIGNAL</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">STOPSIGNAL signal</span></pre></td></tr></table></figure>

<p>STOPSIGNAL指令设置将被发送到容器的系统调用信号以退出。该信号可以是一个有效的无符号数字，与内核的syscall表中的一个位置（例如9）匹配，或者是一个SIGNAME格式的信号名称，例如SIGKILL。</p>
<h3 id="HEALTHCHECK"><a href="#HEALTHCHECK" class="headerlink" title="HEALTHCHECK"></a>HEALTHCHECK</h3><p>HEALTHCHECK指令有两种形式：</p>
<ul>
<li><code>HEALTHCHECK [选项] CMD命令</code>（通过在容器中运行一个命令来检查容器的健康状况）</li>
<li><code>HEALTHCHECK NONE</code>（禁用从基础映像继承的任何健康检查）</li>
</ul>
<p>HEALTHCHECK指令告诉Docker如何测试一个容器来检查它是否还在工作。这可以检测到一些情况，例如一个陷入无限循环的web服务器，即使服务器进程仍在运行，也无法处理新的连接。</p>
<p>当容器指定了健康状况检查时，除了正常状态之外，还有一个健康状态。这个状态是最初开始的。每当健康检查通过，它变得健康（无论以前在哪个状态）。经过一定次数的连续失败后，变得不健康。</p>
<p>可以在CMD之前出现的选项是：</p>
<ul>
<li><code>--interval = DURATION</code>（默认：30秒）</li>
<li><code>--timeout = DURATION</code>（默认：30s）</li>
<li><code>--start-period = DURATION</code>（默认值：0s）</li>
<li><code>--retries = N</code>（默认值：3）</li>
</ul>
<p>运行状况检查将首先在容器启动后的间隔秒内运行，然后在每次前一次检查完成后再次间隔几秒。</p>
<p>如果单次运行检查花费的时间超过了超过秒数，则认为检查失败。</p>
<p>多次连续的健康检查失败的容器被认为是不健康的。</p>
<p>启动周期为需要时间启动的容器提供初始化时间。在此期间的探测失败不会计入最大重试次数。但是，如果在启动期间运行状况检查成功，则认为容器已启动，并且所有连续的故障都将计入最大重试次数。</p>
<p>Dockerfile中只能有一个HEALTHCHECK指令。如果您列出多个，则只有最后一个HEALTHCHECK将生效。</p>
<p>CMD关键字之后的命令可以是shell命令（例如，HEALTHCHECK CMD / bin / check-running）或exec阵列（与其他Dockerfile命令一样;例如参见ENTRYPOINT以获得详细信息）。</p>
<p>该命令的退出状态表示容器的健康状态。可能的值是：</p>
<ul>
<li>0：成功 - 容器很健康而且随时可以使用</li>
<li>1：不健康 - 容器运行状态不正常</li>
<li>2：保留 - 不要使用这个退出状态码</li>
</ul>
<p>例如，要每隔五分钟检查一次，网络服务器是否能够在三秒内为网站的主页提供服务：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HEALTHCHECK --interval &#x3D; 5m --timeout &#x3D; 3s \</span></pre></td></tr><tr><td class="code"><pre><span class="line">  CMD curl -f http：&#x2F;&#x2F; localhost &#x2F; ||exit 1</span></pre></td></tr></table></figure>

<p>为了帮助调试失败的探测器，命令在stdout或stderr上写入的任何输出文本（UTF-8编码）都将存储在健康状态中，并且可以通过docker检查进行查询。这样的输出应该保持简短（目前只有前4096个字节被存储）。</p>
<p>当容器的运行状况发生变化时，会以新状态生成一个<code>health_status</code>事件。</p>
<p>在Docker 1.12中添加了HEALTHCHECK功能。</p>
<h3 id="SHELL"><a href="#SHELL" class="headerlink" title="SHELL"></a>SHELL</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SHELL [&quot;executable&quot;, &quot;parameters&quot;]</span></pre></td></tr></table></figure>

<p>SHELL指令允许覆盖用于shell命令形式的默认shell。 Linux上的默认shell是<code>[&quot;/bin/sh&quot;，&quot;-c&quot;]</code>，在Windows上是<code>[&quot;cmd&quot;，&quot;/S&quot;，&quot;/C&quot;]</code>。 SHELL指令必须以JSON格式写入Dockerfile中。</p>
<p>SHELL指令在Windows中有两个常用和完全不同的本机shell特别有用：cmd和powershell，以及可用的备用shell，包括sh。</p>
<p>SHELL指令可以出现多次。每个SHELL指令将覆盖所有先前的SHELL指令，并影响所有后续指令。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FROM microsoft&#x2F;windowsservercore</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"># Executed as cmd &#x2F;S &#x2F;C echo default</span></pre></td></tr><tr><td class="code"><pre><span class="line">RUN echo default</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"># Executed as cmd &#x2F;S &#x2F;C powershell -command Write-Host default</span></pre></td></tr><tr><td class="code"><pre><span class="line">RUN powershell -command Write-Host default</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"># Executed as powershell -command Write-Host hello</span></pre></td></tr><tr><td class="code"><pre><span class="line">SHELL [&quot;powershell&quot;, &quot;-command&quot;]</span></pre></td></tr><tr><td class="code"><pre><span class="line">RUN Write-Host hello</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"># Executed as cmd &#x2F;S &#x2F;C echo hello</span></pre></td></tr><tr><td class="code"><pre><span class="line">SHELL [&quot;cmd&quot;, &quot;&#x2F;S&quot;&quot;, &quot;&#x2F;C&quot;]</span></pre></td></tr><tr><td class="code"><pre><span class="line">RUN echo hello</span></pre></td></tr></table></figure>


<p>如果在Dockerfile中使用SHELL指令，则会影响以下指令：RUN，CMD和ENTRYPOINT。</p>
<p>以下示例是在Windows上可以通过使用SHELL指令简化的常见模式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">...</span></pre></td></tr><tr><td class="code"><pre><span class="line">RUN powershell -command Execute-MyCmdlet -param1 &quot;c:\foo.txt&quot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">...</span></pre></td></tr></table></figure>

<p>docker调用的命令是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cmd &#x2F;S &#x2F;C powershell -command Execute-MyCmdlet -param1 &quot;c:\foo.txt&quot;</span></pre></td></tr></table></figure>

<p>这是低效率的，原因有两个。首先，调用一个不必要的cmd.exe命令处理器（又名shell）。其次，shell格式中的每条RUN指令都需要在命令前加上一个额外的powershell命令。</p>
<p>为了提高效率，可以采用两种机制之一。一种是使用RUN命令的JSON格式，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">...</span></pre></td></tr><tr><td class="code"><pre><span class="line">RUN [&quot;powershell&quot;，&quot;-command&quot;，&quot;Execute-MyCmdlet&quot;，&quot;-param1 \&quot;c:\\foo.txt\&quot;&quot;]</span></pre></td></tr><tr><td class="code"><pre><span class="line">...</span></pre></td></tr></table></figure>

<p>虽然JSON格式是明确的，并且不使用不必要的cmd.exe，但是通过双引号和转义确实需要更多的冗长。另一种机制是使用SHELL指令和shell形式，为Windows用户提供更自然的语法，特别是与<code>escape</code>转义指令结合使用时：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># escape&#x3D;&#96;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">FROM microsoft&#x2F;nanoserver</span></pre></td></tr><tr><td class="code"><pre><span class="line">SHELL [&quot;powershell&quot;,&quot;-command&quot;]</span></pre></td></tr><tr><td class="code"><pre><span class="line">RUN New-Item -ItemType Directory C:\Example</span></pre></td></tr><tr><td class="code"><pre><span class="line">ADD Execute-MyCmdlet.ps1 c:\example\</span></pre></td></tr><tr><td class="code"><pre><span class="line">RUN c:\example\Execute-MyCmdlet -sample &#39;hello world&#39;</span></pre></td></tr></table></figure>
<p>结果是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PS E:\docker\build\shell&gt; docker build -t shell .</span></pre></td></tr><tr><td class="code"><pre><span class="line">Sending build context to Docker daemon 4.096 kB</span></pre></td></tr><tr><td class="code"><pre><span class="line">Step 1&#x2F;5 : FROM microsoft&#x2F;nanoserver</span></pre></td></tr><tr><td class="code"><pre><span class="line"> ---&gt; 22738ff49c6d</span></pre></td></tr><tr><td class="code"><pre><span class="line">Step 2&#x2F;5 : SHELL powershell -command</span></pre></td></tr><tr><td class="code"><pre><span class="line"> ---&gt; Running in 6fcdb6855ae2</span></pre></td></tr><tr><td class="code"><pre><span class="line"> ---&gt; 6331462d4300</span></pre></td></tr><tr><td class="code"><pre><span class="line">Removing intermediate container 6fcdb6855ae2</span></pre></td></tr><tr><td class="code"><pre><span class="line">Step 3&#x2F;5 : RUN New-Item -ItemType Directory C:\Example</span></pre></td></tr><tr><td class="code"><pre><span class="line"> ---&gt; Running in d0eef8386e97</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    Directory: C:\</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">Mode                LastWriteTime         Length Name</span></pre></td></tr><tr><td class="code"><pre><span class="line">----                -------------         ------ ----</span></pre></td></tr><tr><td class="code"><pre><span class="line">d-----       10&#x2F;28&#x2F;2016  11:26 AM                Example</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"> ---&gt; 3f2fbf1395d9</span></pre></td></tr><tr><td class="code"><pre><span class="line">Removing intermediate container d0eef8386e97</span></pre></td></tr><tr><td class="code"><pre><span class="line">Step 4&#x2F;5 : ADD Execute-MyCmdlet.ps1 c:\example\</span></pre></td></tr><tr><td class="code"><pre><span class="line"> ---&gt; a955b2621c31</span></pre></td></tr><tr><td class="code"><pre><span class="line">Removing intermediate container b825593d39fc</span></pre></td></tr><tr><td class="code"><pre><span class="line">Step 5&#x2F;5 : RUN c:\example\Execute-MyCmdlet &#39;hello world&#39;</span></pre></td></tr><tr><td class="code"><pre><span class="line"> ---&gt; Running in be6d8e63fe75</span></pre></td></tr><tr><td class="code"><pre><span class="line">hello world</span></pre></td></tr><tr><td class="code"><pre><span class="line"> ---&gt; 8e559e9bf424</span></pre></td></tr><tr><td class="code"><pre><span class="line">Removing intermediate container be6d8e63fe75</span></pre></td></tr><tr><td class="code"><pre><span class="line">Successfully built 8e559e9bf424</span></pre></td></tr><tr><td class="code"><pre><span class="line">PS E:\docker\build\shell&gt;</span></pre></td></tr></table></figure>


<p>SHELL指令也可以用来修改shell的运行方式。例如，在Windows上使用<code>SHELL cmd /S /C /V:ON|OFF</code>，可以修改延迟的环境变量扩展语义。</p>
<p>SHELL指令也可以在Linux上使用，如果需要备用shell，如zsh，csh，tcsh等。</p>
<p>SHELL功能是在Docker 1.12中添加的。</p>
<h2 id="Dockerfile-示例"><a href="#Dockerfile-示例" class="headerlink" title="Dockerfile 示例"></a>Dockerfile 示例</h2><p>在你可以看到Dockerfile语法之前，如果你对更多的实例感兴趣，可以参考<a href="https://docs.docker.com/engine/examples/" target="_blank" rel="noopener">docker文档</a>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Nginx</span></pre></td></tr><tr><td class="code"><pre><span class="line">#</span></pre></td></tr><tr><td class="code"><pre><span class="line"># VERSION               0.0.1</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">FROM      ubuntu</span></pre></td></tr><tr><td class="code"><pre><span class="line">LABEL Description&#x3D;&quot;This image is used to start the foobar executable&quot; Vendor&#x3D;&quot;ACME Products&quot; Version&#x3D;&quot;1.0&quot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">RUN apt-get update &amp;&amp; apt-get install -y inotify-tools nginx apache2 openssh-server</span></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Firefox over VNC</span></pre></td></tr><tr><td class="code"><pre><span class="line">#</span></pre></td></tr><tr><td class="code"><pre><span class="line"># VERSION               0.3</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">FROM ubuntu</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"># Install vnc, xvfb in order to create a &#39;fake&#39; display and firefox</span></pre></td></tr><tr><td class="code"><pre><span class="line">RUN apt-get update &amp;&amp; apt-get install -y x11vnc xvfb firefox</span></pre></td></tr><tr><td class="code"><pre><span class="line">RUN mkdir ~&#x2F;.vnc</span></pre></td></tr><tr><td class="code"><pre><span class="line"># Setup a password</span></pre></td></tr><tr><td class="code"><pre><span class="line">RUN x11vnc -storepasswd 1234 ~&#x2F;.vnc&#x2F;passwd</span></pre></td></tr><tr><td class="code"><pre><span class="line"># Autostart firefox (might not be the best way, but it does the trick)</span></pre></td></tr><tr><td class="code"><pre><span class="line">RUN bash -c &#39;echo &quot;firefox&quot; &gt;&gt; &#x2F;.bashrc&#39;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">EXPOSE 5900</span></pre></td></tr><tr><td class="code"><pre><span class="line">CMD    [&quot;x11vnc&quot;, &quot;-forever&quot;, &quot;-usepw&quot;, &quot;-create&quot;]</span></pre></td></tr><tr><td class="code"><pre><span class="line"># Multiple images example</span></pre></td></tr><tr><td class="code"><pre><span class="line">#</span></pre></td></tr><tr><td class="code"><pre><span class="line"># VERSION               0.1</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">FROM ubuntu</span></pre></td></tr><tr><td class="code"><pre><span class="line">RUN echo foo &gt; bar</span></pre></td></tr><tr><td class="code"><pre><span class="line"># Will output something like &#x3D;&#x3D;&#x3D;&gt; 907ad6c2736f</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">FROM ubuntu</span></pre></td></tr><tr><td class="code"><pre><span class="line">RUN echo moo &gt; oink</span></pre></td></tr><tr><td class="code"><pre><span class="line"># Will output something like &#x3D;&#x3D;&#x3D;&gt; 695d7793cbe4</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"># You&#39;ll now have two images, 907ad6c2736f with &#x2F;bar, and 695d7793cbe4 with</span></pre></td></tr><tr><td class="code"><pre><span class="line"># &#x2F;oink.</span></pre></td></tr></table></figure>

<h2 id="Dockerfile-最佳实践"><a href="#Dockerfile-最佳实践" class="headerlink" title="Dockerfile 最佳实践"></a>Dockerfile 最佳实践</h2><p>Docker可以通过从Dockerfile中阅读</p>
<h3 id="一般参考和建议"><a href="#一般参考和建议" class="headerlink" title="一般参考和建议"></a>一般参考和建议</h3><h4 id="容器应该是短暂的"><a href="#容器应该是短暂的" class="headerlink" title="容器应该是短暂的"></a>容器应该是短暂的</h4><p>你Dockerfile中定义的镜像所产生的容器应该是尽可能短暂的。提到“短暂“，我们的意思是它可以停止和被销毁，而且可以用一个最小化的启动和配置流程来构建一个新的替代它。</p>
<h4 id="使用-dockerignore文件"><a href="#使用-dockerignore文件" class="headerlink" title="使用.dockerignore文件"></a>使用.dockerignore文件</h4><p>当您发出docker build命令时，您所在的当前工作目录称为构建上下文，并且Dockerfile必须位于此构建上下文中的某个位置。默认情况下，它假定位于当前目录中，但是可以使用<code>-f</code>标志指定不同的位置。无论Dockerfile实际存在于哪里，当前目录中的所有文件和目录的递归内容都会作为构建上下文发送到Docker守护进程。无意中包含构建映像所不需要的文件会产生较大的构建上下文和较大的映像大小。这些反过来可以增加构建时间，拉和推图像的时间以及容器的运行时间大小。要查看构建上下文有多大，在构建Dockerfile时查找如下消息。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Sending build context to Docker daemon  187.8MB</span></pre></td></tr></table></figure>

<p>要排除与构建无关的文件，而不重构源代码库，请使用.dockerignore文件。该文件支持类似于.gitignore文件的排除模式。有关创建一个的信息，请参阅<a href="https://docs.docker.com/engine/reference/builder/#dockerignore-file" target="_blank" rel="noopener">.dockerignore</a>文件。除了使用.dockerignore文件之外，请查看以下关于<a href="https://docs.docker.com/engine/userguide/eng-image/dockerfile_best-practices/#use-multi-stage-builds" target="_blank" rel="noopener">多阶段构建</a>的信息。</p>
<h4 id="使用多阶段构建"><a href="#使用多阶段构建" class="headerlink" title="使用多阶段构建"></a>使用多阶段构建</h4><p>如果你使用Docker 17.05或者更高版本，你可以使用<a href="https://docs.docker.com/engine/userguide/eng-image/multistage-build/" target="_blank" rel="noopener">多阶段构建</a>来彻底减少最终镜像的大小。</p>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Docker</tag>
        <tag>Dockerfile</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 多线程 常见面试问题</title>
    <url>/2017/05/07/Java-%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>整理下Java多线程相关知识点和面试可能会问到的问题</p>
<a id="more"></a>
<h4 id="现在有T1、T2、T3三个线程，你怎样保证T2在T1执行完后执行，T3在T2执行完后执行？"><a href="#现在有T1、T2、T3三个线程，你怎样保证T2在T1执行完后执行，T3在T2执行完后执行？" class="headerlink" title="现在有T1、T2、T3三个线程，你怎样保证T2在T1执行完后执行，T3在T2执行完后执行？"></a>现在有T1、T2、T3三个线程，你怎样保证T2在T1执行完后执行，T3在T2执行完后执行？</h4><p>join方法</p>
<h4 id="在java中wait和sleep方法的不同？"><a href="#在java中wait和sleep方法的不同？" class="headerlink" title="在java中wait和sleep方法的不同？"></a>在java中wait和sleep方法的不同？</h4><p>最大的不同是wait会在等待时释放锁，而sleep会持有锁。wait通常会被用于线程之间的交互，sleep通常被用于暂停执行。</p>
<h4 id="volatile能提供什么保证？"><a href="#volatile能提供什么保证？" class="headerlink" title="volatile能提供什么保证？"></a>volatile能提供什么保证？</h4><p>volatile变量提供顺序保证和可见性保证，比如JVM或者JIT会为了更好的性能对语句重排顺序，使用volatile修饰的变量即使在没有同步块的情况下赋值也不会与其他语句重拍序。volatile提供happens-before保证，确保一个线程的修改能对其他线程可见。<br>在某些情况下还能提供原子性，比如long和double类型的数据。</p>
<h4 id="Java中能创建volatile数组吗"><a href="#Java中能创建volatile数组吗" class="headerlink" title="Java中能创建volatile数组吗?"></a>Java中能创建volatile数组吗?</h4><p>能，Java中能创建volatile数组，但是只是一个指向数组的引用，而不是整个数组，也就是说如果多个线程同时改变数组的元素，volatile标识符就不能起到保护作用。、</p>
<h4 id="volatile标识符能使一个非原子操作变成一个原子操作吗？"><a href="#volatile标识符能使一个非原子操作变成一个原子操作吗？" class="headerlink" title="volatile标识符能使一个非原子操作变成一个原子操作吗？"></a>volatile标识符能使一个非原子操作变成一个原子操作吗？</h4><p>一个典型的例子就是一个long类型。Java中读取long类型变量不是原子的，需要分成两步，如果一个线程正在修改该long变量的值，另一个线程可能就只能看到该值的一半（前32位）。但是如果对一个volatile修饰的long或者double变量的读写是原子的。</p>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>Java JVM 常见面试问题</title>
    <url>/2017/05/07/Java-JVM-%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>整理下JVM相关知识点和面试可能会问到的问题</p>
<a id="more"></a>
<h4 id="64位JVM中，int的长度是多少位？"><a href="#64位JVM中，int的长度是多少位？" class="headerlink" title="64位JVM中，int的长度是多少位？"></a>64位JVM中，int的长度是多少位？</h4><p>Java中，int类型变量的长度是一个固定值，与平台无关，都是32位。</p>
<h4 id="对象分配规则"><a href="#对象分配规则" class="headerlink" title="对象分配规则"></a>对象分配规则</h4><ul>
<li>对象优先分配在<code>Eden</code>区，如果<code>Eden</code>区没有足够的空间时，虚拟机执行一次<code>Minor GC</code>.</li>
<li>大对象直接进入老年代。这么做的目的是避免频繁在<code>Eden</code>区和两个<code>Survivor</code>区之间发生大量的内存拷贝。</li>
<li>长期存活的对象进入老年代。虚拟机为每个对象定义了一个年龄计数器，如果对象经过一次<code>Minor GC</code>那么对象会进入<code>Survivor</code>区，之后每经过一次<code>Minor GC</code>对象的年龄就会增加一，直到达到阈值，对象进入老年代。</li>
<li>动态判断对象的年龄。如果<code>Survivor</code>区中相同年龄的所有对象大小的总和大于<code>Survivor</code>空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代。</li>
<li>空间分配担保。每次进行<code>Minor GC</code>时，<code>JVM</code>会计算<code>Survivor</code>区移动到老年区的对象的平均大小，如果这个值大于老年区的剩余值则进行一次<code>Full GC</code>，如果小于就检查<code>HandlePromotionFailure</code>设置，设置为<code>true</code>的话只进行<code>Minor GC</code>，如果<code>false</code>则进行<code>Full GC</code>。</li>
</ul>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>Java API 常见面试问题</title>
    <url>/2017/05/02/Java-API-%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>整理下面试的时候可能会问到的Java常用API问题</p>
<a id="more"></a>

<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><h4 id="怎么将byte转换为String？"><a href="#怎么将byte转换为String？" class="headerlink" title="怎么将byte转换为String？"></a>怎么将byte转换为String？</h4><p>可以使用String接收byte[]参数的构造器来进行转换，需要注意的是使用正确的编码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> String(<span class="string">"你好啊"</span>.getBytes(), StandardCharsets.UTF_8);</span></pre></td></tr></table></figure>

<h4 id="我们能将int强制转换位byte类型的变量吗？如果该值大于byte类型的范围，将会出现什么现象？"><a href="#我们能将int强制转换位byte类型的变量吗？如果该值大于byte类型的范围，将会出现什么现象？" class="headerlink" title="我们能将int强制转换位byte类型的变量吗？如果该值大于byte类型的范围，将会出现什么现象？"></a>我们能将int强制转换位byte类型的变量吗？如果该值大于byte类型的范围，将会出现什么现象？</h4><p>是的，可以强制转换,但是Java中int是32位的，而byte是8位的，所以，如果强制转化，int类型的高24位将会被丢弃，byte类型的范围是-127到128。</p>
<h4 id="Java中的-操作符是线程安全的吗？"><a href="#Java中的-操作符是线程安全的吗？" class="headerlink" title="Java中的++操作符是线程安全的吗？"></a>Java中的++操作符是线程安全的吗？</h4><p>不是，这个操作实际上涉及三个指令：读取变量值，增加，再存储会内存，这个过程有可能出现多个线程交叉。</p>
<h4 id="3-0-1-0-3-将会返回什么？true-还是-false？"><a href="#3-0-1-0-3-将会返回什么？true-还是-false？" class="headerlink" title="3*0.1 == 0.3 将会返回什么？true 还是 false？"></a>3*0.1 == 0.3 将会返回什么？true 还是 false？</h4><p>false，因为有些浮点数不能精确度的表示出来。<br>可以用<code>BigDecimal</code>转换后进行精确计算：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BigDecimal bigDecimal = <span class="keyword">new</span> BigDecimal(<span class="string">"0.2"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">System.out.println(bigDecimal.multiply(<span class="keyword">new</span> BigDecimal(<span class="string">"6"</span>)).doubleValue());</span></pre></td></tr></table></figure>
<p>这里注意要用BigDecimal的String构造器，如果是用double类型，仍然是不精确的。<br>参考：<a href="https://my.oschina.net/junn/blog/136978" target="_blank" rel="noopener">Java中浮点型数据Float和Double进行精确计算的问题</a></p>
<h4 id="可以用Switch中使用String吗？"><a href="#可以用Switch中使用String吗？" class="headerlink" title="可以用Switch中使用String吗？"></a>可以用Switch中使用String吗？</h4><p>从Java7开始，我们可以在switch case中使用字符串，但这仅仅是一个语法糖。内部实现在switch中使用字符串的hash code。</p>
<h4 id="String和StringBuilder-StringBuffer"><a href="#String和StringBuilder-StringBuffer" class="headerlink" title="String和StringBuilder/StringBuffer"></a>String和StringBuilder/StringBuffer</h4><p>String是只读字符串，它所引用的字符串内容是不能被改变的。而StringBuffer和StringBuilder表示的字符串对象是可以修改的。StringBuilder是JDK1.5引入的，区别在于它是在单线程环境下使用的，所有方面都没有被synchronized修饰，因此它的效率也比StringBuffer高。<br>关于性能问题，有个知乎问题：<a href="https://www.zhihu.com/question/20101840" target="_blank" rel="noopener">JAVA 中的 StringBuilder 和 StringBuffer 适用的场景是什么？</a> 评论区提到，现在用+号拼接字符串已经没有了性能损失，除非在一个循环里面重复执行，因为这样会多次创建StringBuilder</p>
<p>有一个面试题问：有没有哪种情况用 + 做字符串连接比调用 StringBuffer / StringBuilder 对象的 append 方法性能更好？如果连接后得到的字符串在静态存储区中是早已存在的，那么用+做字符串连接是优于 StringBuffer / StringBuilder 的 append 方法的。</p>
<h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><h4 id="ArrayList和LinkedList区别是什么"><a href="#ArrayList和LinkedList区别是什么" class="headerlink" title="ArrayList和LinkedList区别是什么"></a>ArrayList和LinkedList区别是什么</h4><p>ArrayList底层使用数组，随机访问效率高，插入和删除元素的效率低，需要连续空间；LinkedList底层使用链表，随机访问元素效率低，插入和删除效率高，不需要连续空间。</p>
<h4 id="LinkedHashMap-和-PriorityQueue-的区别是什么？"><a href="#LinkedHashMap-和-PriorityQueue-的区别是什么？" class="headerlink" title="LinkedHashMap 和 PriorityQueue 的区别是什么？"></a>LinkedHashMap 和 PriorityQueue 的区别是什么？</h4><p>PriorityQueue保证最高或者最低优先级的元素总在队列头部，但是LinkedHashMap维持的顺序是元素插入的顺序。当遍历一个PriorityQueue时，没有任何顺序保证，但是LinkedHashMap保证按照插入顺序。</p>
<h4 id="Java中怎么打印数组？"><a href="#Java中怎么打印数组？" class="headerlink" title="Java中怎么打印数组？"></a>Java中怎么打印数组？</h4><p>用Arrays.toString()和Arrays.deepToString()方法。</p>
<h4 id="TreeMap是用什么实现的？"><a href="#TreeMap是用什么实现的？" class="headerlink" title="TreeMap是用什么实现的？"></a>TreeMap是用什么实现的？</h4><p>红黑树。</p>
<h4 id="ArrayList和HashMap的默认大小是多少？"><a href="#ArrayList和HashMap的默认大小是多少？" class="headerlink" title="ArrayList和HashMap的默认大小是多少？"></a>ArrayList和HashMap的默认大小是多少？</h4><p>ArrayList的默认大小是是个元素，HashMap的默认大小是16个元素（必须是2的幂）</p>
<h4 id="Iterator和ListIterator的区别是什么？"><a href="#Iterator和ListIterator的区别是什么？" class="headerlink" title="Iterator和ListIterator的区别是什么？"></a>Iterator和ListIterator的区别是什么？</h4><ul>
<li>Iterator可以用来遍历Set和List集合，但是ListIterator只能用来遍历List。</li>
<li>Iterator对集合只能是前向遍历，但是ListIterator可以前向也可以后向。</li>
<li>ListIterator实现了Iterator接口，并且包含其他功能。比如：增加元素，替换元素，获取前一个和后一个元素的索引等等。</li>
</ul>
<h4 id="快速失败-fail-fast-和安全失败-fail-safe-的区别是什么？"><a href="#快速失败-fail-fast-和安全失败-fail-safe-的区别是什么？" class="headerlink" title="快速失败(fail-fast)和安全失败(fail-safe)的区别是什么？"></a>快速失败(fail-fast)和安全失败(fail-safe)的区别是什么？</h4><p>Iterator的安全失败是基于对底层集合做拷贝，因此，它不受源集合上修改的影响。java.util包下面的所有集合都是快速失败的，而java.util.current包下面的所有类都是安全失败的。快速失败的迭代器会抛出CurrentModificationException异常，而安全失败的迭代器永远不会抛出这样的异常。</p>
<h4 id="用什么方法来实现集合的排序？"><a href="#用什么方法来实现集合的排序？" class="headerlink" title="用什么方法来实现集合的排序？"></a>用什么方法来实现集合的排序？</h4><p>可以使用有序集合比如TreeSet或者TreeMap，你也可以使用Collections.sort()来排序</p>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>面试</tag>
        <tag>API</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaFX简单入门</title>
    <url>/2017/04/13/JavaFX%E7%AE%80%E5%8D%95%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<p>这几天鼓捣bilibili的直播，想做一个桌面弹窗，方便查看直播消息，开始用Python和PyQt5，后来觉得Python手实在太生，写出来的代码惨不忍睹，不如就用ava写了，找工作也用得上。Java写GUI一向饱受诟病，看了半天也没啥很好的方案，推荐最多的就是JavaFX了。中文资料比较缺乏，只能慢慢摸索了，做到哪里就跟着写到哪里吧，这篇就总结下JavaFx学到的东西。</p>
<a id="more"></a>
<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>JavaFX是一个强大的图形和多媒体处理工具包集合，和Java一样是跨平台的，在Java8里面已经内置。<br>JavaFX8新的特性（不知道啥意思跟着抄下来装逼就对了）：</p>
<ul>
<li>JavaFX应用程序的默认主题是新设计的Modena主题。详见“关键特性”一节中的Modena主题部分。</li>
<li>已经加入了对HTML5的支持。详见“向JavaFX应用程序中添加HTML内容”相关章节。</li>
<li>新添加的SwingNode类改进了与Swing的互操作性。参考“在JavaFX应用程序中嵌入Swing内容”相关章节。</li>
<li>新的内置UI控件，DatePicker和TableView，已经可用。参考《使用JavaFX UI控件》一文来获得更多信息。</li>
<li>3D图形库被改进了，增加了一些新的API类。参考“关键特性”一节中的3D图形特性部分和“开始使用JavaFX 3D图形”章节来获得更多信息。</li>
<li>print包现在是可用的，并且提供了公开的JavaFX打印API</li>
<li>加入了富本文支持</li>
<li>对Hi-DPI显示的支持已经变得可用了</li>
<li>CSS样式类变成了公开API</li>
<li>引入了调度服务类</li>
</ul>
<h1 id="JavaFX架构"><a href="#JavaFX架构" class="headerlink" title="JavaFX架构"></a>JavaFX架构</h1><p>先放一个现成的架构图：<br><img src="http://www.javafxchina.net/blog/wp-content/uploads/2015/06/2_1-jfxar_dt_001_arch-diag.png" alt="">  </p>
<h2 id="Scene-场景图"><a href="#Scene-场景图" class="headerlink" title="Scene 场景图"></a>Scene 场景图</h2><p>Scene在顶层部分，是构建JavaFX应用的入口，这是一个层级结构的节点树，表示了所有用户界面的视觉元素，可以处理输入，可以被渲染。<br>场景图中的元素被称为一个节点（Node），每个节点有一个ID，样式类和一个包围盒（bounding volime），除了根节点，其他都有一个父节点，零个或者多个子节点。除此之外还有如下特性：</p>
<ul>
<li>效果（Effects），比如模糊和阴影</li>
<li>不透明度（Opacity）</li>
<li>变换（Transforms）</li>
<li>事件处理器（Event handlers，例如鼠标、键盘和输入法）</li>
<li>应用相关的状态（Application-specific state）</li>
</ul>
<h2 id="图形系统"><a href="#图形系统" class="headerlink" title="图形系统"></a>图形系统</h2><p>JavaFX图形系统（Graphics System）是架构图中蓝色部分，是在JavaFX场景图层之下的实现细节。当系统中的图形硬件无法支持硬件加速渲染时，它将提供软件渲染技术。</p>
<p>在JavaFX平台中实现了两套图形加速流水线：</p>
<ul>
<li>Prism用于处理渲染工作。它可以在硬件和软件渲染器之上工作，包括3D。它负责将JavaFX场景进行光栅化和渲染。下面的各种渲染方式都有可能被用到：<ul>
<li>在Windows XP和Vista上的DirectX 9</li>
<li>在Windows 7上的DirectX 11</li>
<li>Mac、Linux、嵌入式设备上的OpenGL</li>
<li>当硬件加速技术不支持时使用软件渲染，如果可能将会优先使用硬件加速，但是如果硬件加速不可用则会使用软件渲染，软件渲染技术已经内置于JRE之中。这点在展示3D场景时尤其重要。当然，使用硬件加速时性能将会更好。</li>
</ul>
</li>
<li>Quantum Toolkit 将Prism和Glass Windowing ToolKit绑在一起，使得它们可以被其上层的JavaFX层使用。它也负责管理与渲染有关的事件处理的线程规则。</li>
</ul>
<h1 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h1><h2 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h2><p>最简单的一个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> javafx.application.Application;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> javafx.scene.Group;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> javafx.scene.Scene;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> javafx.scene.paint.Color;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> javafx.stage.Stage;</span></pre></td></tr><tr><td class="code"><pre><span class="line"> </span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> <span class="keyword">extends</span> <span class="title">Application</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"> </span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="meta">@Override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(Stage stage)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">       Group root = <span class="keyword">new</span> Group();</span></pre></td></tr><tr><td class="code"><pre><span class="line">       Scene scene = <span class="keyword">new</span> Scene(root, <span class="number">500</span>, <span class="number">500</span>, Color.BLACK);</span></pre></td></tr><tr><td class="code"><pre><span class="line">       stage.setTitle(<span class="string">"JavaFX Scene Graph Demo"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">       stage.setScene(scene);</span></pre></td></tr><tr><td class="code"><pre><span class="line">       stage.show();</span></pre></td></tr><tr><td class="code"><pre><span class="line">   &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"> </span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">       launch(args);</span></pre></td></tr><tr><td class="code"><pre><span class="line">   &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>



<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="http://www.javafxchina.net/" target="_blank" rel="noopener">JavaFX中文资料</a></p>
]]></content>
      <categories>
        <category>JavaFX</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaFX</tag>
        <tag>GUI</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring配置文件</title>
    <url>/2017/04/07/Spring%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<p>被Spring配置文件搞得不胜其烦，干脆记下来，也不用到处找教程了。</p>
<a id="more"></a>
<h1 id="配置内容"><a href="#配置内容" class="headerlink" title="配置内容"></a>配置内容</h1><h2 id="web-xml"><a href="#web-xml" class="headerlink" title="web.xml"></a>web.xml</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">"http://xmlns.jcp.org/xml/ns/javaee"</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd"</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">         <span class="attr">version</span>=<span class="string">"3.1"</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>SpringMVC<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>WEB-INF/springmvc-servlet.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>SpringMVC<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span></pre></td></tr></table></figure>
<h2 id="spring"><a href="#spring" class="headerlink" title="spring"></a>spring</h2><h2 id="springmvc"><a href="#springmvc" class="headerlink" title="springmvc"></a>springmvc</h2><p>然后是springmvc的配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">       <span class="attr">xmlns:mvc</span>=<span class="string">"http://www.springframework.org/schema/mvc"</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd"</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"index"</span>/&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">mvc:default-servlet-handler</span>/&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">mvc:annotation-driven</span>/&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.view.InternalResourceViewResolver"</span> <span class="attr">id</span>=<span class="string">"internalResourceViewResolver"</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"prefix"</span> <span class="attr">value</span>=<span class="string">"/WEB-INF/pages"</span>/&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"suffix"</span> <span class="attr">value</span>=<span class="string">".jsp"</span>/&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span></pre></td></tr></table></figure>

<h1 id="详细解释"><a href="#详细解释" class="headerlink" title="详细解释"></a>详细解释</h1><h2 id="web-xml-1"><a href="#web-xml-1" class="headerlink" title="web.xml"></a>web.xml</h2><h3 id="web-xml文件元素"><a href="#web-xml文件元素" class="headerlink" title="web.xml文件元素"></a>web.xml文件元素</h3><h4 id="schema"><a href="#schema" class="headerlink" title="schema"></a>schema</h4><p>Sun公司定义的，在根元素<web-app>中，都必须标明web.xml是用的拿个文件模式。其他元素放在<web-app></web-app>内部<br>比如：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">"http://xmlns.jcp.org/xml/ns/javaee"</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd"</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">         <span class="attr">version</span>=<span class="string">"3.1"</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span></pre></td></tr></table></figure>

<h4 id="icon、display、disciption、"><a href="#icon、display、disciption、" class="headerlink" title="icon、display、disciption、"></a>icon、display、disciption、</h4><p>分别用来描述web应用的图标、名称和描述，基本没用过…</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">icon</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">small-icon</span>&gt;</span>/images/app_small.gif<span class="tag">&lt;/<span class="name">small-icon</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">large-icon</span>&gt;</span>/images/app_large.gif<span class="tag">&lt;/<span class="name">large-icon</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">icon</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">display-name</span>&gt;</span>Tomcat Example<span class="tag">&lt;/<span class="name">display-name</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">disciption</span>&gt;</span>Tomcat Example servlets and JSP pages.<span class="tag">&lt;/<span class="name">disciption</span>&gt;</span></span></pre></td></tr></table></figure>

<h4 id="context-param-上下文参数"><a href="#context-param-上下文参数" class="headerlink" title="context-param 上下文参数"></a>context-param 上下文参数</h4><p>声明应用范围内的初始化参数。向ServletContext提供键值对，即应用程序上下文信息。listener，filter等在初始化的时候会用到这些上下文中的信息。在servlet了里面可以通过<code>getServletContext().getInitParameter(&quot;cibtext/param&quot;)</code>得到</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>ContextParameter<span class="tag">&lt;/<span class="name">para-name</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>test<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>It is a test parameter.<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span></pre></td></tr></table></figure>

<h4 id="filter-过滤器"><a href="#filter-过滤器" class="headerlink" title="filter 过滤器"></a>filter 过滤器</h4><p>将一个名字和一个实现javaxs.servlet.Filter接口的类相关联<br>通过Filter技术，对web服务器管理的所有web资源：例如Jsp, Servlet, 静态图片文件或静态 html 文件等进行拦截，从而实现一些特殊的功能。例如实现URL级别的权限访问控制、过滤敏感词汇、压缩响应信息等一些高级功能。<br>使用Filter 的完整流程：Filter 对用户请求进行预处理，接着将请求交给Servlet 进行处理并生成响应，最后Filter 再对服务器响应进行后处理。</p>
<h5 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h5><ul>
<li>在HttpServletRequest 到达 Servlet 之前，拦截客户的 HttpServletRequest 。 根据需要检查 HttpServletRequest ，也可以修改HttpServletRequest 头和数据。</li>
<li>在HttpServletResponse 到达客户端之前，拦截HttpServletResponse 。 根据需要检查 HttpServletResponse ，也可以修改HttpServletResponse头和数据。</li>
</ul>
<h5 id="filter链"><a href="#filter链" class="headerlink" title="filter链"></a>filter链</h5><p>在一个web应用中，可以开发编写多个Filter，这些Filter组合起来称之为一个Filter链。<br>web服务器根据Filter在web.xml文件中的注册顺序，决定先调用哪个Filter，当第一个Filter的doFilter方法被调用时，web服务器会创建一个代表Filter链的FilterChain对象传递给该方法。在doFilter方法中，开发人员如果调用了FilterChain对象的doFilter方法，则web服务器会检查FilterChain对象中是否还有filter，如果有，则调用第2个filter，如果没有，则调用目标资源。</p>
<h5 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h5><p>web服务器负责创建和销毁，应用程序启动的时候创建实例，并且调用init方法<br>创建：<code>public void init(FilterConfig filterConfig) throws ServletException;//初始化</code><br>执行：<code>public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException;//拦截请求</code><br>销毁：<code>public void destroy();//销毁</code></p>
<h5 id="FilterConfig接口"><a href="#FilterConfig接口" class="headerlink" title="FilterConfig接口"></a>FilterConfig接口</h5><p>编写filter的时候可以通过filterConfig对象的方法获取filter初始化参数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">String <span class="title">getFilterName</span><span class="params">()</span></span>;<span class="comment">//得到filter的名称。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">String <span class="title">getInitParameter</span><span class="params">(String name)</span></span>;<span class="comment">//返回在部署描述中指定名称的初始化参数的值。如果不存在返回null.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">Enumeration <span class="title">getInitParameterNames</span><span class="params">()</span></span>;<span class="comment">//返回过滤器的所有初始化参数的名字的枚举集合。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ServletContext <span class="title">getServletContext</span><span class="params">()</span></span>;<span class="comment">//返回Servlet上下文对象的引用。</span></span></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>setCharacterEncoding<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>com.myTest.setCharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span><span class="comment">&lt;!--通过FilterConfig类的getInitParameter("paramName")  --&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>setCharacterEncoding<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>指定过滤器所拦截的Servlet名称。<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">dispatcher</span>&gt;</span>指定过滤器所拦截的资源被 Servlet 容器调用的方式，可以是REQUEST,INCLUDE,FORWARD和ERROR之一，默认REQUEST。用户可以设置多个dispatcher子元素用来指定 Filter 对资源的多种调用方式进行拦截。<span class="tag">&lt;/<span class="name">dispatcher</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span></pre></td></tr></table></figure>

<h4 id="listener-监听器"><a href="#listener-监听器" class="headerlink" title="listener 监听器"></a>listener 监听器</h4><p>监听器Listener就是在application,session,request三个对象创建、销毁或者往其中添加修改删除属性时自动执行代码的功能组件。<br>Listener是Servlet的监听器，可以监听客户端的请求，服务端的操作等。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">listener</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>com.listener.class<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span></pre></td></tr></table></figure>
<h5 id="ServletContext监听"><a href="#ServletContext监听" class="headerlink" title="ServletContext监听"></a>ServletContext监听</h5><p>ServletContextListerner接口: 用于对Servlet整个上下文进行监听(创建、销毁)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextInitialized</span><span class="params">(ServletContextEvent sce)</span></span>;<span class="comment">//上下文初始化</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextDestroyed</span><span class="params">(ServletContextEvent sce)</span></span>;<span class="comment">//上下文销毁</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ServletContext <span class="title">getServletContext</span><span class="params">()</span></span>;<span class="comment">//ServletContextEvent事件：取得一个ServletContext（application）对象</span></span></pre></td></tr></table></figure>
<p>ServletContextAttributeListener接口：对Servlet上下文属性的监听(增删改属性)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attributeAdded</span><span class="params">(ServletContextAttributeEvent scab)</span></span>;<span class="comment">//增加属性</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attributeRemoved</span><span class="params">(ServletContextAttributeEvent scab)</span></span>;<span class="comment">//属性删除</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attributeRepalced</span><span class="params">(ServletContextAttributeEvent scab)</span></span>;<span class="comment">//属性替换（第二次设置同一属性）</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//ServletContextAttributeEvent事件：能取得设置属性的名称与内容</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>;<span class="comment">//得到属性名称</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getValue</span><span class="params">()</span></span>;<span class="comment">//取得属性的值</span></span></pre></td></tr></table></figure>

<h5 id="Session监听"><a href="#Session监听" class="headerlink" title="Session监听"></a>Session监听</h5><p>Session属于http协议下的内容，接口位于javax.servlet.http.*包下。<br>HttpSessionListener接口：对Session的整体状态的监听。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sessionCreated</span><span class="params">(HttpSessionEvent se)</span></span>;<span class="comment">//session创建</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sessionDestroyed</span><span class="params">(HttpSessionEvent se)</span></span>;<span class="comment">//session销毁</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//HttpSessionEvent事件：</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> HttpSession <span class="title">getSession</span><span class="params">()</span></span>;<span class="comment">//取得当前操作的session</span></span></pre></td></tr></table></figure>
<p>HttpSessionAttributeListener接口：对session的属性监听。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attributeAdded</span><span class="params">(HttpSessionBindingEvent se)</span></span>;<span class="comment">//增加属性</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attributeRemoved</span><span class="params">(HttpSessionBindingEvent se)</span></span>;<span class="comment">//删除属性</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attributeReplaced</span><span class="params">(HttpSessionBindingEvent se)</span></span>;<span class="comment">//替换属性</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//HttpSessionBindingEvent事件：</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>;<span class="comment">//取得属性的名称</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getValue</span><span class="params">()</span></span>;<span class="comment">//取得属性的值</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> HttpSession <span class="title">getSession</span><span class="params">()</span></span>;<span class="comment">//取得当前的session</span></span></pre></td></tr></table></figure>

<h5 id="request监听"><a href="#request监听" class="headerlink" title="request监听"></a>request监听</h5><p>ServletRequestListener： 用于Request请求进行监听(创建、销毁)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">requestInitialized</span><span class="params">(ServletRequestEvent sre)</span></span>;<span class="comment">//request初始化</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">requestDestroyed</span><span class="params">(ServletRequestEvent sre)</span></span>;<span class="comment">//request销毁</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//ServletRequestEvent事件：</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ServletRequest <span class="title">getServletRequest</span><span class="params">()</span></span>;<span class="comment">//取得一个ServletRequest对象</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ServletContext <span class="title">getServletContext</span><span class="params">()</span></span>;<span class="comment">//取得一个ServletContext（application）对象</span></span></pre></td></tr></table></figure>
<p>ServletRequestAttributeListener: 对Request属性的监听(增删改属性)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attributeAdded</span><span class="params">(ServletRequestAttributeEvent srae)</span></span>;<span class="comment">//增加属性</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attributeRemoved</span><span class="params">(ServletRequestAttributeEvent srae)</span></span>;<span class="comment">//属性删除</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attributeReplaced</span><span class="params">(ServletRequestAttributeEvent srae)</span></span>;<span class="comment">//属性替换（第二次设置同一属性）</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//ServletRequestAttributeEvent事件：能取得设置属性的名称与内容</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>;<span class="comment">//得到属性名称</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getValue</span><span class="params">()</span></span>;<span class="comment">//取得属性的值</span></span></pre></td></tr></table></figure>

<h4 id="servlet"><a href="#servlet" class="headerlink" title="servlet"></a>servlet</h4><p>servlet标签只要有以下子元素：</p>
<ul>
<li>servlet-name指定servlet的名称</li>
<li>servlet-class制定servlet的类名称</li>
<li>jsp-file制定某个jsp网页的完整路径</li>
<li>init-param用来定义参数，可以有多个init-param。在servlet类中通过getInitParamenter(String name)方法初始化参数</li>
<li>load-on-startup 指定当Web应用启动的时候，装载Servlet的次序,当值为正数或零时：Servlet容器先加载数值小的servlet，再依次加载其他数值大的servlet。当值为负或未定义：Servlet容器将在Web客户首次访问这个servlet时加载它。</li>
<li>servlet-mapping 用来定义servlet所对应的URL包含两个子元素</li>
<li>servlet-name 指定servlet的名称</li>
<li>url-parttern 指定servlet所对应的URL<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 基本配置 --&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>snoop<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>SnoopServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>snoop<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/snoop<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 高级配置 --&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>snoop<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>SnoopServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>foo<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>bar<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">run-as</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">description</span>&gt;</span>Security role for anonymous access<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">role-name</span>&gt;</span>tomcat<span class="tag">&lt;/<span class="name">role-name</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;/<span class="name">run-as</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>snoop<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/snoop<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="session-config-会话超时配置"><a href="#session-config-会话超时配置" class="headerlink" title="session-config 会话超时配置"></a>session-config 会话超时配置</h4><p>单位是分钟</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">session-config</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">session-timeout</span>&gt;</span>120<span class="tag">&lt;/<span class="name">session-timeout</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">session-config</span>&gt;</span></span></pre></td></tr></table></figure>

<h4 id="mime-mapping、welcome-file-list、error-page错误页面"><a href="#mime-mapping、welcome-file-list、error-page错误页面" class="headerlink" title="mime-mapping、welcome-file-list、error-page错误页面"></a>mime-mapping、welcome-file-list、error-page错误页面</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mime-mapping</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">extension</span>&gt;</span>htm<span class="tag">&lt;/<span class="name">extension</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">mime-type</span>&gt;</span>text/html<span class="tag">&lt;/<span class="name">mime-type</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">mime-mapping</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">welcome-file-list</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">welcome-file</span>&gt;</span>index.jsp<span class="tag">&lt;/<span class="name">welcome-file</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">welcome-file</span>&gt;</span>index.html<span class="tag">&lt;/<span class="name">welcome-file</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">welcome-file</span>&gt;</span>index.htm<span class="tag">&lt;/<span class="name">welcome-file</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">welcome-file-list</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">error-page</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">error-code</span>&gt;</span>404<span class="tag">&lt;/<span class="name">error-code</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">location</span>&gt;</span>/NotFound.jsp<span class="tag">&lt;/<span class="name">location</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">error-page</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">error-page</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">exception-type</span>&gt;</span>java.lang.NullException<span class="tag">&lt;/<span class="name">exception-type</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">location</span>&gt;</span>/error.jsp<span class="tag">&lt;/<span class="name">location</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">error-page</span>&gt;</span></span></pre></td></tr></table></figure>

<h4 id="jsp-config-设置jsp"><a href="#jsp-config-设置jsp" class="headerlink" title="jsp-config 设置jsp"></a>jsp-config 设置jsp</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">jsp-config</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">taglib</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">taglib-uri</span>&gt;</span>Taglib<span class="tag">&lt;/<span class="name">taglib-uri</span>&gt;</span><span class="comment">&lt;!--jstl标签配置--&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">taglib-location</span>&gt;</span>/WEB-INF/tlds/MyTaglib.tld<span class="tag">&lt;/<span class="name">taglib-location</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;/<span class="name">taglib</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">jsp-property-group</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">description</span>&gt;</span>Special property group for JSP Configuration JSP example.<span class="tag">&lt;/<span class="name">description</span>&gt;</span><span class="comment">&lt;!--设定的说明--&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">display-name</span>&gt;</span>JSPConfiguration<span class="tag">&lt;/<span class="name">display-name</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/jsp/* <span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">el-ignored</span>&gt;</span>true<span class="tag">&lt;/<span class="name">el-ignored</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">page-encoding</span>&gt;</span>GB2312<span class="tag">&lt;/<span class="name">page-encoding</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">scripting-invalid</span>&gt;</span>true<span class="tag">&lt;/<span class="name">scripting-invalid</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">include-prelude</span>&gt;</span>/include/prelude.jspf<span class="tag">&lt;/<span class="name">include-prelude</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">include-coda</span>&gt;</span>/include/coda.jspf<span class="tag">&lt;/<span class="name">include-coda</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;/<span class="name">jsp-property-group</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">jsp-config</span>&gt;</span></span></pre></td></tr></table></figure>


<h3 id="容器加载web-xml和启动过程"><a href="#容器加载web-xml和启动过程" class="headerlink" title="容器加载web.xml和启动过程"></a>容器加载web.xml和启动过程</h3><p>当要启动某个j2ee项目的时候，服务器软件或者容器会第一步加载项目中的web.xml文件，通过其中的各种配置来启动项目，只有其中配置各项<br>均无误的时候，项目才正确启动。<br>web.xml有多响标签，在加载过程中顺序依次为：context-param &gt; listener &gt; filter &gt; servlet</p>
<ol>
<li>web.xml先读取context-param和listen这两个节点；</li>
<li>然后容器创建一个ServletContext，应用于整个项目；</li>
<li>将读取到的context-param转化为键值对并且存入servletContext</li>
<li>根据listener创建监听</li>
<li>容器读取，根据指定的类路径来实例化过滤器</li>
<li>项目初始化完成</li>
<li>发起第一次请求的时候，servlet节点被加载实例化。</li>
</ol>
<p>参考：<a href="http://www.cnblogs.com/hellojava/archive/2012/12/28/2835730.html" target="_blank" rel="noopener">web.xml文件详解</a>、<a href="http://www.imooc.com/article/5385" target="_blank" rel="noopener">Web启动过程及web.xml配置</a>、<a href="https://docs.oracle.com/cd/E13222_01/wls/docs81/webapp/web_xml.html" target="_blank" rel="noopener">web.xml官方文档</a>、<a href="http://www.cnblogs.com/hellojava/archive/2012/12/19/2824444.html" target="_blank" rel="noopener">Filter过滤器</a>、<a href="http://www.cnblogs.com/hellojava/archive/2012/12/26/2833840.html" target="_blank" rel="noopener">Listener监听器</a>、<a href="http://www.runoob.com/jsp/jsp-jstl.html" target="_blank" rel="noopener">JSP标准标签库</a></p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>framework</tag>
      </tags>
  </entry>
  <entry>
    <title>Java关键字</title>
    <url>/2017/04/05/Java%E5%85%B3%E9%94%AE%E5%AD%97/</url>
    <content><![CDATA[<p>Java里面的关键字和相关的知识点</p>
<a id="more"></a>
<h2 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h2><p>final可以声明成员变、方法、类和本地变量。一旦将引用声明为final，这个引用就不能改变了。</p>
<h3 id="final变量"><a href="#final变量" class="headerlink" title="final变量"></a>final变量</h3><p>凡是对成员变量或者本地变量(在方法中的或者代码块中的变量称为本地变量)声明为final的都叫作final变量。final变量经常和static关键字一起使用，作为常量。</p>
<h3 id="final方法"><a href="#final方法" class="headerlink" title="final方法"></a>final方法</h3><p>声明为final 的方法不能被子类的方法重写。<br>final方法比非final方法要快，因为编译的时候已经静态绑定，不需要运行时再动态绑定。</p>
<h3 id="final类"><a href="#final类" class="headerlink" title="final类"></a>final类</h3><p>final修饰的类不能被继承。Java中有String，Integer和其他包装类都是final类。</p>
<h3 id="final关键字的好处"><a href="#final关键字的好处" class="headerlink" title="final关键字的好处"></a>final关键字的好处</h3><ol>
<li>提高性能，JVM和Java应用都会缓存final变量。</li>
<li>可以在安全的多线程环境下进行共享，不需要额外的同步开销。</li>
<li>使用final关键字，JVM会对方法、变量和类进行优化。</li>
</ol>
<h3 id="不可变类"><a href="#不可变类" class="headerlink" title="不可变类"></a>不可变类</h3><p>不可变类是指对象一旦创建就不能更改，要使用final关键字创建。</p>
<h4 id="为什么字符串类需要是不可变的？"><a href="#为什么字符串类需要是不可变的？" class="headerlink" title="为什么字符串类需要是不可变的？"></a>为什么字符串类需要是不可变的？</h4><ul>
<li>实现字符串池，节省heap空间。如果是可变的那么String interning就不能实现了，因为这样的话如果变量改变了他的值，那么这个值的变量的值也会一起改变。</li>
<li>安全问题：比如数据库的用户名密码都是字符串形式传入数据库的连接，可变的话就有风险被篡改。</li>
<li>多线程安全，字符串可以被多个线程共享。</li>
<li>类加载器要用到字符串。比如你想加载java.sql.Connection类，而这个值被改成了myhacked.Connection，那么会对你的数据库造成不可知的破坏。</li>
<li>创建的时候hashcode就被缓存了，不需要重新计算。这使得字符串很适合作为Map中的键，字符串的处理速度要快过其他的键对象。</li>
</ul>
<h4 id="如何写一个不可变类"><a href="#如何写一个不可变类" class="headerlink" title="如何写一个不可变类"></a><a href="http://www.importnew.com/7535.html" target="_blank" rel="noopener">如何写一个不可变类</a></h4><h3 id="其他要点"><a href="#其他要点" class="headerlink" title="其他要点"></a>其他要点</h3><ul>
<li>final成员变量必须在声明的时候初始化或者在构造器中初始化，否则编译报错。</li>
<li>匿名类所有变量必须是final的。</li>
<li>接口中所有变量本身是final的/</li>
<li>final和abstract是冲突的，不能同时使用。</li>
<li>集合对象声明为final，引用不能被更改，但是不影响增删改查内部元素。</li>
</ul>
<p>(来源:<a href="http://www.importnew.com/7553.html" target="_blank" rel="noopener">深入理解Java中的final关键字</a>、<a href="http://www.importnew.com/7440.html" target="_blank" rel="noopener">为什么String类是不可变的</a>)</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>API</tag>
      </tags>
  </entry>
  <entry>
    <title>遇到的小问题合集</title>
    <url>/2017/03/17/%E9%81%87%E5%88%B0%E7%9A%84%E5%B0%8F%E9%97%AE%E9%A2%98%E5%90%88%E9%9B%86/</url>
    <content><![CDATA[<p>记录平时遇到的小问题和踩过的坑，当做备忘。</p>
<a id="more"></a>

<h2 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h2><h3 id="Spring-MVC表单传值中文乱码"><a href="#Spring-MVC表单传值中文乱码" class="headerlink" title="Spring MVC表单传值中文乱码"></a>Spring MVC表单传值中文乱码</h3><p>在web.xml中增加拦截器：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>characterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>characterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span></pre></td></tr></table></figure>


<h3 id="Spring-MVC返回JSON数据"><a href="#Spring-MVC返回JSON数据" class="headerlink" title="Spring MVC返回JSON数据"></a>Spring MVC返回JSON数据</h3><p>只需要添加依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.8.8<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></pre></td></tr></table></figure>

<p>其实试了好几个解析JSON数据的包，但是就这个行了，没搞明白咋回事。</p>
<h2 id="Linux系统"><a href="#Linux系统" class="headerlink" title="Linux系统"></a>Linux系统</h2><h3 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h3><p>免sudo使用docker：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$sudo addgroup --system docker</span></pre></td></tr><tr><td class="code"><pre><span class="line">$sudo adduser $USER docker</span></pre></td></tr><tr><td class="code"><pre><span class="line">$newgrp docker</span></pre></td></tr></table></figure>


<p>在容器中创建虚拟IP的时候，有可能遇到错误：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">IPVS: Can&#39;t initialize ipvs: Protocol not available</span></pre></td></tr></table></figure>

<p>开启的必要条件有两个：</p>
<ol>
<li>容器放开权限，即添加参数<code>--privileged</code></li>
<li>宿主机同样需要开启<code>ipvasdm</code></li>
</ol>
<p>在容器中使用<code>Systemctl</code>命令经常会遇到提示：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl start fdfs_trckerd</span></pre></td></tr><tr><td class="code"><pre><span class="line">Failed to get D-Bus connection: Operation not permitted</span></pre></td></tr></table></figure>

<p>解决办法，用特权模式启动容器：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d -name centos7 --privileged=<span class="literal">true</span> centos:7 /usr/sbin/init</span></pre></td></tr></table></figure>



<h3 id="ssh"><a href="#ssh" class="headerlink" title="ssh"></a>ssh</h3><p>设置免密码ssh登陆的时候，把公钥放到<code>authorized_keys</code>里面，重启ssh service都不生效，百度得知home目录，.ssh目录和authorized_keys文件需要分别为700,700,600权限，错一个都不行，更改权限后可以免密登陆了。</p>
<h3 id="apt-get"><a href="#apt-get" class="headerlink" title="apt-get"></a>apt-get</h3><p>经常遇到apt-get遇到问题卡住之后，出错的地方常年在那摆着，无论干啥都提示一遍，神烦。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &#x2F;var&#x2F;lib&#x2F;dpkg</span></pre></td></tr><tr><td class="code"><pre><span class="line">sudo mv info info.bak</span></pre></td></tr><tr><td class="code"><pre><span class="line">sudo mkdir info</span></pre></td></tr></table></figure>
<p>info删掉就搞定了，原理有待深入研究</p>
<h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><h3 id="Linux下的MySQL安装顺序"><a href="#Linux下的MySQL安装顺序" class="headerlink" title="Linux下的MySQL安装顺序"></a>Linux下的MySQL安装顺序</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rpm -ivh mysql-community-common-5.7.17-1.el7.x86_64.rpm   </span></pre></td></tr><tr><td class="code"><pre><span class="line">rpm -ivh mysql-community-libs-5.7.17-1.el7.x86_64.rpm   </span></pre></td></tr><tr><td class="code"><pre><span class="line">rpm -ivh mysql-community-client-5.7.17-1.el7.x86_64.rpm  </span></pre></td></tr><tr><td class="code"><pre><span class="line">rpm -ivh mysql-community-server-5.7.17-1.el7.x86_64.rpm  </span></pre></td></tr><tr><td class="code"><pre><span class="line">rpm -ivh mysql-community-devel-5.7.17-1.el7.x86_64.rpm</span></pre></td></tr></table></figure>

<p>安装最后一个的时候有可能出现依赖openssl的问题，重新安装openssl无效，输入参数<code>-e --nodeps</code>可以解决，暂不清楚原理</p>
<h3 id="MySQL-8修改用户密码命令"><a href="#MySQL-8修改用户密码命令" class="headerlink" title="MySQL 8修改用户密码命令"></a>MySQL 8修改用户密码命令</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED WITH mysql_native_password BY &#39;新密码&#39;;</span></pre></td></tr></table></figure>

<p>如果提示<code>ERROR 1819 (HY000): Your password does not satisfy the current policy requirements</code></p>
<p>说明密码太简单，经过测试大小写英文字母+数字+标点符号可以满足要求。</p>
<h2 id="IDEA和java"><a href="#IDEA和java" class="headerlink" title="IDEA和java"></a>IDEA和java</h2><h3 id="中文字符问题"><a href="#中文字符问题" class="headerlink" title="中文字符问题"></a>中文字符问题</h3><p>运行Tomcat的时候，Messages Build出现了错误提示：<br><img src="s2.png" alt=""><br>然后中文因为字体的关系不能显示，这里由于实在是喜欢这个字体，不想换成很丑的中文，而且JVM的错误提示还是英文搜索起来比较方便，所以想换成中文。然后发现在终端输入Java命令得到的是中文：<br><img src="s1.png" alt=""><br>这两个应该是相关的。<br>然后修改系统字体：<br><img src="s3.png" alt=""><br>发现可以显示成英文，但是目的是只是Java为英文，所以不想这样。<br>尝试过的方法：</p>
<ul>
<li>在Tomcat的VM option里面添加-Duser.language=en -Duser.country=US<br>  <img src="s4.png" alt=""></li>
<li>在Setting-&gt;BUild,Execution,Deployment-&gt;Compiler中的两个地方添加-Duser.language=en -Duser.country=US<br>  <img src="s5.png" alt=""></li>
<li>在IDEA的安装路径/bin/idea.vmoptions中添加-Duser.language=en -Duser.country=US<br>  <img src="s6.png" alt=""></li>
</ul>
<p>最后发现上面那个配置文件是32位程序的，64位程序不用这个….<br>点击 Help-&gt;Edit Custom VM Option 会生成一个 64 位的配置文件，然后再添加-D 巴拉拉巴拉就行了….<br>害得我V2EX号还被封了…..</p>
<h3 id="JavaFX窗口闪烁问题"><a href="#JavaFX窗口闪烁问题" class="headerlink" title="JavaFX窗口闪烁问题"></a>JavaFX窗口闪烁问题</h3><p>用JavaFX绘制窗口的时候，由于Scene填充成了比较深的颜色，所以每次窗口初始化和大小变化的时候，背景都会出现白色闪烁：</p>
<p><img src="flashing.gif" alt=""><br>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Panel</span> <span class="keyword">extends</span> <span class="title">Application</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> Group root;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> Scene scene;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Color BACKGROUND_COLOR = Color.rgb(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0.5</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> Stage stage;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(Stage primaryStage)</span> <span class="keyword">throws</span> Exception </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        root = <span class="keyword">new</span> Group();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        stage = primaryStage;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        primaryStage.initStyle(StageStyle.TRANSPARENT);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        scene = <span class="keyword">new</span> Scene(root, <span class="number">1000</span>, <span class="number">250</span>, BACKGROUND_COLOR);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Screen screen = Screen.getScreens().get(<span class="number">0</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">double</span> windowHeight = screen.getBounds().getHeight();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">double</span> windowWidth = screen.getBounds().getWidth();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        stage.setY(windowHeight + <span class="number">1000</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        stage.setX(windowWidth - <span class="number">1000</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        stage.setScene(scene);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        stage.show();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Timer timer = <span class="keyword">new</span> Timer();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span>[] index = &#123;<span class="number">0</span>&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        timer.schedule(<span class="keyword">new</span> TimerTask() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="meta">@Override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                System.out.println(<span class="string">"111"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                index[<span class="number">0</span>]++;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                primaryStage.setY(primaryStage.getY() - <span class="number">1</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                primaryStage.setHeight(primaryStage.getHeight() + <span class="number">1</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">if</span> (index[<span class="number">0</span>] == <span class="number">300</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    <span class="keyword">this</span>.cancel();</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;, <span class="number">1000</span>, <span class="number">1</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>浪费了大概一天的时间…查找各种文档，教学，试了好多方法还是不行。<br>一开始以为我填充的区域不对，不是最底层的，后来以为是填充背景色时间不对，跟底层绘制时间差距太大导致出现闪烁，但是不能解决。最后还是在万能的Google上找到了一个向jdk开发人员反馈的帖子：<br><a href="https://bugs.openjdk.java.net/browse/JDK-8088179" target="_blank" rel="noopener">White flashing when opening a stage with dark background</a><br>原来是个Bug…窗口初始化的时候默认填充了白色。<br>第一次碰到jdk级别的Bug还有点小激动。跟着帖子看到的修复信息：<br><a href="http://hg.openjdk.java.net/openjfx/9-dev/rt/rev/bfe35c702696" target="_blank" rel="noopener">changeset 10131:bfe35c702696 jdk-9+145</a><br>解决方法是取得了子节点的颜色再填充的，修复的版本是9…所以只好下了个预览版的jdk9<br>最后要记住这个网站：<a href="https://bugs.openjdk.java.net" target="_blank" rel="noopener">https://bugs.openjdk.java.net</a>，可以向jdk的开发组反馈遇到的问题～</p>
<h3 id="修改Maven中央仓库"><a href="#修改Maven中央仓库" class="headerlink" title="修改Maven中央仓库"></a>修改Maven中央仓库</h3><p>.m2文件夹下新建文件settings.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/SETTINGS/1.0.0"</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">  <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/SETTINGS/1.0.0</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag"><span class="string">                      https://maven.apache.org/xsd/settings-1.0.0.xsd"</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mirrors</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">id</span>&gt;</span>alimaven<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">name</span>&gt;</span>aliyun maven<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">mirrors</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span></pre></td></tr></table></figure>

<p>其他设置参考<a href="https://maven.apache.org/settings.html" target="_blank" rel="noopener">官方文档</a></p>
<h2 id="其他工具"><a href="#其他工具" class="headerlink" title="其他工具"></a>其他工具</h2><h3 id="Hexo的git问题"><a href="#Hexo的git问题" class="headerlink" title="Hexo的git问题"></a>Hexo的git问题</h3><p>写完博客，上传到服务器的时候，出现了错误：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FATAL Permission denied (publickey).</span></pre></td></tr><tr><td class="code"><pre><span class="line">fatal: Could not read from remote repository.</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">Please make sure you have the correct access rights</span></pre></td></tr><tr><td class="code"><pre><span class="line">and the repository exists.</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">Error: Permission denied (publickey).</span></pre></td></tr><tr><td class="code"><pre><span class="line">fatal: Could not read from remote repository.</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">Please make sure you have the correct access rights</span></pre></td></tr><tr><td class="code"><pre><span class="line">and the repository exists.</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    at ChildProcess.&lt;anonymous&gt; (&#x2F;home&#x2F;ray&#x2F;文档&#x2F;笔记&#x2F;Blogs&#x2F;node_modules&#x2F;hexo-util&#x2F;lib&#x2F;spawn.js文档&#x2F;笔记&#x2F;Blogs&#x2F;node_modules&#x2F;hexo-util&#x2F;lib&#x2F;spawn.js:37:17)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    at emitTwo (events.js:87:13)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    at ChildProcess.emit (events.js:172:7)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    at maybeClose (internal&#x2F;child_process.js:821:16)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    at Socket.&lt;anonymous&gt; (internal&#x2F;child_process.js:319:11)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    at emitOne (events.js:77:13)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    at Socket.emit (events.js:169:7)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    at Pipe._onclose (net.js:469:12)</span></pre></td></tr></table></figure>
<p>试了试github能登上，也能push，把hexo的配置文件里面关于git的配置，ssh改成了https,就能成功上传代码了，原因不明。每次都得输入账号密码，这也不是办法。</p>
]]></content>
      <categories>
        <category>问题</category>
      </categories>
      <tags>
        <tag>问题</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串匹配算法</title>
    <url>/2017/03/07/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>刷题的时候遇到的几个与字符串匹配相关的算法。</p>
<a id="more"></a>

<h2 id="搜索子字符串"><a href="#搜索子字符串" class="headerlink" title="搜索子字符串"></a>搜索子字符串</h2><h3 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h3><p>首先是比较出名的KMP算法</p>
<h3 id="Sunday算法"><a href="#Sunday算法" class="headerlink" title="Sunday算法"></a>Sunday算法</h3><p>主要思想：匹配失败的时候关注的是参与匹配的最末位字符的下一个字符。<br>这个字符如果没有出现在下面字符串里，就直接向右移动字符串长度+1位。<br>如果出现，就移动字符串长度-出现位置位。<br>比如，要在substring searching algorithm中搜索algorithm，先从头匹配：<br><img src="s1.png" alt=""><br>显然不符合，然后直接跳到最末位的下一个，空格没有出现在下面字符串里<br><img src="s2.png" alt=""><br>不符合，接着找下一个<br><img src="s3.png" alt=""><br>g出现了，在下标为2的位置，所以右移9-2=7位<br><img src="s4.png" alt=""><br>显然还是不行，然后再去找下一个，i出现了，在下标5的位置，所以右移4个<br><img src="s5.png" alt=""><br>经验证符合要求。<br>java代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">searchStr</span><span class="params">(String patternString, String str)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="keyword">if</span> (patternString.equals(<span class="string">""</span>) || str.equals(<span class="string">""</span>)||str.length()&gt;patternString.length())</span></pre></td></tr><tr><td class="code"><pre><span class="line">           <span class="keyword">return</span> -<span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="keyword">char</span>[] pattern = patternString.toCharArray();</span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="keyword">char</span>[] s = str.toCharArray();</span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="keyword">int</span> strIndex;</span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pattern.length;) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">           strIndex = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">           <span class="keyword">while</span> (strIndex &lt; s.length) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">               <span class="keyword">if</span>(pattern[i + strIndex] != s[strIndex]) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                   i+=strIndex;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                   <span class="keyword">break</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">               &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">               <span class="keyword">if</span>(strIndex==s.length-<span class="number">1</span>)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                   <span class="keyword">return</span> i;</span></pre></td></tr><tr><td class="code"><pre><span class="line">               &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">               strIndex++;</span></pre></td></tr><tr><td class="code"><pre><span class="line">           &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">           <span class="keyword">if</span> (i + <span class="number">1</span> &lt; pattern.length) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">               <span class="keyword">int</span> charIndex=findChar(s,pattern[i+s.length]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">               <span class="keyword">if</span>(charIndex==-<span class="number">1</span>)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                   i+=s.length+<span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">               &#125;<span class="keyword">else</span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                   i+=s.length-charIndex;</span></pre></td></tr><tr><td class="code"><pre><span class="line">               &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">           &#125; <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">               <span class="keyword">return</span> -<span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">           &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">       &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="keyword">return</span> -<span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">   &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">private</span>  <span class="keyword">int</span> <span class="title">findChar</span><span class="params">(<span class="keyword">char</span>[] c,<span class="keyword">char</span> search)</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;c.length;i++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">          <span class="keyword">if</span>(c[i]==search)</span></pre></td></tr><tr><td class="code"><pre><span class="line">              <span class="keyword">return</span> i;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">return</span>  -<span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">   &#125;</span></pre></td></tr></table></figure>
<h2 id="最长回文子串"><a href="#最长回文子串" class="headerlink" title="最长回文子串"></a>最长回文子串</h2><h3 id="暴力求解"><a href="#暴力求解" class="headerlink" title="暴力求解"></a>暴力求解</h3><p>三层循环，外层遍历字符串，中层遍历子串，三层判定是否回文</p>
<h3 id="中心扩散法"><a href="#中心扩散法" class="headerlink" title="中心扩散法"></a>中心扩散法</h3><p>先循环找到相邻且相等的，或者间隔一个且相等两个字符，然后向外扩展找到最长<br>时间复杂度n²</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// Write your code here</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (s.equals(<span class="string">""</span>) || s.length() == <span class="number">1</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span> s;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">char</span>[] result = &#123;&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">char</span>[] charArray = s.toCharArray();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (i + <span class="number">1</span> &lt; s.length() &amp;&amp; charArray[i] == charArray[i + <span class="number">1</span>]) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                result = result.length &lt;= <span class="number">2</span> ? Arrays.copyOfRange(charArray, i, i + <span class="number">2</span>) : result;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= s.length() / <span class="number">2</span>; j++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    <span class="keyword">if</span> (i - j+<span class="number">1</span> &gt; <span class="number">0</span> &amp;&amp; i + j + <span class="number">1</span> &lt; s.length() &amp;&amp; charArray[i - j] == charArray[i + j + <span class="number">1</span>]) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                        result = result.length &lt; (<span class="number">2</span> * j + <span class="number">2</span>) ? Arrays.copyOfRange(charArray, i - j, i + j + <span class="number">2</span>) : result;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                        <span class="keyword">break</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (i + <span class="number">2</span> &lt; s.length() &amp;&amp; charArray[i] == charArray[i + <span class="number">2</span>]) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                result = result.length &lt;= <span class="number">3</span> ? Arrays.copyOfRange(charArray, i, i + <span class="number">3</span>) : result;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= s.length() / <span class="number">2</span>; j++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    <span class="keyword">if</span> (i - j+<span class="number">1</span> &gt; <span class="number">0</span> &amp;&amp; i + j + <span class="number">2</span> &lt; s.length() &amp;&amp; charArray[i - j] == charArray[i + j + <span class="number">2</span>]) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                        result = result.length &lt; (<span class="number">2</span> * j + <span class="number">3</span>) ? Arrays.copyOfRange(charArray, i - j, i + j + <span class="number">3</span>) : result;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                        <span class="keyword">break</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String(result);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr></table></figure>
<h3 id="Manacher算法"><a href="#Manacher算法" class="headerlink" title="Manacher算法"></a>Manacher算法</h3><p>先对字符串预处理，每个字符中间添加特殊符号比如#<br>然后引入数组P[i]代表以字符S[i]为中心的最长回文子串向左/右扩张的长度（包括S[i]）<br>S[]<code>ghaweuifhwe123454321fahwu</code>-&gt;<br>S[]<code>#g#h#a#w#e#u#i#f#h#w#e#1#2#1#4#4#1#2#1#f#a#h#w#u#</code><br>P[] 1212121212121212121212121412129212141212121212121<br>可以看出P[i]-1就是原字符串中回文子串的长度，比如12144241中对应的9-1，121对应4-1，所以需要求P[]最大值</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>LintCode记录</title>
    <url>/2017/03/01/LintCode%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<p>记录刷的那些麻烦的题 </p>
<a id="more"></a>

<h2 id="二叉树的所有路径："><a href="#二叉树的所有路径：" class="headerlink" title="二叉树的所有路径："></a>二叉树的所有路径：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * Definition of TreeNode:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> *     public int val;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> *     public TreeNode left, right;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> *     public TreeNode(int val) &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> *         this.val = val;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> *         this.left = this.right = null;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> *     &#125;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * &#125;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//递归解法：</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List <span class="title">binaryTreePaths</span><span class="params">(TreeNode root)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    List&lt;String&gt; leftList=<span class="keyword">new</span> ArrayList&lt;&gt;();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span>(root==<span class="keyword">null</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> leftList;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span>(root.left!=<span class="keyword">null</span>)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span>(String list:binaryTreePaths(root.left))</span></pre></td></tr><tr><td class="code"><pre><span class="line">            leftList.add(root.val+<span class="string">"-&gt;"</span>+list);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span>(root.right!=<span class="keyword">null</span>)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span>(String list:binaryTreePaths(root.right))</span></pre></td></tr><tr><td class="code"><pre><span class="line">            leftList.add(root.val+<span class="string">"-&gt;"</span>+list);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span>(root.right==<span class="keyword">null</span>&amp;&amp;root.left==<span class="keyword">null</span>)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        leftList.add(String.valueOf(root.val));</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> leftList;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//非递归解法：</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> List <span class="title">binaryTreePaths</span><span class="params">(TreeNode root)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    List list=<span class="keyword">new</span> ArrayList&lt;&gt;();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span>(root==<span class="keyword">null</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">return</span> list;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">boolean</span> down=<span class="keyword">true</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Stack stack=<span class="keyword">new</span> Stack&lt;&gt;();</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Stack result=<span class="keyword">new</span> Stack&lt;&gt;();</span></pre></td></tr><tr><td class="code"><pre><span class="line">  TreeNode test=root;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span>(test.left!=<span class="keyword">null</span>&amp;&amp;test.right!=<span class="keyword">null</span>)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">if</span>(down)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span>(test==root)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">          result.push(String.valueOf(test.val));</span></pre></td></tr><tr><td class="code"><pre><span class="line">          result.push(String.valueOf(test.val));</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">else</span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">          String str=result.pop();</span></pre></td></tr><tr><td class="code"><pre><span class="line">          result.push(str+<span class="string">"-&gt;"</span>+String.valueOf(test.val));</span></pre></td></tr><tr><td class="code"><pre><span class="line">          result.push(str+<span class="string">"-&gt;"</span>+String.valueOf(test.val));</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        stack.push(test);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        test=test.left;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        down=<span class="keyword">true</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;<span class="keyword">else</span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">          result.push(String.valueOf(result.pop()));</span></pre></td></tr><tr><td class="code"><pre><span class="line">          test=test.right;</span></pre></td></tr><tr><td class="code"><pre><span class="line">          down=<span class="keyword">true</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125;<span class="keyword">else</span> <span class="keyword">if</span>(test.left!=<span class="keyword">null</span>)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span>(test==root)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">          result.push(String.valueOf(test.val));</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;<span class="keyword">else</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">          result.push(result.pop()+<span class="string">"-&gt;"</span>+String.valueOf(test.val));</span></pre></td></tr><tr><td class="code"><pre><span class="line">          test=test.left;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(test.right!=<span class="keyword">null</span>)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span>(test==root)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                result.push(String.valueOf(test.val));</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;<span class="keyword">else</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                result.push(result.pop()+<span class="string">"-&gt;"</span>+String.valueOf(test.val));</span></pre></td></tr><tr><td class="code"><pre><span class="line">                test=test.right;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;<span class="keyword">else</span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span>(test==root)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                list.add(String.valueOf(test.val));</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;<span class="keyword">else</span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                list.add(result.pop()+<span class="string">"-&gt;"</span>+String.valueOf(test.val));</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span>(stack.empty())</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">break</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            test=stack.pop();</span></pre></td></tr><tr><td class="code"><pre><span class="line">            down=<span class="keyword">false</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> list;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h2 id="动态规划：上楼问题。一次一个或者两个台阶，上N层楼。"><a href="#动态规划：上楼问题。一次一个或者两个台阶，上N层楼。" class="headerlink" title="动态规划：上楼问题。一次一个或者两个台阶，上N层楼。"></a>动态规划：上楼问题。一次一个或者两个台阶，上N层楼。</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 递归：消耗太大，简直变态</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     * <span class="doctag">@param</span> n: An integer</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     * <span class="doctag">@return</span>: An integer</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(n==<span class="number">1</span>)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(n==<span class="number">2</span>)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;<span class="keyword">else</span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// write your code here</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> climbStairs(n-<span class="number">1</span>)+climbStairs(n-<span class="number">2</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 非递归解法：</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     * <span class="doctag">@param</span> n: An integer</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     * <span class="doctag">@return</span>: An integer</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(n==<span class="number">1</span>)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(n==<span class="number">2</span>)&#123;<span class="keyword">return</span> <span class="number">2</span>;&#125;<span class="keyword">else</span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> last=<span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> swap;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> result=<span class="number">2</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n-<span class="number">2</span>;i++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            swap=result;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            result+=last;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            last=swap;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> result;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h2 id="非递归的二叉树后序遍历"><a href="#非递归的二叉树后序遍历" class="headerlink" title="非递归的二叉树后序遍历"></a>非递归的二叉树后序遍历</h2><p>应该还有更简洁的方式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * Definition of TreeNode:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> *     public int val;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> *     public TreeNode left, right;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> *     public TreeNode(int val) &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> *         this.val = val;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> *         this.left = this.right = null;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> *     &#125;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * &#125;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     * <span class="doctag">@param</span> root: The root of binary tree.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     * <span class="doctag">@return</span>: Postorder in ArrayList which contains node values.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ArrayList list=<span class="keyword">new</span> ArrayList();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        TreeNode node=root;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span> list;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Stack&lt;TreeNode&gt; stack=<span class="keyword">new</span> Stack&lt;&gt;();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">boolean</span> down=<span class="keyword">true</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Stack&lt;TreeNode&gt; last=<span class="keyword">new</span> Stack&lt;&gt;();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        last.push(<span class="keyword">new</span> TreeNode(<span class="number">0</span>));</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span>(node.left!=<span class="keyword">null</span>&amp;&amp;node.right!=<span class="keyword">null</span>)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">if</span>(down)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    stack.push(node);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    stack.push(node);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    node=node.left;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    down=<span class="keyword">true</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &#125;<span class="keyword">else</span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    <span class="keyword">if</span>(node==last.peek())&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                        list.add(node.val);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                         <span class="keyword">if</span>(stack.empty())</span></pre></td></tr><tr><td class="code"><pre><span class="line">                            <span class="keyword">break</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                        node=stack.pop();</span></pre></td></tr><tr><td class="code"><pre><span class="line">                        last.pop();</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                        last.push(node);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                        node=node.right;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                        down=<span class="keyword">true</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(node.left!=<span class="keyword">null</span>)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">if</span>(down)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    stack.push(node);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    node=node.left;down=<span class="keyword">true</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &#125;<span class="keyword">else</span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    list.add(node.val);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    <span class="keyword">if</span>(stack.empty())</span></pre></td></tr><tr><td class="code"><pre><span class="line">                            <span class="keyword">break</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    node=stack.pop();</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(node.right!=<span class="keyword">null</span>)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">if</span>(down)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    stack.push(node);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                     node=node.right;down=<span class="keyword">true</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &#125;<span class="keyword">else</span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    list.add(node.val);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    <span class="keyword">if</span>(stack.empty())</span></pre></td></tr><tr><td class="code"><pre><span class="line">                            <span class="keyword">break</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    node=stack.pop();</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;<span class="keyword">else</span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                list.add(node.val);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">if</span>(stack.empty())</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    <span class="keyword">break</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                node=stack.pop();</span></pre></td></tr><tr><td class="code"><pre><span class="line">                down=<span class="keyword">false</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> list;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h2 id="二叉树的复制-非递归"><a href="#二叉树的复制-非递归" class="headerlink" title="二叉树的复制 非递归"></a>二叉树的复制 非递归</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     * <span class="doctag">@param</span> root: The root of binary tree</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     * <span class="doctag">@return</span> root of new tree</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">cloneTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        TreeNode another=<span class="keyword">new</span> TreeNode(root.val);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        TreeNode test=root;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        TreeNode test2=another;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">boolean</span> down=<span class="keyword">true</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Stack&lt;TreeNode&gt; stack1=<span class="keyword">new</span> Stack&lt;&gt;();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Stack&lt;TreeNode&gt; stack2=<span class="keyword">new</span> Stack&lt;&gt;();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span>(test.left!=<span class="keyword">null</span>&amp;&amp;test.right!=<span class="keyword">null</span>)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">if</span>(down)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    stack1.push(test);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    stack2.push(test2);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    test2.left=<span class="keyword">new</span> TreeNode(test.left.val);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    test=test.left;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    test2=test2.left;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    <span class="keyword">continue</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &#125;<span class="keyword">else</span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    test2.right=<span class="keyword">new</span> TreeNode(test.right.val);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    test=test.right;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    test2=test2.right;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    down=<span class="keyword">true</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    <span class="keyword">continue</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(test.left!=<span class="keyword">null</span>)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                test2.left=<span class="keyword">new</span> TreeNode(test.left.val);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                test=test.left;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                test2=test2.left;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(test.right!=<span class="keyword">null</span>)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                test2.right=<span class="keyword">new</span> TreeNode(test.right.val);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                test=test.right;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                test2=test2.right;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;<span class="keyword">else</span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">if</span>(stack1.empty())</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    <span class="keyword">break</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                test=stack1.pop();</span></pre></td></tr><tr><td class="code"><pre><span class="line">                test2=stack2.pop();</span></pre></td></tr><tr><td class="code"><pre><span class="line">                down=<span class="keyword">false</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> another;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><p>本来是很简单的问题，但是不知道position为啥要减一，回头再看.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">         <span class="keyword">if</span> (nums == <span class="keyword">null</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> position = nums.length;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span>[] temp = nums;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">int</span> len = temp.length;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (len == <span class="number">2</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">if</span> (temp[<span class="number">0</span>] == target)</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    <span class="keyword">return</span> position - <span class="number">2</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(temp[<span class="number">1</span>] == target)</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    <span class="keyword">return</span> position-<span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">else</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                    <span class="keyword">return</span> -<span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (len == <span class="number">1</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">if</span>(temp[<span class="number">0</span>]==target)</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    <span class="keyword">return</span> position-<span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">else</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                    <span class="keyword">return</span> -<span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            len = len / <span class="number">2</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (temp[len] &gt;= target) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                position = position-temp.length+len+<span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                temp = Arrays.copyOfRange(temp, <span class="number">0</span>, len + <span class="number">1</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125; <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                temp = Arrays.copyOfRange(temp, len + <span class="number">1</span>, temp.length);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr></table></figure>

<h2 id="二叉树的层次遍历"><a href="#二叉树的层次遍历" class="headerlink" title="二叉树的层次遍历"></a>二叉树的层次遍历</h2><p>一层一层的输出二叉树： 基本解法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="comment">// write your code here</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">       ArrayList&lt;ArrayList&lt;Integer&gt;&gt; result=<span class="keyword">new</span> ArrayList&lt;&gt;();</span></pre></td></tr><tr><td class="code"><pre><span class="line">       ArrayList&lt;Integer&gt; list=<span class="keyword">new</span> ArrayList&lt;&gt;();</span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="keyword">if</span>(root==<span class="keyword">null</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">           <span class="keyword">return</span> result;</span></pre></td></tr><tr><td class="code"><pre><span class="line">       TreeNode currentNode=root;</span></pre></td></tr><tr><td class="code"><pre><span class="line">       Queue queue=<span class="keyword">new</span> LinkedList();</span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="keyword">int</span> index=<span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="keyword">int</span> index2=<span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">           list.add(currentNode.val);</span></pre></td></tr><tr><td class="code"><pre><span class="line">           <span class="keyword">if</span>(currentNode.left!=<span class="keyword">null</span>)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">               queue.add(currentNode.left);</span></pre></td></tr><tr><td class="code"><pre><span class="line">               index2++;</span></pre></td></tr><tr><td class="code"><pre><span class="line">           &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">           <span class="keyword">if</span>(currentNode.right!=<span class="keyword">null</span>)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">               queue.add(currentNode.right);</span></pre></td></tr><tr><td class="code"><pre><span class="line">               index2++;</span></pre></td></tr><tr><td class="code"><pre><span class="line">           &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">           <span class="keyword">if</span>(index==<span class="number">0</span>)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">               index=index2;</span></pre></td></tr><tr><td class="code"><pre><span class="line">               index2=<span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">               result.add(<span class="keyword">new</span> ArrayList(list));</span></pre></td></tr><tr><td class="code"><pre><span class="line">               list.clear();</span></pre></td></tr><tr><td class="code"><pre><span class="line">               <span class="keyword">if</span>(queue.isEmpty())</span></pre></td></tr><tr><td class="code"><pre><span class="line">                   <span class="keyword">break</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">           &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">           currentNode=(TreeNode)queue.remove();</span></pre></td></tr><tr><td class="code"><pre><span class="line">           index--;</span></pre></td></tr><tr><td class="code"><pre><span class="line">       &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="keyword">return</span> result;</span></pre></td></tr><tr><td class="code"><pre><span class="line">   &#125;</span></pre></td></tr></table></figure>

<h2 id="二叉树的路径和"><a href="#二叉树的路径和" class="headerlink" title="二叉树的路径和"></a>二叉树的路径和</h2><p>我觉得我的智商有问题…</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; binaryTreePathSum(TreeNode root, <span class="keyword">int</span> target) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        TreeNode node = root;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        List&lt;List&lt;Integer&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span> list;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (target == node.val) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (node.left == <span class="keyword">null</span> &amp;&amp; node.right == <span class="keyword">null</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                List l = <span class="keyword">new</span> ArrayList();</span></pre></td></tr><tr><td class="code"><pre><span class="line">                l.add(node.val);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                list.add(l);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">return</span> list;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (target &lt; node.val&amp;&amp;node.left == <span class="keyword">null</span> &amp;&amp; node.right == <span class="keyword">null</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">           List  l = binaryTreePathSum(node.left, target - node.val);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (l != <span class="keyword">null</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; l.size(); i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                List ll = (List) l.get(i);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                List lll = <span class="keyword">new</span> ArrayList();</span></pre></td></tr><tr><td class="code"><pre><span class="line">                lll.add(node.val);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                lll.addAll(ll);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                list.add(lll);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            List l = binaryTreePathSum(node.right, target - node.val);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (l != <span class="keyword">null</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; l.size(); i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                List ll = (List) l.get(i);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                List lll = <span class="keyword">new</span> ArrayList();</span></pre></td></tr><tr><td class="code"><pre><span class="line">                lll.add(node.val);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                lll.addAll(ll);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                list.add(lll);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">          <span class="keyword">return</span> list;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr></table></figure>

<p>几个出错了的点：</p>
<ul>
<li>没考虑负数</li>
<li><code>new ArrayList(i)</code>的参数i不是初始值，是initCapacity初始容量</li>
</ul>
<h2 id="二叉查找树的删除元素"><a href="#二叉查找树的删除元素" class="headerlink" title="二叉查找树的删除元素"></a>二叉查找树的删除元素</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">removeNode</span><span class="params">(TreeNode root, <span class="keyword">int</span> value)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="comment">// write your code here</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">           <span class="keyword">return</span> <span class="keyword">null</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="keyword">if</span>(root.val==value)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">           <span class="keyword">if</span>(root.left!=<span class="keyword">null</span>)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">               TreeNode retuNode=root;</span></pre></td></tr><tr><td class="code"><pre><span class="line">               root=root.left;</span></pre></td></tr><tr><td class="code"><pre><span class="line">               TreeNode max=root;</span></pre></td></tr><tr><td class="code"><pre><span class="line">               <span class="keyword">while</span>(max.right!=<span class="keyword">null</span>)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                   max=max.right;</span></pre></td></tr><tr><td class="code"><pre><span class="line">               &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">               max.right=retuNode.right;</span></pre></td></tr><tr><td class="code"><pre><span class="line">               <span class="keyword">return</span> root;</span></pre></td></tr><tr><td class="code"><pre><span class="line">           &#125;<span class="keyword">else</span> <span class="keyword">if</span>(root.right!=<span class="keyword">null</span>)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">               root=root.right;</span></pre></td></tr><tr><td class="code"><pre><span class="line">               <span class="keyword">return</span> root;</span></pre></td></tr><tr><td class="code"><pre><span class="line">           &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">           <span class="keyword">return</span> <span class="keyword">null</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">       &#125;<span class="keyword">else</span> <span class="keyword">if</span>(value&lt;root.val)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">           root.left=removeNode(root.left,value);</span></pre></td></tr><tr><td class="code"><pre><span class="line">           <span class="keyword">return</span> root;</span></pre></td></tr><tr><td class="code"><pre><span class="line">       &#125;<span class="keyword">else</span> <span class="keyword">if</span>(value&gt;root.val)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">           root.right=removeNode(root.right,value);</span></pre></td></tr><tr><td class="code"><pre><span class="line">           <span class="keyword">return</span> root;</span></pre></td></tr><tr><td class="code"><pre><span class="line">       &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">   &#125;</span></pre></td></tr></table></figure>

<h2 id="最长无重复字符的子串"><a href="#最长无重复字符的子串" class="headerlink" title="最长无重复字符的子串"></a>最长无重复字符的子串</h2><p>这个简单，不过就是不知道使用了hashmap的话,时间复杂度应该怎么算</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// write your code here</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="keyword">if</span> (s.equals(<span class="string">""</span>)) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">char</span>[] c = s.toCharArray();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> end = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> length = <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        HashSet set = <span class="keyword">new</span> HashSet();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">while</span> (end &lt; c.length) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">boolean</span> added = set.add(c[end]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            length = set.size() &gt; length ? set.size() : length;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (!added) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">while</span> (c[start] != c[end]) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    set.remove(c[start]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    start++;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                start++;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            end++;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> length;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>计算机基础</tag>
        <tag>数据结构</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>奇奇怪怪的面试题记录</title>
    <url>/2017/02/27/%E5%A5%87%E5%A5%87%E6%80%AA%E6%80%AA%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<p>好几次碰到已经刷过的奇怪的题，还是想不起来，所以还是好记性不如烂笔头，都记下来面试之前看一遍好了。</p>
<a id="more"></a>

<h1 id="语言特性"><a href="#语言特性" class="headerlink" title="语言特性"></a>语言特性</h1><h2 id="不借助中间变量，交换字符串"><a href="#不借助中间变量，交换字符串" class="headerlink" title="不借助中间变量，交换字符串"></a>不借助中间变量，交换字符串</h2><p>要用到三次亦或：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a=<span class="number">5555</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> b=<span class="number">6666</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">a^=b;</span></pre></td></tr><tr><td class="code"><pre><span class="line">b^=a;</span></pre></td></tr><tr><td class="code"><pre><span class="line">a^=b;</span></pre></td></tr><tr><td class="code"><pre><span class="line">System.out.println(a+<span class="string">" "</span>+b);</span></pre></td></tr></table></figure>
<p>Java不能字符串的亦或操作，用数字表示了，好像c可以？？</p>
<h2 id="Java类型转换"><a href="#Java类型转换" class="headerlink" title="Java类型转换"></a>Java类型转换</h2><p>今天犯了个错，char转int直接强转，然后得到了Unicode。<br>可以<code>Integer.parseInt(&#39;x&#39;+&quot;&quot;)</code>转成string再转换<br>或者<code>Character</code>的静态方法:<code>Character.getNumericValue((int)&#39;5&#39;)</code>  </p>
<p>今天发现个好玩的事情，测试一个回文字符串算法，重复十亿次看时间，发现二十个字符和十个字符好时差别不大，四十个和二十个却有十倍的差距，我猜应该是虚拟机对段字符串有优化，留个坑改天详细研究。</p>
<h2 id="Java语言基础"><a href="#Java语言基础" class="headerlink" title="Java语言基础"></a>Java语言基础</h2><h3 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h3><h3 id="static关键字"><a href="#static关键字" class="headerlink" title="static关键字"></a>static关键字</h3><h4 id="静态变量"><a href="#静态变量" class="headerlink" title="静态变量"></a>静态变量</h4><p>同一个类在内存中只有同一个拷贝，可以用类名直接访问，也可以通过对象访问（不推荐）</p>
<h4 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h4><p>可以通过类名调用，任何势力都可以调用，所以静态方法中不能有this和super关键字。静态方法必须被实现，不能是abstract。</p>
<h4 id="静态代码块"><a href="#静态代码块" class="headerlink" title="静态代码块"></a>静态代码块</h4><p>JVM加载类的时候按照出现的先后顺序执行，每个代码块只被执行一次。</p>
<h4 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h4><ul>
<li>一个内部类如果想要有静态的成员变量或者成员方法，那他本身必须是static关键字修饰的。</li>
<li>静态内部类只能访问外部的静态方法和变量，非静态的不能访问，这是静态内部类最大的使用限制，普通的非静态内部类没有这个限制。<h4 id="静态导包"><a href="#静态导包" class="headerlink" title="静态导包"></a>静态导包</h4>导入静态方法，简化操作，比如：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.System.out</span></pre></td></tr><tr><td class="code"><pre><span class="line">out.println(<span class="string">"text"</span>);</span></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1>]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>用github.pages和Hexo搭建个人博客</title>
    <url>/2017/02/24/Article/</url>
    <content><![CDATA[<p>最近深感进步速度太慢，希望能养成写博客的习惯，不断总结学习。<br>之前都是想在 Atom 上本地写写，后来用手机或者在别的地方看起来不方便，于是决定自己用比较现成的 github.pages+Hexo 解决，顺便玩玩 github。</p>
<a id="more"></a>
<p>基本的搭建过程网上教程一大把，不在赘述，也没啥技术含量，主要记录个人遇到的几个坑</p>
<ol>
<li><p>Repository name 一定要是 <em>username</em>.github.id  </p>
</li>
<li><p>生成ssh-key的时候，因为之前gitlab上用了一套，然后开始以为不能用同一个，就找了条命令：<code>ssh-keygen -t rsa -C &quot;xxx@xxx.com&quot; -f ~/.ssh/github</code>(后来发现默认的命令也会让你填写保存的文件名称)，然后发现没卵用…仍然是 permission denied  </p>
</li>
<li><p>然后看到人说是 root 用户的问题，看了下自己用的，果然是 root 用户，马上切回到普通用户，生成一遍，还是不行…  </p>
</li>
<li><p>再回头翻了翻 github 的帮助，发现可以不用生成新的 key：</p>
<blockquote>
<p>1、Start the ssh-agent in the background.<br>$ eval “$(ssh-agent -s)”<br>$ Agent pid 59566<br>2、Add your SSH key to the ssh-agent. If you are using an existing SSH key rather than generating a new SSH key, you’ll need to replace id_rsa in the command with the name of your existing private key file.<br>$ ssh-add ~/.ssh/id_rsa</p>
</blockquote>
</li>
<li><p>终于搞定基本的连接，开始搭Hexo，deployer的时候,出现了错误:<code>error deployer not found:git</code><br>在 v2ex 上找到了解决办法：<a href="https://www.v2ex.com/t/175940" target="_blank" rel="noopener">搭建 hexo，在执行 hexo deploy 后,出现 error deployer not found:github 的错误</a>。</p>
<blockquote>
<p>npm install hexo-deployer-git –save 改了之后执行，然后再部署试试</p>
</blockquote>
<p>顺便安利下这个 v2ex 还是个挺不错的程序员社区  </p>
</li>
<li><p>搞了大半夜折腾了个 Next.mist 主题…我发誓再也不做美化界面的事…</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Blog</category>
      </categories>
      <tags>
        <tag>Github</tag>
        <tag>Blog</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>
