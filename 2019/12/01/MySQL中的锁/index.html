<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.1.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/icon.jpg">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/icon.jpg">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/icon.jpg">
  <link rel="mask-icon" href="/images/icon.jpg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://Beritra.github.com').hostname,
    root: '/',
    scheme: 'Mist',
    version: '7.6.0',
    exturl: false,
    sidebar: {"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta name="description" content="本文主要摘抄自《MySQL技术内幕（InnoDB存储引擎）第二版》，少部分来自网络博客和自己补充。">
<meta property="og:type" content="article">
<meta property="og:title" content="MySQL中的锁">
<meta property="og:url" content="http:&#x2F;&#x2F;beritra.github.com&#x2F;2019&#x2F;12&#x2F;01&#x2F;MySQL%E4%B8%AD%E7%9A%84%E9%94%81&#x2F;index.html">
<meta property="og:site_name" content="Beritra">
<meta property="og:description" content="本文主要摘抄自《MySQL技术内幕（InnoDB存储引擎）第二版》，少部分来自网络博客和自己补充。">
<meta property="og:image" content="http:&#x2F;&#x2F;nas.beritra.com:18081&#x2F;uploads&#x2F;big&#x2F;bd688943194e21785253085c31ab3068.png">
<meta property="og:image" content="http:&#x2F;&#x2F;nas.beritra.com:18081&#x2F;uploads&#x2F;big&#x2F;60c089a6fc20004f8dfe2448bf718b79.png">
<meta property="og:image" content="http:&#x2F;&#x2F;nas.beritra.com:18081&#x2F;uploads&#x2F;big&#x2F;2dee43dca39b6166f58fa2502037c082.png">
<meta property="og:image" content="http:&#x2F;&#x2F;nas.beritra.com:18081&#x2F;uploads&#x2F;big&#x2F;d4f39c4487a879b52e864613bfae6a13.png">
<meta property="og:image" content="http:&#x2F;&#x2F;nas.beritra.com:18081&#x2F;uploads&#x2F;big&#x2F;459473d464483abf7120afe478c03ade.png">
<meta property="og:image" content="http:&#x2F;&#x2F;nas.beritra.com:18081&#x2F;uploads&#x2F;big&#x2F;4cd48d8a91196d45f528b0ef2ee6c1f9.png">
<meta property="og:image" content="http:&#x2F;&#x2F;nas.beritra.com:18081&#x2F;uploads&#x2F;big&#x2F;582c68591c786071eccc2fcf1878b367.png">
<meta property="og:image" content="http:&#x2F;&#x2F;nas.beritra.com:18081&#x2F;uploads&#x2F;big&#x2F;9941f4666dee54782b182f5eacdcf3a8.png">
<meta property="og:image" content="http:&#x2F;&#x2F;nas.beritra.com:18081&#x2F;uploads&#x2F;big&#x2F;d0ad4367ae0308988d67fafe16ab57d8.png">
<meta property="og:image" content="http:&#x2F;&#x2F;nas.beritra.com:18081&#x2F;uploads&#x2F;big&#x2F;1aba09745c0c14391626b500f0bc1870.png">
<meta property="og:image" content="http:&#x2F;&#x2F;nas.beritra.com:18081&#x2F;uploads&#x2F;big&#x2F;301223cb3933201dd3f24ccfba86ebdb.png">
<meta property="og:image" content="http:&#x2F;&#x2F;nas.beritra.com:18081&#x2F;uploads&#x2F;big&#x2F;526914fec4f38a48344b723dfe357d60.png">
<meta property="og:image" content="http:&#x2F;&#x2F;nas.beritra.com:18081&#x2F;uploads&#x2F;big&#x2F;5fa1953169dcdbe8e205fe9446ab697e.png">
<meta property="og:image" content="http:&#x2F;&#x2F;nas.beritra.com:18081&#x2F;uploads&#x2F;big&#x2F;75e52cbf37518d1129ffec738ac3eba3.png">
<meta property="og:image" content="http:&#x2F;&#x2F;nas.beritra.com:18081&#x2F;uploads&#x2F;big&#x2F;2e8c143f61edc551fced109b87191a03.png">
<meta property="og:image" content="http:&#x2F;&#x2F;nas.beritra.com:18081&#x2F;uploads&#x2F;medium&#x2F;c49c74ec349c32bcfba6252d150c04ad.png">
<meta property="og:image" content="http:&#x2F;&#x2F;nas.beritra.com:18081&#x2F;uploads&#x2F;big&#x2F;beb5c1646f29da096ada91f25e50bcdb.png">
<meta property="og:image" content="http:&#x2F;&#x2F;nas.beritra.com:18081&#x2F;uploads&#x2F;big&#x2F;73be1410494a154abddd702b2fd31e59.png">
<meta property="article:published_time" content="2019-12-01T04:12:12.000Z">
<meta property="article:modified_time" content="2019-12-15T14:25:36.956Z">
<meta property="article:author" content="Beritra">
<meta property="article:tag" content="MySQL">
<meta property="article:tag" content="数据库">
<meta property="article:tag" content="锁">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http:&#x2F;&#x2F;nas.beritra.com:18081&#x2F;uploads&#x2F;big&#x2F;bd688943194e21785253085c31ab3068.png">

<link rel="canonical" href="http://beritra.github.com/2019/12/01/MySQL%E4%B8%AD%E7%9A%84%E9%94%81/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true
  };
</script>

  <title>MySQL中的锁 | Beritra</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Beritra</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">Blogs</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="搜索..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://beritra.github.com/2019/12/01/MySQL%E4%B8%AD%E7%9A%84%E9%94%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avator.jpg">
      <meta itemprop="name" content="Beritra">
      <meta itemprop="description" content="Beritra's Blogs">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Beritra">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          MySQL中的锁
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-12-01 12:12:12" itemprop="dateCreated datePublished" datetime="2019-12-01T12:12:12+08:00">2019-12-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-12-15 22:25:36" itemprop="dateModified" datetime="2019-12-15T22:25:36+08:00">2019-12-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MySQL/" itemprop="url" rel="index">
                    <span itemprop="name">MySQL</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>12k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>20 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>本文主要摘抄自《MySQL技术内幕（InnoDB存储引擎）第二版》，少部分来自网络博客和自己补充。</p>
<a id="more"></a>

<p>开发多用户、数据库驱动的应用时，最大的一个难点是：一方面要最大程度地利用数据库的并发访问，另一方面还要确保每个用户能以一致的方式读取和修改数据。为此就有了锁（locking）的机制，同时这也是数据库系统区别于文件系统的一个关键特性。</p>
<h2 id="什么是锁"><a href="#什么是锁" class="headerlink" title="什么是锁"></a>什么是锁</h2><p>锁机制用于管理对共享资源的并发访问。InnoDB 存储引擎会在行级别上堆表数据上诉哟，这固然不错。不过InnoDB 存储引擎也会在数据库内部其他多个地方使用锁，从而允许堆多种不同资源提供并发访问。例如，操作缓冲池 LRU 列表，删除、添加、移动 LRU 列表中的元素，为了保证一致性，必须有锁的介入。</p>
<h2 id="lock-与-latch"><a href="#lock-与-latch" class="headerlink" title="lock 与 latch"></a>lock 与 latch</h2><p>在数据库中，lock 与 latch 都可以被称为“锁”，但是两者有着截然不同的含义，本文主要关注的是lock。</p>
<p>latch一般称为闩锁（轻量级的锁），因为其要求锁定的时间必须非常短。若持续的时间长，则应用的性能会非常差。在 InnoDB 存储引擎中，latch 又可以分为 mutex（互斥锁）和 rwlock（读写锁）。其目的是用来保证并发线程操作临界资源的正确性，并且通常没有死锁检测的机制。</p>
<p>lock 的对象是事务，用来锁定的是数据库中的对象，如表、页、行。并且一般lock的对象仅在事务 commit 或 rollback 后进行释放（不同事务隔离级别释放的时间可能不同）。此外，lock，正如在大多数数据库中一样，是有死锁机制的。下图显示了 lock 与 latch 的不同：</p>
<p><img src="http://nas.beritra.com:18081/uploads/big/bd688943194e21785253085c31ab3068.png" alt=""></p>
<p>对于 InnoDB 存储引擎中的 latch，可以通过命令<code>SHOW ENGINE INNODB MUTEX</code>来进行查看。具体的数据结果说明如下：</p>
<p><img src="http://nas.beritra.com:18081/uploads/big/60c089a6fc20004f8dfe2448bf718b79.png" alt=""></p>
<p>上述信息是比较底层的，一般仅供开发人员参好。但是用户还是可以通过这些参数调优。</p>
<p>相对于 latch 的查看，lock 的信息就显得直观多了。用户可以通过命令<code>SHOW ENGING INNODB STATUS</code>及<code>infomation_schema</code>架构下的表<code>INNODB_TRX</code>、<code>INNODB_LOCKS</code>、<code>INNODB_LOCK_WAITS</code>来观察锁的信息。</p>
<h2 id="InnoDB-存储引擎中的锁"><a href="#InnoDB-存储引擎中的锁" class="headerlink" title="InnoDB 存储引擎中的锁"></a>InnoDB 存储引擎中的锁</h2><h3 id="锁的类型"><a href="#锁的类型" class="headerlink" title="锁的类型"></a>锁的类型</h3><p>InnoDB 存储引擎实现了如下两种标准的行级锁：</p>
<ul>
<li>共享锁（S Lock），允许事务读一行数据。</li>
<li>排它锁（X Lock），允许事务删除或更新一行数据。</li>
</ul>
<p>如果一个事务 T1 已经获得了行 r 的共享锁，那么另外的事务 T2 可以立即获得行 r 的共享锁，因为读取并没有改变行 r 的数据，称这种情况为锁兼容（Lock Compatible）。但若有其他事务 T3 想获得行 r 的排它锁，则其必须等待事务 T1、T2 释放行 r 上的共享锁——这种情况称为锁不兼容。下表显示了共享锁和排他锁的兼容性。</p>
<p><img src="http://nas.beritra.com:18081/uploads/big/2dee43dca39b6166f58fa2502037c082.png" alt=""></p>
<p>可以看出，X 锁与任何所都不兼容，而 S 锁仅和 S 锁兼容。需要特别注意的是，S 和 X 锁都是行锁，兼容是指对同一记录（row）锁的兼容性情况。</p>
<p>此外，InnoDB 存储引擎支持多粒度（granular）锁定，这种锁定允许事务在行级上的锁和表级上的锁同时存在。为了支持在不同粒度上进行加锁操作，InnoDB 存储引擎支持一种额外的锁方式，称之为意向锁（Intention Lock）。意向锁是将锁定的对象分为多个层次，意向锁意味着事务希望在更细粒度（fine granularity）上进行加锁。</p>
<p>怼细粒度的对象上锁，那么首先需要对粗粒度的对象上锁。如图所示，如果要对页上的对象 r 上 X 锁，那么分别需要堆数据库A、表、页上 IX 锁，最后对记录 r 上 X 锁。若其中任何一部分导致等待，那么操作都需要等粗粒度锁的完成。 </p>
<p><img src="http://nas.beritra.com:18081/uploads/big/d4f39c4487a879b52e864613bfae6a13.png" alt=""></p>
<p>InnoDB 引擎支持意向锁设计的比较简练，其意向锁即为表级别的锁。设计目的主要是为了在一个事务中揭示下一行将被请求的锁类型。其支持两种意向锁：</p>
<ol>
<li>意向共享锁（IS Lock），事务想要获得一张表中某几行的共享锁。</li>
<li>意向排他锁（IX Lock），事务想要获得一张表中某几行的排它锁。</li>
</ol>
<p>由于 InnoDB 存储引擎支持的是行级别的锁，因此意向锁不会阻塞除全表扫描以外的任何请求。表级意向锁和行级锁的兼容性如图所示：</p>
<p><img src="http://nas.beritra.com:18081/uploads/big/459473d464483abf7120afe478c03ade.png" alt=""></p>
<p>用户可以通过命令<code>SHOW ENGINE INNODB STATUS</code>命令查看当前锁请求的信息</p>
<p>从 InnoDB 1.0 开始，在<code>INFORMATION_SCHEMA</code>架构下添加了表<code>INNODB_TRX</code>、<code>INNODB_LOCKS</code>、<code>INNODB_LOCKS_WAITS</code>。通过这三张表，用户可以更简单地监控当前事务并分析可能存在的锁问题。<code>INNODB</code>的定义如下图所示，一共8个字段（在MySQL 8.0 版本进行测试，发现已经扩充到了24个字段）：</p>
<p><img src="http://nas.beritra.com:18081/uploads/big/4cd48d8a91196d45f528b0ef2ee6c1f9.png" alt=""></p>
<p>这个表可以显示当前运行的 InnoDB 事务，并不能判断锁的一些情况。如果需要查看锁，则还需要访问表<code>INNODB_LOCKS</code>，该表的字段如下所示：</p>
<p><img src="http://nas.beritra.com:18081/uploads/big/582c68591c786071eccc2fcf1878b367.png" alt=""></p>
<p>再通过表<code>INNODB_LOCKS</code>查看了每张表上锁的情况后，用户就可以判断由此引发的等待状况了。当事务较小时，用户就可以人为地、直观地进行判断了。但是当事务量非常大，其中锁和等待也时常发生，这个时候就不那么容易判断。但是通过表<code>INNODB_LOCK_WAIT</code>，可以很直观地反应当前事务的等待。表<code>INNODB_LOCK_WAITS</code>由四个字段组成，如下图所示。</p>
<p><img src="http://nas.beritra.com:18081/uploads/big/9941f4666dee54782b182f5eacdcf3a8.png" alt=""></p>
<blockquote>
<p>注意：在MySQL 8.0 版本中，INFORMATION_SCHEMA下的INNODB_LOCKS和INNODB_LOCK_WAITS表已被删除。 用Performance Schema data_locks和data_lock_waits表替代。</p>
</blockquote>
<h3 id="一致性非锁定读"><a href="#一致性非锁定读" class="headerlink" title="一致性非锁定读"></a>一致性非锁定读</h3><p>一致性的非锁定读（consistent nonlocking read）是指 InnoDB 存储引擎通过行多版本控制（multi versioning）的方式来读取当前执行时间数据库中行的数据。如果读取的行正在执行 DELETE 或者 UPDATE 操作，这时读取操作不会因此去等待行上锁的释放。相反的，InnoDB 存储引擎会去读取行的一个快照存储。</p>
<p>之所以称其为非锁定读，因为不需要等待访问的行上 X 锁的释放。快照数据是指该行的之前版本的数据，该实现是通过 undo 段来完成，而 undo 用来在事务中回滚数据，因此快照数据本身是没有额外的开销的。此外，读取快照数据是不需要上锁的吗，因为没有事务需要对历史的数据进行修改操作。</p>
<p>可以看出，非锁定读机制极大地提提高了数据库的并发性。在 InnoDB 存储引擎的默认设置下，这是默认的读取方式，即读取不会占用和等待表上的锁。但是在不同事务隔离级别下，读取的方式不同，并不是在每个事务隔离级别下都是采用的非锁定的一致性读。此外，即使都是采用的非锁定的一致性读，但是对于快照数据的定义也各不相同。</p>
<p>在事务隔离级别<code>READ COMMITTED</code>和<code>REPEATABLE READ</code>（InnoDB存储引擎的默认事务隔离级别）下，InnoDB 存储引擎使用非锁定的一致性读。然而，对于快照数据的定义却不相同。在<code>READ COMMITTED</code>事务隔离级别下，对于快照数据，非一致性读总是读取被锁定行的最新一份快照数据。而在<code>REPEATABLE READ</code>事务隔离级别下，对于快照数据，非一致性读总是读取事务开始时的行数据版本。</p>
<p>举个栗子，首先在当前 MySQL 数据库的连接回话 A 中执行以下 SQL 语句：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">mysql&gt; begin;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">Query OK, 0 rows affected (0.01 sec)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from parent where id &#x3D;1;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">+------+</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">| id   |</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">+------+</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">|    1 |</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">+------+</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">1 row in set (0.00 sec)</span></pre></td></tr></table></figure>

<p>在会话 A 显式的开启了一个事务，并读取了表 parent 中 id 为 1 的数据，但是事务并没有结束。与此同时，用户再开启另一个回话B，这样可以模拟并发的情况，然后对 B 做如下的操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">mysql&gt; begin;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">Query OK, 0 rows affected (0.00 sec)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">mysql&gt; update parent set id&#x3D;3 where id&#x3D;1;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">Query OK, 1 row affected (0.00 sec)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">Rows matched: 1  Changed: 1  Warnings: 0</span></pre></td></tr></table></figure>

<p>在会话 B 中将事务表 parent 中 id 为 1 的记录修改为 id=3 ，但是事务同样没有提交。这样 id=1 的行实际上加了一个 X 锁。这时如果在会话 A 中再次读取 id 为 1 的记录，根据 InnoDB 引擎的特性，即在<code>READ COMMITTED</code>和<code>REPEATETABLE READ</code>的事务隔离级别下会使用非锁定的一致性读。回到之前的会话 A ，接着上次未提交的事务，执行 SQL 语句 <code>select * from parent where id=1</code>的操作，这时不管使用<code>READ COMMITTED</code>还是<code>REPEATETABLE READ</code>的事务隔离级别，显示的数据应该都是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from parent where id &#x3D;1;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">+------+</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">| id   |</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">+------+</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">|    1 |</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">+------+</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">1 row in set (0.00 sec)</span></pre></td></tr></table></figure>

<p>由于当前 id=1 的数据被修改了1次，因此只有一个行办本的记录。接着，在会话 B 中提交上次的事务：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">mysql&gt; commit;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">Query OK, 0 rows affected (0.00 sec)</span></pre></td></tr></table></figure>

<p>在会话 B 提交事务之后，在会话 A 中再次运行<code>select * from parent where id=1</code>语句，在<code>READ COMMITTED</code>和<code>REPEATETABLE READ</code>的事务隔离级别下得到的结果就不一样了。对于<code>READ COMMITTED</code>的事务隔离级别，它总是能够读取行的最新版本，如果行被锁定了，则读取最新的一个快照（fresh snapshot）。在上述例子中，因为会话 B 已经提交了事务，所以<code>READ COMMITTED</code>事务隔离级别下会得到如下结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">mysql&gt; select @@transaction_isolation\G;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">*************************** 1. row ***************************</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">@@transaction_isolation: REPEATABLE-READ</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">1 row in set (0.00 sec)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from parent where id &#x3D;1;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">Empty set (0.00 sec)</span></pre></td></tr></table></figure>

<p>而对于<code>REPEATABLE READ</code>的事务隔离级别，总是读取事务开始时的行数据。因此对于<code>REPEATABLE REPEAD</code>事务隔离级别，得到的结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">mysql&gt; select @@transaction_isolation\G;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">*************************** 1. row ***************************</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">@@transaction_isolation: REPEATABLE-READ</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">1 row in set (0.00 sec)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from parent where id &#x3D;1;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">+------+</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">| id   |</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">+------+</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">|    1 |</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">+------+</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">1 row in set (0.00 sec)</span></pre></td></tr></table></figure>

<blockquote>
<p>注意，MySQL 8.0 之前查询当前事务隔离级别的语句是<code>select @@tx_isolation</code>，之后是上面用的<code>select @@transaction_isolation</code></p>
</blockquote>
<p>下面将从时间的角度上展现上述演示的示例过程，如下表所示。需要特别注意的是，对于<code>READ COMMITTED</code>的事务隔离级别而言，从数据库理论的角度来看，其违反了事务 ACID 中的 I 的特性，即隔离性。</p>
<p><img src="http://nas.beritra.com:18081/uploads/big/d0ad4367ae0308988d67fafe16ab57d8.png" alt=""></p>
<h3 id="一致性锁定锁"><a href="#一致性锁定锁" class="headerlink" title="一致性锁定锁"></a>一致性锁定锁</h3><p>在前一节讲到，默认配置下，事务隔离级别是<code>REPEATABLE READ</code>模式，InnoDB 存储引擎的<code>SELECT</code>操作使用一致性非锁定锁。但是在某些情况下，用户需要显式得堆数据库读取操作进行加锁以保证数据逻辑的一致性。InnoDB 存储引擎对于<code>SELECT</code>语句支持两种一致性的锁定读（locking read）操作：</p>
<ul>
<li>SELECT … FOR UPDATE</li>
<li>SELECT … LOCK IN SHARE MODE</li>
</ul>
<p><code>SELECT ... FOR UPDATE</code>堆读取的行记录加一个 X 锁，其他事务不能对已锁定的行加上任何锁。<code>SELECT ... LOCK IN SHARE MODE</code>对读取的行加一个 S 锁，其他事务可以向被锁定的行加 S 锁，但是如果加 X 锁，就会被阻塞。</p>
<p>以上这两个语句必须在同一个事务中，当事务提交了，锁也就释放了。因此在使用两个<code>SELECT</code> 锁的时候，务必记得带上<code>BEGIN</code>，<code>START TRANSACTION</code>或者<code>SET AUTOCOMMIT=0</code>。</p>
<h3 id="自增长与锁"><a href="#自增长与锁" class="headerlink" title="自增长与锁"></a>自增长与锁</h3><p>自增长是非常常用的一个属性，在 InnoDB 引擎的内存结构中，对每个含有自增长值的表都有一个自增长计数器（auto-increment counter）。当对含有自增长的计数器的表进行插入操作时，这个计数器会被初始化，执行如下的语句来得到计数器的值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">SELECT MAX(auto_inc_col) FROM t FOR UPDATE;</span></pre></td></tr></table></figure>

<p>插入操作会依据这个自增的计数器的值加 1 赋予自增长列。这个实现方式称作<code>AUTO-INC Locking</code>。这个锁其实是采用一种特殊的表锁机制，为了提高插入的性能，锁不是在一个事务完成后才释放，而是在完成对自增长值插入 SQL 语句后立即释放。</p>
<p>虽然<code>AUTO-INC Locking</code>从一定程度上提高了并发插入的效率，但是还存在一定性能上的问题。首先对于自增长值得咧并发插入性能较差，事务必须等待前一个插入完成。其次，对于<code>INSERT ... SELECT</code>的大数据量插入会影响插入性能。因为另一个事务中的插入会被阻塞。</p>
<p>从 MySQL 5.1.22 开始，InnoDB 存储引擎中提供了一种轻量级互斥锁的自增长实现机制，这种机制大大提高了自增值的插入性能。从该版本开始，InnoDB 存储引擎提供了一个参数<code>innodb_autoinc_lock_mode</code>来控制自增长的模式，该参数的默认值为 1 。我们对自增长的插入进行分类的话，如图所示。</p>
<p><img src="http://nas.beritra.com:18081/uploads/big/1aba09745c0c14391626b500f0bc1870.png" alt=""></p>
<p>接着来分析参数<code>innodb_autoinc_lock_mode</code>以及各个设置下堆自增的印象，总共有三个有效值可供供设定，即0、1、2，具体说明如下表所示：</p>
<p><img src="http://nas.beritra.com:18081/uploads/big/301223cb3933201dd3f24ccfba86ebdb.png" alt=""></p>
<p>在 InnoDB 存储引擎中，自增长的列必须是索引，同时必须是索引的第一个列。如果不是第一个列，则 MySQL 数据库会抛出异常。</p>
<h3 id="外键和锁"><a href="#外键和锁" class="headerlink" title="外键和锁"></a>外键和锁</h3><p>在 InnoDB 存储引擎中，对于一个外键列，如果没有显式的对这个列加索引，InnoDB 引擎会自动加一个索引，因为这样可以避免表锁。对于外键的插入或更新，首先需要查询父表中的记录，即 SELECT 父表。单是对于父表的 SELECT 操作，不是使用一致性非锁定读的方式，因为这样会发生数据不一致的问题。因此这时使用的是<code>SELECT ... LOCK IN SHARE MODE</code>方式，即主动对父表加一个 S 锁。如果这时候父表已经加上了一个 X 锁，子表上的操作会被阻塞。</p>
<h2 id="锁的算法"><a href="#锁的算法" class="headerlink" title="锁的算法"></a>锁的算法</h2><h3 id="行锁的-3-种算法"><a href="#行锁的-3-种算法" class="headerlink" title="行锁的 3 种算法"></a>行锁的 3 种算法</h3><p>InnoDB 存储引擎有三种行锁的算法，分别是：</p>
<ul>
<li>Record Lock：单个行记录上的锁</li>
<li>Rap Lock：间隙锁，锁定一个范围，但不包含记录本身</li>
<li>Next-Key Lock：Gap Lock+Record Lock，锁定一个范围，并且锁定记录本身</li>
</ul>
<p>Record Lock 总是回去锁住索引记录，如果 InnoDB 存储引擎表在建立的时候没有设置任何一个索引，那么这是 InnoDB 存储引擎会使用隐式的主键来进行锁定。</p>
<p>Next-Key Lock 是结合了 Gap Lock 和 Record Lock 的一种锁定算法，在 Next-Key Lock 算法下，InnoDB 对于行的查询都是采用这种锁定算法。例如一个索引有10，11，13和20这四个值，那么该索引可能被 Next-Key Lock 的区间为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">(-∞，10]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">(10，11]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">(11，13]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">(13，20]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">(20，+∞)</span></pre></td></tr></table></figure>

<p>采用 Next-Key Lock 的锁定技术称为 Next-Key Locking。其设计的目的是为了解决 Phantom Problem，这将在下一个小节介绍。利用这种技术，锁定的不是单个值，而是一个范围，是谓词锁（predict lock）的一种改进。除了 Next-Key Locking，还有 Previous-Key Locking 技术。</p>
<p>同样上述索引10，11，13和20，如果采用 Previous-Key Locking 技术，可锁定的区间会变成：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">(-∞，10)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">[10，11)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">[11，13)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">[13，20)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">[20，+∞)</span></pre></td></tr></table></figure>

<p>若事务 T1 已经通过 Next-Key Locking 锁定了如下范围：</p>
<p><code>(10,11]、(11,13]</code></p>
<p>当插入新的记录 12 的时候，锁定的范围会变成：</p>
<p><code>(10,11]、(11,12]、(12,13]</code></p>
<p>当查询的索引含有唯一属性的时候，InnoDB 存储引擎会对 Next-Key Lock 进行优化，将其降级为 Record Lock，即仅锁住索引本身，而不是范围，从而提高应用的并发性。</p>
<p>使用下列代码创建测试表 t ：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">create table t(a int primary key);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">insert into t select 1;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">insert into t select 2;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">insert into t select 5;</span></pre></td></tr></table></figure>

<p>然后执行下列语句：</p>
<p><img src="http://nas.beritra.com:18081/uploads/big/526914fec4f38a48344b723dfe357d60.png" alt=""></p>
<p>表 t 一共只有1、2、5 三个值。在上面的例子中，会话 A 首先对 a=5 进行 X 素哟定。而由于 a 是主键且唯一，因此锁定的仅仅是 5 这个值，而不是（2,5）这个范围，这样在会话 B 中插入值 4 而不会阻塞，可以立即插入并返回。</p>
<p>若是辅助索引，情况会完全不同。根据下列代码创建测试表 z：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">mysql&gt; create table z(a int,b int, primary key(a),key(b));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">mysql&gt; insert into z select 1,1;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">mysql&gt; insert into z select 3,1;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">mysql&gt; insert into z select 5,3;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">mysql&gt; insert into z select 7,6;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">mysql&gt; insert into z select 10,8;</span></pre></td></tr></table></figure>

<p>表 z 的列 b 是辅助索引，若在会话 A 中开启事务，执行下面的 SQL 语句：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">select  * from z where b&#x3D;3 for update;</span></pre></td></tr></table></figure>

<p>这时 SQL 语句将通过索引列 b 进行查询，因此使用传统的 Next-Key Locking技术进行加锁，并且由于有两个索引，需要对其分别加锁。对于聚集索引，仅对列 a 等于 5 的索引加上 Record Lock。而对于辅助索引，其加上的是 Next-Key Lock，锁定范围是（1,3），需要特别注意的，InnoDB 存储引擎还会对辅助索引下一个键值加上 gap lock，即还有一个辅助索引范围为（3,6）的锁，因此，若在新回话 B 中运行下面的 SQL 语句，都会被阻塞。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">select * from z where a&#x3D;5 lock in share mode;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">insert into z select 4,2;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">insert into z select 6,5;</span></pre></td></tr></table></figure>

<p>原因如下：</p>
<ul>
<li>第一个 SQL 语句不能执行，因为在会话 A 中执行的 SQL 语句已经对聚集索引中列 a=5 的值加上 X 锁，因此执行会被阻塞。</li>
<li>第二个 SQL 语句，主键插入 4 ，没有问题，但是插入的辅助索引 2 在锁定的范围（1,3）中，所以同样会阻塞</li>
<li>第三个 SQL 语句，插入的主键 6 没有被锁定，5 也不在范围（1,3）之间，但是插入的值 5 在另一个锁定的范围（3,6）中，所以同样需要等待。</li>
</ul>
<p>上面的例子可以看出，Gap Lock 的作用是为了阻止多个事务将记录插入到同一个范围内，而这会导致 Phantom Problem 问题的产生。例如上面的例子中，会话 A 用户锁定了 b=3 的记录，如果此时没有锁定（3,6），那么用户可以插入 b 列为 3 的记录，这会导致会话 A 中的用户再次执行查询时返回不同的记录，这就导致了 Phantom Problem 问题的产生。</p>
<p>用户可以通过以下两种方式来显式的关闭 Gap Lock：</p>
<ul>
<li>将事务的隔离级别设置为<code>READ COMMITTED</code></li>
<li>将参数<code>innodb_locks_unsafe_for_binlog</code>设置为 1</li>
</ul>
<p>在上述配置下，除了外键约束和唯一性检查仍然需要 Gap Lock，其余情况仅使用 Record Lock 进行锁定。但需要牢记的是，上述设置破坏了事务的隔离性，并且对于 replication，可能会导致主从数据的不一致。因此从性能上看，<code>READ COMMITTED</code>也不会优于默认的事务隔离级别<code>READ REPEATABLE</code>。</p>
<p>需要再次提醒的是，对于唯一键值的锁定，Next-Key Lock 降级为 Record Lock 仅存在于查询所有的唯一索引列。若唯一索引由多个列组成，而查询仅是查找多个唯一索引列中的其中一个，那么查询其实是 range 类型查询，而不是 point 类型查询，故 InnoDB 存储引擎依然使用 Next-Key Lock 进行锁定。</p>
<h3 id="解决-Phantom-Problem"><a href="#解决-Phantom-Problem" class="headerlink" title="解决 Phantom Problem"></a>解决 Phantom Problem</h3><p>在默认的事务隔离级别下，即<code>REPEATABLE READ</code>下，InnoDB 存储引擎采用 Next-Key Locking 机制来避免 Phantom Problem（幻想问题）。</p>
<p>Phantom Problem 是指在同一事务下，连续执行两次同样的 SQL 可能导致不同的结果，第二次的 SQL 语句可能会返回之前不存在的行。</p>
<p>还是以上一节创建的表 t 为例，表 t 由 1、2、5 三个值组成，如果事务 T1 执行如下 SQL 语句：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">select * from t where a&gt;2 for update;</span></pre></td></tr></table></figure>

<p>注意这时候 T1 并没有进行提交操作，上述应该返回 5 这个结果。如果与此同时，另一个事务 T2 插入了 4 这个值，并且数据库允许该操作，那么事务 T1 再次执行查询 SQL 语句的时候，就会得到结果 4 和 5 。这与第一次查询的结果不同，违反了事务的隔离性，即当前事务可以看到其他事务的结果。</p>
<p>InnoDB 引擎采用了 Next-Key Locking 算法避免出现上面的情况。对于上面的 SQL，实际上锁住的不只是 5 这个单个值，而是对（2,+∞）范围都加了 X 锁，因此对于这个范围内的插入都是不允许的，从而避免 Phantom Problem。</p>
<p>InnoDB 引擎默认的事务隔离级别是<code>REPEATABLE READ</code>，在该隔离级别下，采用 Next-Key Locking 来加锁。而在事务隔离级别<code>READ COMMITTED</code>级别下，仅采用 record Lock，因此在上述示例中，会话 A 需要将事务的隔离级别设置为<code>READ COMMITTED</code>。</p>
<p>此外，用户可以通过 InnoDB 存储引擎的 Next-Key Locking 机制在应用层面实现唯一性检查：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">select * from table where col&#x3D;xxx lock in share mode;</span></pre></td></tr></table></figure>

<p>如果用户通过索引查询一个值，并对该行加上一个 SLock，那么即使查询的值不存在，锁定的也是一个范围，因此若此行没有任何返回，那么新插入的值一定是唯一的。</p>
<p>这里如果在第一步<code>select ... lock in share mode</code>操作的回收，有多个事务并发操作，这种唯一性检查机制是否存在问题呐？答案是不会，因为这时候会导致死锁，只有一个事务操作成功，其他会抛出死锁的错误提示。</p>
<h2 id="锁问题"><a href="#锁问题" class="headerlink" title="锁问题"></a>锁问题</h2><p>通过锁定机制可以实现事务的隔离性要求，使得事务可以并发的工作。锁提高了并发，但是也有潜在的问题。不过好在事务隔离性的要求，锁只会带来以下三种问题。</p>
<h3 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h3><p>在理解脏读（Dirty Read）之前，需要理解脏数据的概念。脏数据是指未提交的数据，如果读到了脏数据，即一个事务可以读到另外一个事务未提交的数据，则显然违反了数据的隔离性。</p>
<p>下面的表格显示了一个脏读的例子：</p>
<p><img src="http://nas.beritra.com:18081/uploads/big/5fa1953169dcdbe8e205fe9446ab697e.png" alt=""></p>
<p>表 t 还是上面创建的那个，不过不同于上述例子，这里把事务隔离级别改成了<code>READ UNCOMMITTED</code>。因此在会话 A 未提交的前提下，事务 B 两次 SELECT 取得了不同结果，即产生了脏读。</p>
<p>脏读现象在生产环境并不经常发生，由上面例子可以看出来，脏读需要隔离级别为<code>READ UNCOMMITTED</code>，实际上大多数数据库至少都是<code>READ COMMITTED</code>，而 InnoDB 默认的都是<code>READ REPEATABLE</code>。</p>
<p>脏读隔离看似毫无用处，但是一些特殊的情况下还可以将事务的隔离级别放开到<code>READ UNCOMMITTED</code>。例如 replication 环境下的 slave 节点，并且在该 slave 节点上的查询并不需要特别精确的返回值。、</p>
<h3 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h3><p>不可重复读是指在一个事务内多次读取同一个数据集合。在这个事务还没有结束时，另一个事务也访问该同一个数据集合，并做了一些 DML 操作。因此在第一个事务两次读数据之间，由于第二个事务的修改，那么第一个事务读到的数据可能是不一样的。这种情况成为不可重复读。</p>
<p>不可重复读和脏读的区别：脏读读到的是未提交的数据，不可重复读读到的却是提交过的数据，但是其违反了数据库事务一致性的要求。下面的表格展示了一个例子：</p>
<p><img src="http://nas.beritra.com:18081/uploads/big/75e52cbf37518d1129ffec738ac3eba3.png" alt=""></p>
<p>这个例子的前提是，两个事务的隔离级别都调整为<code>READ COMMITTED</code>。会话 B 的事务提交之后，事务 A 进行读取，读到的是 1 和 2 两条记录。</p>
<p>一般情况下，不可重复读是可以接受的，因为读到的是已经提交的数据，本身不会带来太大的问题，因此很多数据库的默认级别设置为<code>READ COMMITTED</code>，允许不可重复读。</p>
<p>在 InnoDB 存储引擎中，使用 Next-Key Lock 算法来避免不可重复读的问题。在 Next-Key Lock 算法下，对于索引的扫描，不仅是锁住了扫描到的索引，还锁着了索引覆盖的范围（gap）。因此在这个范围内的插入都是不被允许的。这样就避免了其他事务在这个范围内插入数据导致不可重复读的问题。</p>
<h3 id="丢失更新"><a href="#丢失更新" class="headerlink" title="丢失更新"></a>丢失更新</h3><p>丢失更新是另一个锁导致的问题，简单来说就是一个事务的更新操作会被另一个事务的更新操作覆盖，从而导致数据不一致。例如：</p>
<ol>
<li>事务 T1 将行记录 r 更新为 v1，但是事务 T1 尚未提交。</li>
<li>与此同时，事务 T2 将行记录 r 更新为 v2，事务 T2 未提交。</li>
<li>事务 T1 提交。</li>
<li>事务 T2 提交。</li>
</ol>
<p>虽然在数据库的任何隔离级别下，都不会导致理论意义上的丢失更新问题，即使是<code>READ UNCOMMITTED</code>的事务隔离级别，对于任何行的 DML 操作，需要对行或者其他粗粒度级别的对象加锁。因此上述步骤中，T2 的更新操作不能顺利执行，会被阻塞。</p>
<p>但是，生产中还会出现类似的另一个逻辑意义上的丢失更新问题，尤其是多用户的计算机系统环境下：</p>
<ol>
<li>事务 T1 查询一行数据，放到本地内存，并显示给一个终端用户 User1。</li>
<li>与此同时，事务 T2 也查询了数据，将数据展示给另一个用户 User2。</li>
<li>User1 修改了这行记录，更新数据库提交。</li>
<li>User2 也修改了记录，更新数据库提交。</li>
</ol>
<p>显然，这个过程中 User1  的更新操作“丢失”了。为了避免这种问题，需要让事务操作串行化，而不是并行。即在操作步骤 1 中，对用户读取的记录加上一个排他锁 X 。同样，在步骤 2 中，同样需要加入排它锁 X 。通过这种方式，步骤 2 就必须等待步骤 1 和 3 完成。下面的表格演示了如何避免上述逻辑上丢失更新问题的产生。</p>
<p><img src="http://nas.beritra.com:18081/uploads/big/2e8c143f61edc551fced109b87191a03.png" alt=""></p>
<h2 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a>阻塞</h2><p>由于不同锁之间的兼容关系，有时候一个事务中的锁需要等待另一个事务中的锁释放它占用的资源，这就是阻塞。</p>
<p>在 InnoDB 存储引擎中，参数<code>innodb_lock_wait_timeout</code>控制等待时间，<code>innodb_rollback_on_timeout</code>用来设定是否在等待超时时堆进行中的事务进行回滚操作。参数<code>innodb_lock_wait_timeout</code>是动态的，可以在数据库运行时动态调整，而<code>innodb_rollback_on_timeout</code>是静态的，不能在运行中修改。</p>
<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><h3 id="死锁的概念"><a href="#死锁的概念" class="headerlink" title="死锁的概念"></a>死锁的概念</h3><p>死锁是指两个或两个以上事务在执行过程中，因争夺锁资源而造成的一种相互等待的现象。</p>
<p>解决死锁最简单的方式是超时，当两个事务相互等待的时候，当其中一个等待超过阈值，进行回滚，另一个事务就可以继续进行。超时机制虽然简单，但是仅仅通过超时后事务回滚的方式处理，或者根据 FIFO 的顺序选择回滚对象。但如果超时的事务所占权重比较大，如事务操作更新很多航，占用了较多的 undo log，这时候采用 FIFO 的方式就不合适了。</p>
<p>因此，除了超时机制，当前数据库还普遍采用 wait-for graph（等待图）的方式来进行死锁检测。 wait-for graph 要求数据库保存以下两种信息：</p>
<ul>
<li>锁的信息链表</li>
<li>事务等待链表</li>
</ul>
<p>通过上述链表可以构造一张图，如果这张图中存在回路，就代表的存在死锁。 wait-for graph 是一种比较主动的死锁检测机制，InnoDB 一般会选择回滚 undo 量最小的事务。</p>
<h3 id="死锁概率"><a href="#死锁概率" class="headerlink" title="死锁概率"></a>死锁概率</h3><p>死锁的概率推导过程就不抄了，直接截图放这里：</p>
<p><img src="http://nas.beritra.com:18081/uploads/medium/c49c74ec349c32bcfba6252d150c04ad.png" alt=""></p>
<p>可以看出死锁发生概率与以下几点有关：</p>
<ul>
<li>系统中事务数量（n），数量越多死锁概率越大。</li>
<li>每个事务的操作量，数量越多死锁概率越大。</li>
<li>操作数据的集合（R），越小则死锁的概率越大。</li>
</ul>
<h3 id="死锁的示例"><a href="#死锁的示例" class="headerlink" title="死锁的示例"></a>死锁的示例</h3><p>下面的表演示了一个死锁的经典情况：</p>
<p><img src="http://nas.beritra.com:18081/uploads/big/beb5c1646f29da096ada91f25e50bcdb.png" alt=""></p>
<p>上面的例子中，会话 B 抛出了 1213 这个错误提示，即表示事务发生了死锁。大多数死锁 InnoDB 引擎本身可以侦测到，不需要人为进行干预。</p>
<p>还有另外一种情况，即当前事务持有了待插入记录的下一个记录的 X 锁，但是在等待队列中存在一个 S 锁的请求，则可能发生死锁。举个栗子，先创建一个表：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">CREATE TABLE t( a INT PRIMARY KEY)ENGINE&#x3D;INNODB;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">INSERT INTO t VALUES (1),(2),(4),(5);</span></pre></td></tr></table></figure>

<p>然后运行下表所示的查询：</p>
<p><img src="http://nas.beritra.com:18081/uploads/big/73be1410494a154abddd702b2fd31e59.png" alt=""></p>
<p>可以看到，会话 A 中已经对记录 4 持有了 X 锁，但是会话 A 中插入记录 3 时会导致死锁发生。这个问题的产生是由于会话 B 中请求记录 4 的 S 锁而发生等待，但之前请求的锁对于主键值记录 1、2 都已经成功，若在时间点 5 能插入记录，那么会话 B 在获得记录 4 持有的 S 锁之后，还需要向后获得记录 3 的记录，这样就显得不合理。因此 InnoDB 引擎在这里主动选择了死锁，而回滚的是 undo log 记录大的事务，这与 AB-BA 死锁的处理方式又有所不同。</p>
<h2 id="锁升级"><a href="#锁升级" class="headerlink" title="锁升级"></a>锁升级</h2><p>锁升级（Lock Escalation）是指将当前锁的粒度降低。举例来说，数据库可以吗一个表的 1000 个行锁升级为一个页锁，或者页锁升级为一个表锁。如果数据库设计中认为锁是稀有资源，想要尽量避免锁的开销，就会频繁出现锁升级现象。</p>
<p>InnoDB 存储引擎不存在锁升级的问题。因为其不是根据每个记录来产生行锁的，而是采用位图。不管一个事务锁住页中的一个记录还是多个记录，开销通常都是一致的。</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/MySQL/" rel="tag"># MySQL</a>
              <a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="tag"># 数据库</a>
              <a href="/tags/%E9%94%81/" rel="tag"># 锁</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2019/01/01/%E7%A6%BB%E7%BA%BF%E7%8E%AF%E5%A2%83%E4%B8%8BKeepalived+MySQL%208.0%E5%AE%89%E8%A3%85%E5%92%8C%E5%8F%8C%E4%B8%BB%E9%AB%98%E5%8F%AF%E7%94%A8%E9%85%8D%E7%BD%AE/" rel="prev" title="Keepalived+MySQL双主高可用配置">
      <i class="fa fa-chevron-left"></i> Keepalived+MySQL双主高可用配置
    </a></div>
      <div class="post-nav-item">
    <a href="/2019/12/01/MySQL%E4%B8%AD%E7%9A%84%E4%BA%8B%E5%8A%A1/" rel="next" title="MySQL中的事务">
      MySQL中的事务 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#什么是锁"><span class="nav-number">1.</span> <span class="nav-text">什么是锁</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#lock-与-latch"><span class="nav-number">2.</span> <span class="nav-text">lock 与 latch</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#InnoDB-存储引擎中的锁"><span class="nav-number">3.</span> <span class="nav-text">InnoDB 存储引擎中的锁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#锁的类型"><span class="nav-number">3.1.</span> <span class="nav-text">锁的类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#一致性非锁定读"><span class="nav-number">3.2.</span> <span class="nav-text">一致性非锁定读</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#一致性锁定锁"><span class="nav-number">3.3.</span> <span class="nav-text">一致性锁定锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#自增长与锁"><span class="nav-number">3.4.</span> <span class="nav-text">自增长与锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#外键和锁"><span class="nav-number">3.5.</span> <span class="nav-text">外键和锁</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#锁的算法"><span class="nav-number">4.</span> <span class="nav-text">锁的算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#行锁的-3-种算法"><span class="nav-number">4.1.</span> <span class="nav-text">行锁的 3 种算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#解决-Phantom-Problem"><span class="nav-number">4.2.</span> <span class="nav-text">解决 Phantom Problem</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#锁问题"><span class="nav-number">5.</span> <span class="nav-text">锁问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#脏读"><span class="nav-number">5.1.</span> <span class="nav-text">脏读</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#不可重复读"><span class="nav-number">5.2.</span> <span class="nav-text">不可重复读</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#丢失更新"><span class="nav-number">5.3.</span> <span class="nav-text">丢失更新</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#阻塞"><span class="nav-number">6.</span> <span class="nav-text">阻塞</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#死锁"><span class="nav-number">7.</span> <span class="nav-text">死锁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#死锁的概念"><span class="nav-number">7.1.</span> <span class="nav-text">死锁的概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#死锁概率"><span class="nav-number">7.2.</span> <span class="nav-text">死锁概率</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#死锁的示例"><span class="nav-number">7.3.</span> <span class="nav-text">死锁的示例</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#锁升级"><span class="nav-number">8.</span> <span class="nav-text">锁升级</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Beritra"
      src="/images/avator.jpg">
  <p class="site-author-name" itemprop="name">Beritra</p>
  <div class="site-description" itemprop="description">Beritra's Blogs</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">28</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">16</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">40</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/beritra" title="Github → https:&#x2F;&#x2F;github.com&#x2F;beritra" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>Github</a>
      </span>
      <span class="links-of-author-item">
        <a href="http://weibo.com/u/3315421093" title="Weibo → http:&#x2F;&#x2F;weibo.com&#x2F;u&#x2F;3315421093" rel="noopener" target="_blank"><i class="fa fa-fw fa-weibo"></i>Weibo</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Beritra</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    <span title="站点总字数">190k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">5:16</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
